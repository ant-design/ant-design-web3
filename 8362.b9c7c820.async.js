"use strict";(self.webpackChunk_ant_design_web3_docs=self.webpackChunk_ant_design_web3_docs||[]).push([[8362],{49678:function(gn,Ne,mt){mt.d(Ne,{secp256k1:function(){return Qt}});var Rt={};mt.r(Rt),mt.d(Rt,{Fy:function(){return st},uw:function(){return ft},gk:function(){return yt},Dd:function(){return fe},dQ:function(){return Vt},ci:function(){return at},bytesToNumberBE:function(){return ot},ty:function(){return Ut},eV:function(){return pt},n$:function(){return ue},ql:function(){return D},hexToBytes:function(){return lt},Z2:function(){return Nt},_t:function(){return rt},H9:function(){return Mt},tL:function(){return dt},S5:function(){return Ct},uz:function(){return ut},FF:function(){return xt}});var nt=mt(74789),R=mt(3893);function _e(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),s=BigInt(4294967295),c=Number(e>>o&s),f=Number(e&s),i=r?4:0,u=r?0:4;t.setUint32(n+i,c,r),t.setUint32(n+u,f,r)}function Te(t,n,e){return t&n^~t&e}function He(t,n,e){return t&n^t&e^n&e}class Le extends R.kb{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=(0,R.GL)(this.buffer)}update(n){(0,nt.$h)(this);const{view:e,buffer:r,blockLen:o}=this;n=(0,R.O0)(n);const s=n.length;for(let c=0;c<s;){const f=Math.min(o-this.pos,s-c);if(f===o){const i=(0,R.GL)(n);for(;o<=s-c;c+=o)this.process(i,c);continue}r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){(0,nt.$h)(this),(0,nt.eB)(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:s}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let l=c;l<o;l++)e[l]=0;_e(r,o-8,BigInt(this.length*8),s),this.process(r,0);const f=(0,R.GL)(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=i/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<u;l++)f.setUint32(4*l,h[l],s)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:s,destroyed:c,pos:f}=this;return n.length=o,n.pos=f,n.finished=s,n.destroyed=c,o%e&&n.buffer.set(r),n}}const ke=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),$=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),J=new Uint32Array(64);class Re extends Le{constructor(){super(64,32,8,!1),this.A=$[0]|0,this.B=$[1]|0,this.C=$[2]|0,this.D=$[3]|0,this.E=$[4]|0,this.F=$[5]|0,this.G=$[6]|0,this.H=$[7]|0}get(){const{A:n,B:e,C:r,D:o,E:s,F:c,G:f,H:i}=this;return[n,e,r,o,s,c,f,i]}set(n,e,r,o,s,c,f,i){this.A=n|0,this.B=e|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=c|0,this.G=f|0,this.H=i|0}process(n,e){for(let l=0;l<16;l++,e+=4)J[l]=n.getUint32(e,!1);for(let l=16;l<64;l++){const d=J[l-15],w=J[l-2],S=(0,R.np)(d,7)^(0,R.np)(d,18)^d>>>3,y=(0,R.np)(w,17)^(0,R.np)(w,19)^w>>>10;J[l]=y+J[l-7]+S+J[l-16]|0}let{A:r,B:o,C:s,D:c,E:f,F:i,G:u,H:h}=this;for(let l=0;l<64;l++){const d=(0,R.np)(f,6)^(0,R.np)(f,11)^(0,R.np)(f,25),w=h+d+Te(f,i,u)+ke[l]+J[l]|0,y=((0,R.np)(r,2)^(0,R.np)(r,13)^(0,R.np)(r,22))+He(r,o,s)|0;h=u,u=i,i=f,f=c+w|0,c=s,s=o,o=r,r=w+y|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,c=c+this.D|0,f=f+this.E|0,i=i+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(r,o,s,c,f,i,u,h)}roundClean(){J.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class wn extends null{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Ue=(0,R.hE)(()=>new Re),bn=null;class oe extends R.kb{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,(0,nt.z3)(n);const r=(0,R.O0)(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=n.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),s.fill(0)}update(n){return(0,nt.$h)(this),this.iHash.update(n),this}digestInto(n){(0,nt.$h)(this),(0,nt.gk)(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:c,outputLen:f}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const se=(t,n,e)=>new oe(t,n).update(e).digest();se.create=(t,n)=>new oe(t,n);const Ot=BigInt(0),qt=BigInt(1),Ce=BigInt(2);function rt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function yt(t){if(!rt(t))throw new Error("Uint8Array expected")}function ft(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}const Ze=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function at(t){yt(t);let n="";for(let e=0;e<t.length;e++)n+=Ze[t[e]];return n}function ut(t){const n=t.toString(16);return n.length&1?"0"+n:n}function ie(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Ot:BigInt("0x"+t)}const W={_0:48,_9:57,A:65,F:70,a:97,f:102};function ce(t){if(t>=W._0&&t<=W._9)return t-W._0;if(t>=W.A&&t<=W.F)return t-(W.A-10);if(t>=W.a&&t<=W.f)return t-(W.a-10)}function lt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let o=0,s=0;o<e;o++,s+=2){const c=ce(t.charCodeAt(s)),f=ce(t.charCodeAt(s+1));if(c===void 0||f===void 0){const i=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+s)}r[o]=c*16+f}return r}function ot(t){return ie(at(t))}function Ut(t){return yt(t),ie(at(Uint8Array.from(t).reverse()))}function dt(t,n){return lt(t.toString(16).padStart(n*2,"0"))}function Ct(t,n){return dt(t,n).reverse()}function mn(t){return lt(ut(t))}function D(t,n,e){let r;if(typeof n=="string")try{r=lt(n)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(rt(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(t+" of length "+e+" expected, got "+o);return r}function pt(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];yt(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const s=t[r];e.set(s,o),o+=s.length}return e}function yn(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function pn(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const Zt=t=>typeof t=="bigint"&&Ot<=t;function Nt(t,n,e){return Zt(t)&&Zt(n)&&Zt(e)&&n<=t&&t<e}function st(t,n,e,r){if(!Nt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function fe(t){let n;for(n=0;t>Ot;t>>=qt,n+=1);return n}function xn(t,n){return t>>BigInt(n)&qt}function En(t,n,e){return t|(e?qt:Ot)<<BigInt(n)}const Vt=t=>(Ce<<BigInt(t-1))-qt,zt=t=>new Uint8Array(t),ae=t=>Uint8Array.from(t);function ue(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=zt(t),o=zt(t),s=0;const c=()=>{r.fill(1),o.fill(0),s=0},f=(...l)=>e(o,r,...l),i=(l=zt())=>{o=f(ae([0]),l),r=f(),l.length!==0&&(o=f(ae([1]),l),r=f())},u=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const d=[];for(;l<n;){r=f();const w=r.slice();d.push(w),l+=r.length}return pt(...d)};return(l,d)=>{c(),i(l);let w;for(;!(w=d(u()));)i();return c(),w}}const Ve={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||rt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function xt(t,n,e={}){const r=(o,s,c)=>{const f=Ve[s];if(typeof f!="function")throw new Error("invalid validator function");const i=t[o];if(!(c&&i===void 0)&&!f(i,t))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+i)};for(const[o,s]of Object.entries(n))r(o,s,!1);for(const[o,s]of Object.entries(e))r(o,s,!0);return t}const Bn=()=>{throw new Error("not implemented")};function Mt(t){const n=new WeakMap;return(e,...r)=>{const o=n.get(e);if(o!==void 0)return o;const s=t(e,...r);return n.set(e,s),s}}const C=BigInt(0),L=BigInt(1),F=BigInt(2),ze=BigInt(3),Pt=BigInt(4),le=BigInt(5),de=BigInt(8),Me=BigInt(9),Pe=BigInt(16);function V(t,n){const e=t%n;return e>=C?e:n+e}function je(t,n,e){if(n<C)throw new Error("invalid exponent, negatives unsupported");if(e<=C)throw new Error("invalid modulus");if(e===L)return C;let r=L;for(;n>C;)n&L&&(r=r*t%e),t=t*t%e,n>>=L;return r}function K(t,n,e){let r=t;for(;n-- >C;)r*=r,r%=e;return r}function _t(t,n){if(t===C)throw new Error("invert: expected non-zero number");if(n<=C)throw new Error("invert: expected positive modulus, got "+n);let e=V(t,n),r=n,o=C,s=L,c=L,f=C;for(;e!==C;){const u=r/e,h=r%e,l=o-c*u,d=s-f*u;r=e,e=h,o=c,s=f,c=l,f=d}if(r!==L)throw new Error("invert: does not exist");return V(o,n)}function Ke(t){const n=(t-L)/F;let e,r,o;for(e=t-L,r=0;e%F===C;e/=F,r++);for(o=F;o<t&&je(o,n,t)!==t-L;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const c=(t+L)/Pt;return function(i,u){const h=i.pow(u,c);if(!i.eql(i.sqr(h),u))throw new Error("Cannot find square root");return h}}const s=(e+L)/F;return function(f,i){if(f.pow(i,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let u=r,h=f.pow(f.mul(f.ONE,o),e),l=f.pow(i,s),d=f.pow(i,e);for(;!f.eql(d,f.ONE);){if(f.eql(d,f.ZERO))return f.ZERO;let w=1;for(let y=f.sqr(d);w<u&&!f.eql(y,f.ONE);w++)y=f.sqr(y);const S=f.pow(h,L<<BigInt(u-w-1));h=f.sqr(S),l=f.mul(l,S),d=f.mul(d,h),u=w}return l}}function De(t){if(t%Pt===ze){const n=(t+L)/Pt;return function(r,o){const s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%de===le){const n=(t-le)/de;return function(r,o){const s=r.mul(o,F),c=r.pow(s,n),f=r.mul(o,c),i=r.mul(r.mul(f,F),c),u=r.mul(f,r.sub(i,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return t%Pe,Ke(t)}const vn=(t,n)=>(V(t,n)&L)===L,Ge=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ye(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Ge.reduce((r,o)=>(r[o]="function",r),n);return xt(t,e)}function We(t,n,e){if(e<C)throw new Error("invalid exponent, negatives unsupported");if(e===C)return t.ONE;if(e===L)return n;let r=t.ONE,o=n;for(;e>C;)e&L&&(r=t.mul(r,o)),o=t.sqr(o),e>>=L;return r}function Xe(t,n){const e=new Array(n.length),r=n.reduce((s,c,f)=>t.is0(c)?s:(e[f]=s,t.mul(s,c)),t.ONE),o=t.inv(r);return n.reduceRight((s,c,f)=>t.is0(c)?s:(e[f]=t.mul(s,e[f]),t.mul(s,c)),o),e}function Sn(t,n,e){return t.mul(n,typeof e=="bigint"?_t(e,t.ORDER):t.inv(e))}function Qe(t){const n=(t-L)/F;return(e,r)=>e.pow(r,n)}function An(t){const n=Qe(t.ORDER);return e=>{const r=n(t,e);return t.eql(r,t.ZERO)||t.eql(r,t.ONE)}}function jt(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function he(t,n,e=!1,r={}){if(t<=C)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:s}=jt(t,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:o,BYTES:s,MASK:Vt(o),ZERO:C,ONE:L,create:i=>V(i,t),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return C<=i&&i<t},is0:i=>i===C,isOdd:i=>(i&L)===L,neg:i=>V(-i,t),eql:(i,u)=>i===u,sqr:i=>V(i*i,t),add:(i,u)=>V(i+u,t),sub:(i,u)=>V(i-u,t),mul:(i,u)=>V(i*u,t),pow:(i,u)=>We(f,i,u),div:(i,u)=>V(i*_t(u,t),t),sqrN:i=>i*i,addN:(i,u)=>i+u,subN:(i,u)=>i-u,mulN:(i,u)=>i*u,inv:i=>_t(i,t),sqrt:r.sqrt||(i=>(c||(c=De(t)),c(f,i))),invertBatch:i=>Xe(f,i),cmov:(i,u,h)=>h?u:i,toBytes:i=>e?Ct(i,s):dt(i,s),fromBytes:i=>{if(i.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+i.length);return e?Ut(i):ot(i)}});return Object.freeze(f)}function In(t,n){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const e=t.sqrt(n);return t.isOdd(e)?e:t.neg(e)}function On(t,n){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const e=t.sqrt(n);return t.isOdd(e)?t.neg(e):e}function qn(t,n,e=!1){t=ensureBytes("privateHash",t);const r=t.length,o=jt(n).nByteLength+8;if(o<24||r<o||r>1024)throw new Error("hashToPrivateScalar: expected "+o+"-1024 bytes of input, got "+r);const s=e?bytesToNumberLE(t):bytesToNumberBE(t);return V(s,n-L)+L}function ge(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function we(t){const n=ge(t);return n+Math.ceil(n/2)}function $e(t,n,e=!1){const r=t.length,o=ge(n),s=we(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const c=e?Ut(t):ot(t),f=V(c,n-L)+L;return e?Ct(f,o):dt(f,o)}const be=BigInt(0),Tt=BigInt(1);function Kt(t,n){const e=n.negate();return t?e:n}function Dt(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Gt(t,n){Dt(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1);return{windows:e,windowSize:r}}function me(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function ye(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Yt=new WeakMap,pe=new WeakMap;function Wt(t){return pe.get(t)||1}function Je(t,n){return{constTimeNegate:Kt,hasPrecomputes(e){return Wt(e)!==1},unsafeLadder(e,r,o=t.ZERO){let s=e;for(;r>be;)r&Tt&&(o=o.add(s)),s=s.double(),r>>=Tt;return o},precomputeWindow(e,r){const{windows:o,windowSize:s}=Gt(r,n),c=[];let f=e,i=f;for(let u=0;u<o;u++){i=f,c.push(i);for(let h=1;h<s;h++)i=i.add(f),c.push(i);f=i.double()}return c},wNAF(e,r,o){const{windows:s,windowSize:c}=Gt(e,n);let f=t.ZERO,i=t.BASE;const u=BigInt(2**e-1),h=2**e,l=BigInt(e);for(let d=0;d<s;d++){const w=d*c;let S=Number(o&u);o>>=l,S>c&&(S-=h,o+=Tt);const y=w,a=w+Math.abs(S)-1,g=d%2!==0,m=S<0;S===0?i=i.add(Kt(g,r[y])):f=f.add(Kt(m,r[a]))}return{p:f,f:i}},wNAFUnsafe(e,r,o,s=t.ZERO){const{windows:c,windowSize:f}=Gt(e,n),i=BigInt(2**e-1),u=2**e,h=BigInt(e);for(let l=0;l<c;l++){const d=l*f;if(o===be)break;let w=Number(o&i);if(o>>=h,w>f&&(w-=u,o+=Tt),w===0)continue;let S=r[d+Math.abs(w)-1];w<0&&(S=S.negate()),s=s.add(S)}return s},getPrecomputes(e,r,o){let s=Yt.get(r);return s||(s=this.precomputeWindow(r,e),e!==1&&Yt.set(r,o(s))),s},wNAFCached(e,r,o){const s=Wt(e);return this.wNAF(s,this.getPrecomputes(s,e,o),r)},wNAFCachedUnsafe(e,r,o,s){const c=Wt(e);return c===1?this.unsafeLadder(e,r,s):this.wNAFUnsafe(c,this.getPrecomputes(c,e,o),r,s)},setWindowSize(e,r){Dt(r,n),pe.set(e,r),Yt.delete(e)}}}function Fe(t,n,e,r){if(me(e,t),ye(r,n),e.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,s=fe(BigInt(e.length)),c=s>12?s-3:s>4?s-2:s?2:1,f=(1<<c)-1,i=new Array(f+1).fill(o),u=Math.floor((n.BITS-1)/c)*c;let h=o;for(let l=u;l>=0;l-=c){i.fill(o);for(let w=0;w<r.length;w++){const S=r[w],y=Number(S>>BigInt(l)&BigInt(f));i[y]=i[y].add(e[w])}let d=o;for(let w=i.length-1,S=o;w>0;w--)S=S.add(i[w]),d=d.add(S);if(h=h.add(d),l!==0)for(let w=0;w<c;w++)h=h.double()}return h}function Nn(t,n,e,r){Dt(r,n.BITS),me(e,t);const o=t.ZERO,s=2**r-1,c=Math.ceil(n.BITS/r),f=BigInt((1<<r)-1),i=e.map(u=>{const h=[];for(let l=0,d=u;l<s;l++)h.push(d),d=d.add(u);return h});return u=>{if(ye(u,n),u.length>e.length)throw new Error("array of scalars must be smaller than array of points");let h=o;for(let l=0;l<c;l++){if(h!==o)for(let w=0;w<r;w++)h=h.double();const d=BigInt(c*r-(l+1)*r);for(let w=0;w<u.length;w++){const S=u[w],y=Number(S>>d&f);y&&(h=h.add(i[w][y-1]))}}return h}}function xe(t){return Ye(t.Fp),xt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...jt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Ee(t){t.lowS!==void 0&&ft("lowS",t.lowS),t.prehash!==void 0&&ft("prehash",t.prehash)}function tn(t){const n=xe(t);xt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:en,hexToBytes:nn}=Rt;class rn extends Error{constructor(n=""){super(n)}}const X={Err:rn,_tlv:{encode:(t,n)=>{const{Err:e}=X;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,o=ut(r);if(o.length/2&128)throw new e("tlv.encode: long form length too big");const s=r>127?ut(o.length/2|128):"";return ut(t)+s+o+n},decode(t,n){const{Err:e}=X;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const o=n[r++],s=!!(o&128);let c=0;if(!s)c=o;else{const i=o&127;if(!i)throw new e("tlv.decode(long): indefinite length not supported");if(i>4)throw new e("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+i);if(u.length!==i)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const h of u)c=c<<8|h;if(r+=i,c<128)throw new e("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=X;if(t<G)throw new n("integer: negative integers are not allowed");let e=ut(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=X;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return en(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=X,o=typeof t=="string"?nn(t):t;yt(o);const{v:s,l:c}=r.decode(48,o);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:i}=r.decode(2,s),{v:u,l:h}=r.decode(2,i);if(h.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(u)}},hexFromSig(t){const{_tlv:n,_int:e}=X,r=n.encode(2,e.encode(t.r)),o=n.encode(2,e.encode(t.s)),s=r+o;return n.encode(48,s)}},G=BigInt(0),T=BigInt(1),tt=BigInt(2),Ht=BigInt(3),Be=BigInt(4);function on(t){const n=tn(t),{Fp:e}=n,r=he(n.n,n.nBitLength),o=n.toBytes||((y,a,g)=>{const m=a.toAffine();return pt(Uint8Array.from([4]),e.toBytes(m.x),e.toBytes(m.y))}),s=n.fromBytes||(y=>{const a=y.subarray(1),g=e.fromBytes(a.subarray(0,e.BYTES)),m=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:g,y:m}});function c(y){const{a,b:g}=n,m=e.sqr(y),p=e.mul(m,y);return e.add(e.add(p,e.mul(y,a)),g)}if(!e.eql(e.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function f(y){return Nt(y,T,n.n)}function i(y){const{allowedPrivateKeyLengths:a,nByteLength:g,wrapPrivateKey:m,n:p}=n;if(a&&typeof y!="bigint"){if(rt(y)&&(y=at(y)),typeof y!="string"||!a.includes(y.length))throw new Error("invalid private key");y=y.padStart(g*2,"0")}let B;try{B=typeof y=="bigint"?y:ot(D("private key",y,g))}catch{throw new Error("invalid private key, expected hex or "+g+" bytes, got "+typeof y)}return m&&(B=V(B,p)),st("private key",B,T,p),B}function u(y){if(!(y instanceof d))throw new Error("ProjectivePoint expected")}const h=Mt((y,a)=>{const{px:g,py:m,pz:p}=y;if(e.eql(p,e.ONE))return{x:g,y:m};const B=y.is0();a==null&&(a=B?e.ONE:e.inv(p));const N=e.mul(g,a),O=e.mul(m,a),v=e.mul(p,a);if(B)return{x:e.ZERO,y:e.ZERO};if(!e.eql(v,e.ONE))throw new Error("invZ was invalid");return{x:N,y:O}}),l=Mt(y=>{if(y.is0()){if(n.allowInfinityPoint&&!e.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:a,y:g}=y.toAffine();if(!e.isValid(a)||!e.isValid(g))throw new Error("bad point: x or y not FE");const m=e.sqr(g),p=c(a);if(!e.eql(m,p))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(a,g,m){if(this.px=a,this.py=g,this.pz=m,a==null||!e.isValid(a))throw new Error("x required");if(g==null||!e.isValid(g))throw new Error("y required");if(m==null||!e.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(a){const{x:g,y:m}=a||{};if(!a||!e.isValid(g)||!e.isValid(m))throw new Error("invalid affine point");if(a instanceof d)throw new Error("projective point not allowed");const p=B=>e.eql(B,e.ZERO);return p(g)&&p(m)?d.ZERO:new d(g,m,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const g=e.invertBatch(a.map(m=>m.pz));return a.map((m,p)=>m.toAffine(g[p])).map(d.fromAffine)}static fromHex(a){const g=d.fromAffine(s(D("pointHex",a)));return g.assertValidity(),g}static fromPrivateKey(a){return d.BASE.multiply(i(a))}static msm(a,g){return Fe(d,r,a,g)}_setWindowSize(a){S.setWindowSize(this,a)}assertValidity(){l(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){u(a);const{px:g,py:m,pz:p}=this,{px:B,py:N,pz:O}=a,v=e.eql(e.mul(g,O),e.mul(B,p)),I=e.eql(e.mul(m,O),e.mul(N,p));return v&&I}negate(){return new d(this.px,e.neg(this.py),this.pz)}double(){const{a,b:g}=n,m=e.mul(g,Ht),{px:p,py:B,pz:N}=this;let O=e.ZERO,v=e.ZERO,I=e.ZERO,A=e.mul(p,p),Z=e.mul(B,B),k=e.mul(N,N),H=e.mul(p,B);return H=e.add(H,H),I=e.mul(p,N),I=e.add(I,I),O=e.mul(a,I),v=e.mul(m,k),v=e.add(O,v),O=e.sub(Z,v),v=e.add(Z,v),v=e.mul(O,v),O=e.mul(H,O),I=e.mul(m,I),k=e.mul(a,k),H=e.sub(A,k),H=e.mul(a,H),H=e.add(H,I),I=e.add(A,A),A=e.add(I,A),A=e.add(A,k),A=e.mul(A,H),v=e.add(v,A),k=e.mul(B,N),k=e.add(k,k),A=e.mul(k,H),O=e.sub(O,A),I=e.mul(k,Z),I=e.add(I,I),I=e.add(I,I),new d(O,v,I)}add(a){u(a);const{px:g,py:m,pz:p}=this,{px:B,py:N,pz:O}=a;let v=e.ZERO,I=e.ZERO,A=e.ZERO;const Z=n.a,k=e.mul(n.b,Ht);let H=e.mul(g,B),j=e.mul(m,N),b=e.mul(p,O),x=e.add(g,m),E=e.add(B,N);x=e.mul(x,E),E=e.add(H,j),x=e.sub(x,E),E=e.add(g,p);let q=e.add(B,O);return E=e.mul(E,q),q=e.add(H,b),E=e.sub(E,q),q=e.add(m,p),v=e.add(N,O),q=e.mul(q,v),v=e.add(j,b),q=e.sub(q,v),A=e.mul(Z,E),v=e.mul(k,b),A=e.add(v,A),v=e.sub(j,A),A=e.add(j,A),I=e.mul(v,A),j=e.add(H,H),j=e.add(j,H),b=e.mul(Z,b),E=e.mul(k,E),j=e.add(j,b),b=e.sub(H,b),b=e.mul(Z,b),E=e.add(E,b),H=e.mul(j,E),I=e.add(I,H),H=e.mul(q,E),v=e.mul(x,v),v=e.sub(v,H),H=e.mul(x,j),A=e.mul(q,A),A=e.add(A,H),new d(v,I,A)}subtract(a){return this.add(a.negate())}is0(){return this.equals(d.ZERO)}wNAF(a){return S.wNAFCached(this,a,d.normalizeZ)}multiplyUnsafe(a){const{endo:g,n:m}=n;st("scalar",a,G,m);const p=d.ZERO;if(a===G)return p;if(this.is0()||a===T)return this;if(!g||S.hasPrecomputes(this))return S.wNAFCachedUnsafe(this,a,d.normalizeZ);let{k1neg:B,k1:N,k2neg:O,k2:v}=g.splitScalar(a),I=p,A=p,Z=this;for(;N>G||v>G;)N&T&&(I=I.add(Z)),v&T&&(A=A.add(Z)),Z=Z.double(),N>>=T,v>>=T;return B&&(I=I.negate()),O&&(A=A.negate()),A=new d(e.mul(A.px,g.beta),A.py,A.pz),I.add(A)}multiply(a){const{endo:g,n:m}=n;st("scalar",a,T,m);let p,B;if(g){const{k1neg:N,k1:O,k2neg:v,k2:I}=g.splitScalar(a);let{p:A,f:Z}=this.wNAF(O),{p:k,f:H}=this.wNAF(I);A=S.constTimeNegate(N,A),k=S.constTimeNegate(v,k),k=new d(e.mul(k.px,g.beta),k.py,k.pz),p=A.add(k),B=Z.add(H)}else{const{p:N,f:O}=this.wNAF(a);p=N,B=O}return d.normalizeZ([p,B])[0]}multiplyAndAddUnsafe(a,g,m){const p=d.BASE,B=(O,v)=>v===G||v===T||!O.equals(p)?O.multiplyUnsafe(v):O.multiply(v),N=B(this,g).add(B(a,m));return N.is0()?void 0:N}toAffine(a){return h(this,a)}isTorsionFree(){const{h:a,isTorsionFree:g}=n;if(a===T)return!0;if(g)return g(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:g}=n;return a===T?this:g?g(d,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return ft("isCompressed",a),this.assertValidity(),o(d,this,a)}toHex(a=!0){return ft("isCompressed",a),at(this.toRawBytes(a))}}d.BASE=new d(n.Gx,n.Gy,e.ONE),d.ZERO=new d(e.ZERO,e.ONE,e.ZERO);const w=n.nBitLength,S=Je(d,n.endo?Math.ceil(w/2):w);return{CURVE:n,ProjectivePoint:d,normPrivateKeyToScalar:i,weierstrassEquation:c,isWithinCurveOrder:f}}function sn(t){const n=xe(t);return xt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function cn(t){const n=sn(t),{Fp:e,n:r}=n,o=e.BYTES+1,s=2*e.BYTES+1;function c(b){return V(b,r)}function f(b){return _t(b,r)}const{ProjectivePoint:i,normPrivateKeyToScalar:u,weierstrassEquation:h,isWithinCurveOrder:l}=on({...n,toBytes(b,x,E){const q=x.toAffine(),_=e.toBytes(q.x),U=pt;return ft("isCompressed",E),E?U(Uint8Array.from([x.hasEvenY()?2:3]),_):U(Uint8Array.from([4]),_,e.toBytes(q.y))},fromBytes(b){const x=b.length,E=b[0],q=b.subarray(1);if(x===o&&(E===2||E===3)){const _=ot(q);if(!Nt(_,T,e.ORDER))throw new Error("Point is not on curve");const U=h(_);let M;try{M=e.sqrt(U)}catch(Y){const P=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+P)}const z=(M&T)===T;return(E&1)===1!==z&&(M=e.neg(M)),{x:_,y:M}}else if(x===s&&E===4){const _=e.fromBytes(q.subarray(0,e.BYTES)),U=e.fromBytes(q.subarray(e.BYTES,2*e.BYTES));return{x:_,y:U}}else{const _=o,U=s;throw new Error("invalid Point, expected length of "+_+", or uncompressed "+U+", got "+x)}}}),d=b=>at(dt(b,n.nByteLength));function w(b){const x=r>>T;return b>x}function S(b){return w(b)?c(-b):b}const y=(b,x,E)=>ot(b.slice(x,E));class a{constructor(x,E,q){this.r=x,this.s=E,this.recovery=q,this.assertValidity()}static fromCompact(x){const E=n.nByteLength;return x=D("compactSignature",x,E*2),new a(y(x,0,E),y(x,E,2*E))}static fromDER(x){const{r:E,s:q}=X.toSig(D("DER",x));return new a(E,q)}assertValidity(){st("r",this.r,T,r),st("s",this.s,T,r)}addRecoveryBit(x){return new a(this.r,this.s,x)}recoverPublicKey(x){const{r:E,s:q,recovery:_}=this,U=O(D("msgHash",x));if(_==null||![0,1,2,3].includes(_))throw new Error("recovery id invalid");const M=_===2||_===3?E+n.n:E;if(M>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=_&1?"03":"02",Q=i.fromHex(z+d(M)),Y=f(M),P=c(-U*Y),gt=c(q*Y),et=i.BASE.multiplyAndAddUnsafe(Q,P,gt);if(!et)throw new Error("point at infinify");return et.assertValidity(),et}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return lt(this.toDERHex())}toDERHex(){return X.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return lt(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const g={isValidPrivateKey(b){try{return u(b),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const b=we(n.n);return $e(n.randomBytes(b),n.n)},precompute(b=8,x=i.BASE){return x._setWindowSize(b),x.multiply(BigInt(3)),x}};function m(b,x=!0){return i.fromPrivateKey(b).toRawBytes(x)}function p(b){const x=rt(b),E=typeof b=="string",q=(x||E)&&b.length;return x?q===o||q===s:E?q===2*o||q===2*s:b instanceof i}function B(b,x,E=!0){if(p(b))throw new Error("first arg must be private key");if(!p(x))throw new Error("second arg must be public key");return i.fromHex(x).multiply(u(b)).toRawBytes(E)}const N=n.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const x=ot(b),E=b.length*8-n.nBitLength;return E>0?x>>BigInt(E):x},O=n.bits2int_modN||function(b){return c(N(b))},v=Vt(n.nBitLength);function I(b){return st("num < 2^"+n.nBitLength,b,G,v),dt(b,n.nByteLength)}function A(b,x,E=Z){if(["recovered","canonical"].some(it=>it in E))throw new Error("sign() legacy options not supported");const{hash:q,randomBytes:_}=n;let{lowS:U,prehash:M,extraEntropy:z}=E;U==null&&(U=!0),b=D("msgHash",b),Ee(E),M&&(b=D("prehashed msgHash",q(b)));const Q=O(b),Y=u(x),P=[I(Y),I(Q)];if(z!=null&&z!==!1){const it=z===!0?_(e.BYTES):z;P.push(D("extraEntropy",it))}const gt=pt(...P),et=Q;function ne(it){const wt=N(it);if(!l(wt))return;const re=f(wt),St=i.BASE.multiply(wt).toAffine(),ct=c(St.x);if(ct===G)return;const At=c(re*c(et+ct*Y));if(At===G)return;let It=(St.x===ct?0:2)|Number(St.y&T),bt=At;return U&&w(At)&&(bt=S(At),It^=1),new a(ct,bt,It)}return{seed:gt,k2sig:ne}}const Z={lowS:n.lowS,prehash:!1},k={lowS:n.lowS,prehash:!1};function H(b,x,E=Z){const{seed:q,k2sig:_}=A(b,x,E),U=n;return ue(U.hash.outputLen,U.nByteLength,U.hmac)(q,_)}i.BASE._setWindowSize(8);function j(b,x,E,q=k){var It;const _=b;x=D("msgHash",x),E=D("publicKey",E);const{lowS:U,prehash:M,format:z}=q;if(Ee(q),"strict"in q)throw new Error("options.strict was renamed to lowS");if(z!==void 0&&z!=="compact"&&z!=="der")throw new Error("format must be compact or der");const Q=typeof _=="string"||rt(_),Y=!Q&&!z&&typeof _=="object"&&_!==null&&typeof _.r=="bigint"&&typeof _.s=="bigint";if(!Q&&!Y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let P,gt;try{if(Y&&(P=new a(_.r,_.s)),Q){try{z!=="compact"&&(P=a.fromDER(_))}catch(bt){if(!(bt instanceof X.Err))throw bt}!P&&z!=="der"&&(P=a.fromCompact(_))}gt=i.fromHex(E)}catch{return!1}if(!P||U&&P.hasHighS())return!1;M&&(x=n.hash(x));const{r:et,s:ne}=P,it=O(x),wt=f(ne),re=c(it*wt),St=c(et*wt),ct=(It=i.BASE.multiplyAndAddUnsafe(gt,re,St))==null?void 0:It.toAffine();return ct?c(ct.x)===et:!1}return{CURVE:n,getPublicKey:m,getSharedSecret:B,sign:H,verify:j,ProjectivePoint:i,Signature:a,utils:g}}function fn(t,n){const e=t.ORDER;let r=G;for(let S=e-T;S%tt===G;S/=tt)r+=T;const o=r,s=tt<<o-T-T,c=s*tt,f=(e-T)/c,i=(f-T)/tt,u=c-T,h=s,l=t.pow(n,f),d=t.pow(n,(f+T)/tt);let w=(S,y)=>{let a=l,g=t.pow(y,u),m=t.sqr(g);m=t.mul(m,y);let p=t.mul(S,m);p=t.pow(p,i),p=t.mul(p,g),g=t.mul(p,y),m=t.mul(p,S);let B=t.mul(m,g);p=t.pow(B,h);let N=t.eql(p,t.ONE);g=t.mul(m,d),p=t.mul(B,a),m=t.cmov(g,m,N),B=t.cmov(p,B,N);for(let O=o;O>T;O--){let v=O-tt;v=tt<<v-T;let I=t.pow(B,v);const A=t.eql(I,t.ONE);g=t.mul(m,a),a=t.mul(a,a),I=t.mul(B,a),m=t.cmov(g,m,A),B=t.cmov(I,B,A)}return{isValid:N,value:m}};if(t.ORDER%Be===Ht){const S=(t.ORDER-Ht)/Be,y=t.sqrt(t.neg(n));w=(a,g)=>{let m=t.sqr(g);const p=t.mul(a,g);m=t.mul(m,p);let B=t.pow(m,S);B=t.mul(B,p);const N=t.mul(B,y),O=t.mul(t.sqr(B),g),v=t.eql(O,a);let I=t.cmov(N,B,v);return{isValid:v,value:I}}}return w}function _n(t,n){if(validateField(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=fn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,c,f,i,u,h,l;o=t.sqr(r),o=t.mul(o,n.Z),s=t.sqr(o),s=t.add(s,o),c=t.add(s,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),f=t.mul(f,n.A),s=t.sqr(c),u=t.sqr(f),i=t.mul(u,n.A),s=t.add(s,i),s=t.mul(s,c),u=t.mul(u,f),i=t.mul(u,n.B),s=t.add(s,i),h=t.mul(o,c);const{isValid:d,value:w}=e(s,u);l=t.mul(o,r),l=t.mul(l,w),h=t.cmov(h,c,d),l=t.cmov(l,w,d);const S=t.isOdd(r)===t.isOdd(l);return l=t.cmov(t.neg(l),l,S),h=t.div(h,f),{x:h,y:l}}}function an(t){return{hash:t,hmac:(n,...e)=>se(t,n,(0,R.eV)(...e)),randomBytes:R.O6}}function un(t,n){const e=r=>cn({...t,...an(r)});return{...e(n),create:e}}const Et=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Lt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Bt=BigInt(1),kt=BigInt(2),ve=(t,n)=>(t+n/kt)/n;function Se(t){const n=Et,e=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),c=BigInt(23),f=BigInt(44),i=BigInt(88),u=t*t*t%n,h=u*u*t%n,l=K(h,e,n)*h%n,d=K(l,e,n)*h%n,w=K(d,kt,n)*u%n,S=K(w,o,n)*w%n,y=K(S,s,n)*S%n,a=K(y,f,n)*y%n,g=K(a,i,n)*a%n,m=K(g,f,n)*y%n,p=K(m,e,n)*h%n,B=K(p,c,n)*S%n,N=K(B,r,n)*u%n,O=K(N,kt,n);if(!Xt.eql(Xt.sqr(O),t))throw new Error("Cannot find square root");return O}const Xt=he(Et,void 0,void 0,{sqrt:Se}),Qt=un({a:BigInt(0),b:BigInt(7),Fp:Xt,n:Lt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Lt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Bt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,c=BigInt("0x100000000000000000000000000000000"),f=ve(s*t,n),i=ve(-r*t,n);let u=V(t-f*e-i*o,n),h=V(-f*r-i*s,n);const l=u>c,d=h>c;if(l&&(u=n-u),d&&(h=n-h),u>c||h>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:u,k2neg:d,k2:h}}}},Ue),Ae=BigInt(0),Ie={};function $t(t,...n){let e=Ie[t];if(e===void 0){const r=sha256(Uint8Array.from(t,o=>o.charCodeAt(0)));e=concatBytes(r,r),Ie[t]=e}return sha256(concatBytes(e,...n))}const Oe=t=>t.toRawBytes(!0).slice(1),Jt=t=>numberToBytesBE(t,32),Ft=t=>mod(t,Et),vt=t=>mod(t,Lt),te=Qt.ProjectivePoint,ln=(t,n,e)=>te.BASE.multiplyAndAddUnsafe(t,n,e);function ee(t){let n=Qt.utils.normPrivateKeyToScalar(t),e=te.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:vt(-n),bytes:Oe(e)}}function dn(t){aInRange("x",t,Bt,Et);const n=Ft(t*t),e=Ft(n*t+BigInt(7));let r=Se(e);r%kt!==Ae&&(r=Ft(-r));const o=new te(t,r,Bt);return o.assertValidity(),o}const ht=null;function qe(...t){return vt(ht($t("BIP0340/challenge",...t)))}function Tn(t){return ee(t).bytes}function Hn(t,n,e=randomBytes(32)){const r=ensureBytes("message",t),{bytes:o,scalar:s}=ee(n),c=ensureBytes("auxRand",e,32),f=Jt(s^ht($t("BIP0340/aux",c))),i=$t("BIP0340/nonce",f,o,r),u=vt(ht(i));if(u===Ae)throw new Error("sign failed: k is zero");const{bytes:h,scalar:l}=ee(u),d=qe(h,o,r),w=new Uint8Array(64);if(w.set(h,0),w.set(Jt(vt(l+d*s)),32),!hn(w,r,o))throw new Error("sign: Invalid signature produced");return w}function hn(t,n,e){const r=ensureBytes("signature",t,64),o=ensureBytes("message",n),s=ensureBytes("publicKey",e,32);try{const c=dn(ht(s)),f=ht(r.subarray(0,32));if(!inRange(f,Bt,Et))return!1;const i=ht(r.subarray(32,64));if(!inRange(i,Bt,Lt))return!1;const u=qe(Jt(f),Oe(c),o),h=ln(c,i,vt(-u));return!(!h||!h.hasEvenY()||h.toAffine().x!==f)}catch{return!1}}const Ln=null,kn=null,Rn=null,Un=null,Cn=null,Zn=null}}]);
