"use strict";(self.webpackChunk_ant_design_web3_docs=self.webpackChunk_ant_design_web3_docs||[]).push([[3307],{53307:function(nn,Ne,pt){pt.d(Ne,{secp256k1:function(){return Ae}});var _e=pt(43448),Re=pt(21645),Rt=pt(61851);const xt=BigInt(0),ft=BigInt(1);function at(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Tt(t){if(!at(t))throw new Error("Uint8Array expected")}function ut(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function lt(t){const n=t.toString(16);return n.length&1?"0"+n:n}function ee(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?xt:BigInt("0x"+t)}const ne=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Te=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function dt(t){if(Tt(t),ne)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=Te[t[e]];return n}const G={_0:48,_9:57,A:65,F:70,a:97,f:102};function re(t){if(t>=G._0&&t<=G._9)return t-G._0;if(t>=G.A&&t<=G.F)return t-(G.A-10);if(t>=G.a&&t<=G.f)return t-(G.a-10)}function ht(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(ne)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let i=0,s=0;i<e;i++,s+=2){const c=re(t.charCodeAt(s)),a=re(t.charCodeAt(s+1));if(c===void 0||a===void 0){const o=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}r[i]=c*16+a}return r}function F(t){return ee(dt(t))}function oe(t){return Tt(t),ee(dt(Uint8Array.from(t).reverse()))}function wt(t,n){return ht(t.toString(16).padStart(n*2,"0"))}function ie(t,n){return wt(t,n).reverse()}function rn(t){return ht(lt(t))}function K(t,n,e){let r;if(typeof n=="string")try{r=ht(n)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(at(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const i=r.length;if(typeof e=="number"&&i!==e)throw new Error(t+" of length "+e+" expected, got "+i);return r}function St(...t){let n=0;for(let r=0;r<t.length;r++){const i=t[r];Tt(i),n+=i.length}const e=new Uint8Array(n);for(let r=0,i=0;r<t.length;r++){const s=t[r];e.set(s,i),i+=s.length}return e}function on(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function sn(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const kt=t=>typeof t=="bigint"&&xt<=t;function Ut(t,n,e){return kt(t)&&kt(n)&&kt(e)&&n<=t&&t<e}function rt(t,n,e,r){if(!Ut(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function ke(t){let n;for(n=0;t>xt;t>>=ft,n+=1);return n}function cn(t,n){return t>>BigInt(n)&ft}function fn(t,n,e){return t|(e?ft:xt)<<BigInt(n)}const At=t=>(ft<<BigInt(t))-ft,Zt=t=>new Uint8Array(t),se=t=>Uint8Array.from(t);function Ue(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Zt(t),i=Zt(t),s=0;const c=()=>{r.fill(1),i.fill(0),s=0},a=(...m)=>e(i,r,...m),o=(m=Zt(0))=>{i=a(se([0]),m),r=a(),m.length!==0&&(i=a(se([1]),m),r=a())},u=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let m=0;const v=[];for(;m<n;){r=a();const p=r.slice();v.push(p),m+=r.length}return St(...v)};return(m,v)=>{c(),o(m);let p;for(;!(p=v(u()));)o();return c(),p}}const Ze={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||at(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function It(t,n,e={}){const r=(i,s,c)=>{const a=Ze[s];if(typeof a!="function")throw new Error("invalid validator function");const o=t[i];if(!(c&&o===void 0)&&!a(o,t))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+o)};for(const[i,s]of Object.entries(n))r(i,s,!1);for(const[i,s]of Object.entries(e))r(i,s,!0);return t}const an=()=>{throw new Error("not implemented")};function ce(t){const n=new WeakMap;return(e,...r)=>{const i=n.get(e);if(i!==void 0)return i;const s=t(e,...r);return n.set(e,s),s}}const H=BigInt(0),P=BigInt(1),tt=BigInt(2),Le=BigInt(3),fe=BigInt(4),ae=BigInt(5),ue=BigInt(8);function V(t,n){const e=t%n;return e>=H?e:n+e}function un(t,n,e){return de(qt(e),t,n)}function Y(t,n,e){let r=t;for(;n-- >H;)r*=r,r%=e;return r}function Ot(t,n){if(t===H)throw new Error("invert: expected non-zero number");if(n<=H)throw new Error("invert: expected positive modulus, got "+n);let e=V(t,n),r=n,i=H,s=P,c=P,a=H;for(;e!==H;){const u=r/e,l=r%e,m=i-c*u,v=s-a*u;r=e,e=l,i=c,s=a,c=m,a=v}if(r!==P)throw new Error("invert: does not exist");return V(i,n)}function le(t,n){const e=(t.ORDER+P)/fe,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function Ce(t,n){const e=(t.ORDER-ae)/ue,r=t.mul(n,tt),i=t.pow(r,e),s=t.mul(n,i),c=t.mul(t.mul(s,tt),i),a=t.mul(s,t.sub(c,t.ONE));if(!t.eql(t.sqr(a),n))throw new Error("Cannot find square root");return a}function Pe(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-P,e=0;for(;n%tt===H;)n/=tt,e++;let r=tt;const i=qt(t);for(;Lt(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return le;let s=i.pow(r,n);const c=(n+P)/tt;return function(o,u){if(o.is0(u))return u;if(Lt(o,u)!==1)throw new Error("Cannot find square root");let l=e,m=o.mul(o.ONE,s),v=o.pow(u,n),p=o.pow(u,c);for(;!o.eql(v,o.ONE);){if(o.is0(v))return o.ZERO;let R=1,g=o.sqr(v);for(;!o.eql(g,o.ONE);)if(R++,g=o.sqr(g),R===l)throw new Error("Cannot find square root");const L=P<<BigInt(l-R-1),_=o.pow(m,L);l=R,m=o.sqr(_),v=o.mul(v,m),p=o.mul(p,_)}return p}}function Ve(t){return t%fe===Le?le:t%ue===ae?Ce:Pe(t)}const ln=(t,n)=>(V(t,n)&P)===P,ze=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function He(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=ze.reduce((r,i)=>(r[i]="function",r),n);return It(t,e)}function de(t,n,e){if(e<H)throw new Error("invalid exponent, negatives unsupported");if(e===H)return t.ONE;if(e===P)return n;let r=t.ONE,i=n;for(;e>H;)e&P&&(r=t.mul(r,i)),i=t.sqr(i),e>>=P;return r}function he(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),i=n.reduce((c,a,o)=>t.is0(a)?c:(r[o]=c,t.mul(c,a)),t.ONE),s=t.inv(i);return n.reduceRight((c,a,o)=>t.is0(a)?c:(r[o]=t.mul(c,r[o]),t.mul(c,a)),s),r}function dn(t,n,e){return t.mul(n,typeof e=="bigint"?Ot(e,t.ORDER):t.inv(e))}function Lt(t,n){const e=(t.ORDER-P)/tt,r=t.pow(n,e),i=t.eql(r,t.ONE),s=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!i&&!s&&!c)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function hn(t,n){return Lt(t,n)===1}function Ct(t,n){n!==void 0&&(0,Rt.k8)(n);const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function qt(t,n,e=!1,r={}){if(t<=H)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:s}=Ct(t,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const a=Object.freeze({ORDER:t,isLE:e,BITS:i,BYTES:s,MASK:At(i),ZERO:H,ONE:P,create:o=>V(o,t),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return H<=o&&o<t},is0:o=>o===H,isOdd:o=>(o&P)===P,neg:o=>V(-o,t),eql:(o,u)=>o===u,sqr:o=>V(o*o,t),add:(o,u)=>V(o+u,t),sub:(o,u)=>V(o-u,t),mul:(o,u)=>V(o*u,t),pow:(o,u)=>de(a,o,u),div:(o,u)=>V(o*Ot(u,t),t),sqrN:o=>o*o,addN:(o,u)=>o+u,subN:(o,u)=>o-u,mulN:(o,u)=>o*u,inv:o=>Ot(o,t),sqrt:r.sqrt||(o=>(c||(c=Ve(t)),c(a,o))),toBytes:o=>e?ie(o,s):wt(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return e?oe(o):F(o)},invertBatch:o=>he(a,o),cmov:(o,u,l)=>l?u:o});return Object.freeze(a)}function wn(t,n){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const e=t.sqrt(n);return t.isOdd(e)?e:t.neg(e)}function gn(t,n){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const e=t.sqrt(n);return t.isOdd(e)?t.neg(e):e}function mn(t,n,e=!1){t=ensureBytes("privateHash",t);const r=t.length,i=Ct(n).nByteLength+8;if(i<24||r<i||r>1024)throw new Error("hashToPrivateScalar: expected "+i+"-1024 bytes of input, got "+r);const s=e?bytesToNumberLE(t):bytesToNumberBE(t);return V(s,n-P)+P}function we(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function ge(t){const n=we(t);return n+Math.ceil(n/2)}function Me(t,n,e=!1){const r=t.length,i=we(n),s=ge(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const c=e?oe(t):F(t),a=V(c,n-P)+P;return e?ie(a,i):wt(a,i)}const me=BigInt(0),Pt=BigInt(1);function Vt(t,n){const e=n.negate();return t?e:n}function zt(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Ht(t,n){zt(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),i=2**t,s=At(t),c=BigInt(t);return{windows:e,windowSize:r,mask:s,maxNumber:i,shiftBy:c}}function ye(t,n,e){const{windowSize:r,mask:i,maxNumber:s,shiftBy:c}=e;let a=Number(t&i),o=t>>c;a>r&&(a-=s,o+=Pt);const u=n*r,l=u+Math.abs(a)-1,m=a===0,v=a<0,p=n%2!==0;return{nextN:o,offset:l,isZero:m,isNeg:v,isNegF:p,offsetF:u}}function be(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function Ee(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Mt=new WeakMap,ve=new WeakMap;function jt(t){return ve.get(t)||1}function je(t,n){return{constTimeNegate:Vt,hasPrecomputes(e){return jt(e)!==1},unsafeLadder(e,r,i=t.ZERO){let s=e;for(;r>me;)r&Pt&&(i=i.add(s)),s=s.double(),r>>=Pt;return i},precomputeWindow(e,r){const{windows:i,windowSize:s}=Ht(r,n),c=[];let a=e,o=a;for(let u=0;u<i;u++){o=a,c.push(o);for(let l=1;l<s;l++)o=o.add(a),c.push(o);a=o.double()}return c},wNAF(e,r,i){let s=t.ZERO,c=t.BASE;const a=Ht(e,n);for(let o=0;o<a.windows;o++){const{nextN:u,offset:l,isZero:m,isNeg:v,isNegF:p,offsetF:R}=ye(i,o,a);i=u,m?c=c.add(Vt(p,r[R])):s=s.add(Vt(v,r[l]))}return{p:s,f:c}},wNAFUnsafe(e,r,i,s=t.ZERO){const c=Ht(e,n);for(let a=0;a<c.windows&&i!==me;a++){const{nextN:o,offset:u,isZero:l,isNeg:m}=ye(i,a,c);if(i=o,!l){const v=r[u];s=s.add(m?v.negate():v)}}return s},getPrecomputes(e,r,i){let s=Mt.get(r);return s||(s=this.precomputeWindow(r,e),e!==1&&Mt.set(r,i(s))),s},wNAFCached(e,r,i){const s=jt(e);return this.wNAF(s,this.getPrecomputes(s,e,i),r)},wNAFCachedUnsafe(e,r,i,s){const c=jt(e);return c===1?this.unsafeLadder(e,r,s):this.wNAFUnsafe(c,this.getPrecomputes(c,e,i),r,s)},setWindowSize(e,r){zt(r,n),ve.set(e,r),Mt.delete(e)}}}function Ke(t,n,e,r){be(e,t),Ee(r,n);const i=e.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const c=t.ZERO,a=ke(BigInt(i));let o=1;a>12?o=a-3:a>4?o=a-2:a>0&&(o=2);const u=At(o),l=new Array(Number(u)+1).fill(c),m=Math.floor((n.BITS-1)/o)*o;let v=c;for(let p=m;p>=0;p-=o){l.fill(c);for(let g=0;g<s;g++){const L=r[g],_=Number(L>>BigInt(p)&u);l[_]=l[_].add(e[g])}let R=c;for(let g=l.length-1,L=c;g>0;g--)L=L.add(l[g]),R=R.add(L);if(v=v.add(R),p!==0)for(let g=0;g<o;g++)v=v.double()}return v}function yn(t,n,e,r){zt(r,n.BITS),be(e,t);const i=t.ZERO,s=2**r-1,c=Math.ceil(n.BITS/r),a=bitMask(r),o=e.map(u=>{const l=[];for(let m=0,v=u;m<s;m++)l.push(v),v=v.add(u);return l});return u=>{if(Ee(u,n),u.length>e.length)throw new Error("array of scalars must be smaller than array of points");let l=i;for(let m=0;m<c;m++){if(l!==i)for(let p=0;p<r;p++)l=l.double();const v=BigInt(c*r-(m+1)*r);for(let p=0;p<u.length;p++){const R=u[p],g=Number(R>>v&a);g&&(l=l.add(o[p][g-1]))}}return l}}function Be(t){return He(t.Fp),It(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ct(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function pe(t){t.lowS!==void 0&&ut("lowS",t.lowS),t.prehash!==void 0&&ut("prehash",t.prehash)}function Ye(t){const n=Be(t);It(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:e,Fp:r,a:i}=n;if(e){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}class De extends Error{constructor(n=""){super(n)}}const X={Err:De,_tlv:{encode:(t,n)=>{const{Err:e}=X;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,i=lt(r);if(i.length/2&128)throw new e("tlv.encode: long form length too big");const s=r>127?lt(i.length/2|128):"";return lt(t)+s+i+n},decode(t,n){const{Err:e}=X;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const i=n[r++],s=!!(i&128);let c=0;if(!s)c=i;else{const o=i&127;if(!o)throw new e("tlv.decode(long): indefinite length not supported");if(o>4)throw new e("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+o);if(u.length!==o)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const l of u)c=c<<8|l;if(r+=o,c<128)throw new e("tlv.decode(long): not minimal encoding")}const a=n.subarray(r,r+c);if(a.length!==c)throw new e("tlv.decode: wrong value length");return{v:a,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=X;if(t<D)throw new n("integer: negative integers are not allowed");let e=lt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=X;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return F(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=X,i=K("signature",t),{v:s,l:c}=r.decode(48,i);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:a,l:o}=r.decode(2,s),{v:u,l}=r.decode(2,o);if(l.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(u)}},hexFromSig(t){const{_tlv:n,_int:e}=X,r=n.encode(2,e.encode(t.r)),i=n.encode(2,e.encode(t.s)),s=r+i;return n.encode(48,s)}};function Kt(t,n){return dt(wt(t,n))}const D=BigInt(0),U=BigInt(1),J=BigInt(2),gt=BigInt(3),Yt=BigInt(4);function We(t){const n=Ye(t),{Fp:e}=n,r=qt(n.n,n.nBitLength),i=n.toBytes||((E,f,w)=>{const y=f.toAffine();return St(Uint8Array.from([4]),e.toBytes(y.x),e.toBytes(y.y))}),s=n.fromBytes||(E=>{const f=E.subarray(1),w=e.fromBytes(f.subarray(0,e.BYTES)),y=e.fromBytes(f.subarray(e.BYTES,2*e.BYTES));return{x:w,y}});function c(E){const{a:f,b:w}=n,y=e.sqr(E),B=e.mul(y,E);return e.add(e.add(B,e.mul(E,f)),w)}function a(E,f){const w=e.sqr(f),y=c(E);return e.eql(w,y)}if(!a(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const o=e.mul(e.pow(n.a,gt),Yt),u=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(o,u)))throw new Error("bad curve params: a or b");function l(E){return Ut(E,U,n.n)}function m(E){const{allowedPrivateKeyLengths:f,nByteLength:w,wrapPrivateKey:y,n:B}=n;if(f&&typeof E!="bigint"){if(at(E)&&(E=dt(E)),typeof E!="string"||!f.includes(E.length))throw new Error("invalid private key");E=E.padStart(w*2,"0")}let I;try{I=typeof E=="bigint"?E:F(K("private key",E,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof E)}return y&&(I=V(I,B)),rt("private key",I,U,B),I}function v(E){if(!(E instanceof g))throw new Error("ProjectivePoint expected")}const p=ce((E,f)=>{const{px:w,py:y,pz:B}=E;if(e.eql(B,e.ONE))return{x:w,y};const I=E.is0();f==null&&(f=I?e.ONE:e.inv(B));const T=e.mul(w,f),k=e.mul(y,f),x=e.mul(B,f);if(I)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:T,y:k}}),R=ce(E=>{if(E.is0()){if(n.allowInfinityPoint&&!e.is0(E.py))return;throw new Error("bad point: ZERO")}const{x:f,y:w}=E.toAffine();if(!e.isValid(f)||!e.isValid(w))throw new Error("bad point: x or y not FE");if(!a(f,w))throw new Error("bad point: equation left != right");if(!E.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(f,w,y){if(f==null||!e.isValid(f))throw new Error("x required");if(w==null||!e.isValid(w)||e.is0(w))throw new Error("y required");if(y==null||!e.isValid(y))throw new Error("z required");this.px=f,this.py=w,this.pz=y,Object.freeze(this)}static fromAffine(f){const{x:w,y}=f||{};if(!f||!e.isValid(w)||!e.isValid(y))throw new Error("invalid affine point");if(f instanceof g)throw new Error("projective point not allowed");const B=I=>e.eql(I,e.ZERO);return B(w)&&B(y)?g.ZERO:new g(w,y,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const w=he(e,f.map(y=>y.pz));return f.map((y,B)=>y.toAffine(w[B])).map(g.fromAffine)}static fromHex(f){const w=g.fromAffine(s(K("pointHex",f)));return w.assertValidity(),w}static fromPrivateKey(f){return g.BASE.multiply(m(f))}static msm(f,w){return Ke(g,r,f,w)}_setWindowSize(f){Z.setWindowSize(this,f)}assertValidity(){R(this)}hasEvenY(){const{y:f}=this.toAffine();if(e.isOdd)return!e.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){v(f);const{px:w,py:y,pz:B}=this,{px:I,py:T,pz:k}=f,x=e.eql(e.mul(w,k),e.mul(I,B)),N=e.eql(e.mul(y,k),e.mul(T,B));return x&&N}negate(){return new g(this.px,e.neg(this.py),this.pz)}double(){const{a:f,b:w}=n,y=e.mul(w,gt),{px:B,py:I,pz:T}=this;let k=e.ZERO,x=e.ZERO,N=e.ZERO,S=e.mul(B,B),z=e.mul(I,I),h=e.mul(T,T),d=e.mul(B,I);return d=e.add(d,d),N=e.mul(B,T),N=e.add(N,N),k=e.mul(f,N),x=e.mul(y,h),x=e.add(k,x),k=e.sub(z,x),x=e.add(z,x),x=e.mul(k,x),k=e.mul(d,k),N=e.mul(y,N),h=e.mul(f,h),d=e.sub(S,h),d=e.mul(f,d),d=e.add(d,N),N=e.add(S,S),S=e.add(N,S),S=e.add(S,h),S=e.mul(S,d),x=e.add(x,S),h=e.mul(I,T),h=e.add(h,h),S=e.mul(h,d),k=e.sub(k,S),N=e.mul(h,z),N=e.add(N,N),N=e.add(N,N),new g(k,x,N)}add(f){v(f);const{px:w,py:y,pz:B}=this,{px:I,py:T,pz:k}=f;let x=e.ZERO,N=e.ZERO,S=e.ZERO;const z=n.a,h=e.mul(n.b,gt);let d=e.mul(w,I),b=e.mul(y,T),q=e.mul(B,k),A=e.add(w,y),O=e.add(I,T);A=e.mul(A,O),O=e.add(d,b),A=e.sub(A,O),O=e.add(w,B);let C=e.add(I,k);return O=e.mul(O,C),C=e.add(d,q),O=e.sub(O,C),C=e.add(y,B),x=e.add(T,k),C=e.mul(C,x),x=e.add(b,q),C=e.sub(C,x),S=e.mul(z,O),x=e.mul(h,q),S=e.add(x,S),x=e.sub(b,S),S=e.add(b,S),N=e.mul(x,S),b=e.add(d,d),b=e.add(b,d),q=e.mul(z,q),O=e.mul(h,O),b=e.add(b,q),q=e.sub(d,q),q=e.mul(z,q),O=e.add(O,q),d=e.mul(b,O),N=e.add(N,d),d=e.mul(C,O),x=e.mul(A,x),x=e.sub(x,d),d=e.mul(A,b),S=e.mul(C,S),S=e.add(S,d),new g(x,N,S)}subtract(f){return this.add(f.negate())}is0(){return this.equals(g.ZERO)}wNAF(f){return Z.wNAFCached(this,f,g.normalizeZ)}multiplyUnsafe(f){const{endo:w,n:y}=n;rt("scalar",f,D,y);const B=g.ZERO;if(f===D)return B;if(this.is0()||f===U)return this;if(!w||Z.hasPrecomputes(this))return Z.wNAFCachedUnsafe(this,f,g.normalizeZ);let{k1neg:I,k1:T,k2neg:k,k2:x}=w.splitScalar(f),N=B,S=B,z=this;for(;T>D||x>D;)T&U&&(N=N.add(z)),x&U&&(S=S.add(z)),z=z.double(),T>>=U,x>>=U;return I&&(N=N.negate()),k&&(S=S.negate()),S=new g(e.mul(S.px,w.beta),S.py,S.pz),N.add(S)}multiply(f){const{endo:w,n:y}=n;rt("scalar",f,U,y);let B,I;if(w){const{k1neg:T,k1:k,k2neg:x,k2:N}=w.splitScalar(f);let{p:S,f:z}=this.wNAF(k),{p:h,f:d}=this.wNAF(N);S=Z.constTimeNegate(T,S),h=Z.constTimeNegate(x,h),h=new g(e.mul(h.px,w.beta),h.py,h.pz),B=S.add(h),I=z.add(d)}else{const{p:T,f:k}=this.wNAF(f);B=T,I=k}return g.normalizeZ([B,I])[0]}multiplyAndAddUnsafe(f,w,y){const B=g.BASE,I=(k,x)=>x===D||x===U||!k.equals(B)?k.multiplyUnsafe(x):k.multiply(x),T=I(this,w).add(I(f,y));return T.is0()?void 0:T}toAffine(f){return p(this,f)}isTorsionFree(){const{h:f,isTorsionFree:w}=n;if(f===U)return!0;if(w)return w(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:w}=n;return f===U?this:w?w(g,this):this.multiplyUnsafe(n.h)}toRawBytes(f=!0){return ut("isCompressed",f),this.assertValidity(),i(g,this,f)}toHex(f=!0){return ut("isCompressed",f),dt(this.toRawBytes(f))}}g.BASE=new g(n.Gx,n.Gy,e.ONE),g.ZERO=new g(e.ZERO,e.ONE,e.ZERO);const{endo:L,nBitLength:_}=n,Z=je(g,L?Math.ceil(_/2):_);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:m,weierstrassEquation:c,isWithinCurveOrder:l}}function Ge(t){const n=Be(t);return It(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Xe(t){const n=Ge(t),{Fp:e,n:r,nByteLength:i,nBitLength:s}=n,c=e.BYTES+1,a=2*e.BYTES+1;function o(h){return V(h,r)}function u(h){return Ot(h,r)}const{ProjectivePoint:l,normPrivateKeyToScalar:m,weierstrassEquation:v,isWithinCurveOrder:p}=We({...n,toBytes(h,d,b){const q=d.toAffine(),A=e.toBytes(q.x),O=St;return ut("isCompressed",b),b?O(Uint8Array.from([d.hasEvenY()?2:3]),A):O(Uint8Array.from([4]),A,e.toBytes(q.y))},fromBytes(h){const d=h.length,b=h[0],q=h.subarray(1);if(d===c&&(b===2||b===3)){const A=F(q);if(!Ut(A,U,e.ORDER))throw new Error("Point is not on curve");const O=v(A);let C;try{C=e.sqrt(O)}catch(W){const j=W instanceof Error?": "+W.message:"";throw new Error("Point is not on curve"+j)}const M=(C&U)===U;return(b&1)===1!==M&&(C=e.neg(C)),{x:A,y:C}}else if(d===a&&b===4){const A=e.fromBytes(q.subarray(0,e.BYTES)),O=e.fromBytes(q.subarray(e.BYTES,2*e.BYTES));return{x:A,y:O}}else{const A=c,O=a;throw new Error("invalid Point, expected length of "+A+", or uncompressed "+O+", got "+d)}}});function R(h){const d=r>>U;return h>d}function g(h){return R(h)?o(-h):h}const L=(h,d,b)=>F(h.slice(d,b));class _{constructor(d,b,q){rt("r",d,U,r),rt("s",b,U,r),this.r=d,this.s=b,q!=null&&(this.recovery=q),Object.freeze(this)}static fromCompact(d){const b=i;return d=K("compactSignature",d,b*2),new _(L(d,0,b),L(d,b,2*b))}static fromDER(d){const{r:b,s:q}=X.toSig(K("DER",d));return new _(b,q)}assertValidity(){}addRecoveryBit(d){return new _(this.r,this.s,d)}recoverPublicKey(d){const{r:b,s:q,recovery:A}=this,O=B(K("msgHash",d));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");const C=A===2||A===3?b+n.n:b;if(C>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=A&1?"03":"02",Q=l.fromHex(M+Kt(C,e.BYTES)),W=u(C),j=o(-O*W),it=o(q*W),$=l.BASE.multiplyAndAddUnsafe(Q,j,it);if(!$)throw new Error("point at infinify");return $.assertValidity(),$}hasHighS(){return R(this.s)}normalizeS(){return this.hasHighS()?new _(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return X.hexFromSig(this)}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){const d=i;return Kt(this.r,d)+Kt(this.s,d)}}const Z={isValidPrivateKey(h){try{return m(h),!0}catch{return!1}},normPrivateKeyToScalar:m,randomPrivateKey:()=>{const h=ge(n.n);return Me(n.randomBytes(h),n.n)},precompute(h=8,d=l.BASE){return d._setWindowSize(h),d.multiply(BigInt(3)),d}};function E(h,d=!0){return l.fromPrivateKey(h).toRawBytes(d)}function f(h){if(typeof h=="bigint")return!1;if(h instanceof l)return!0;const b=K("key",h).length,q=e.BYTES,A=q+1,O=2*q+1;if(!(n.allowedPrivateKeyLengths||i===A))return b===A||b===O}function w(h,d,b=!0){if(f(h)===!0)throw new Error("first arg must be private key");if(f(d)===!1)throw new Error("second arg must be public key");return l.fromHex(d).multiply(m(h)).toRawBytes(b)}const y=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const d=F(h),b=h.length*8-s;return b>0?d>>BigInt(b):d},B=n.bits2int_modN||function(h){return o(y(h))},I=At(s);function T(h){return rt("num < 2^"+s,h,D,I),wt(h,i)}function k(h,d,b=x){if(["recovered","canonical"].some(et=>et in b))throw new Error("sign() legacy options not supported");const{hash:q,randomBytes:A}=n;let{lowS:O,prehash:C,extraEntropy:M}=b;O==null&&(O=!0),h=K("msgHash",h),pe(b),C&&(h=K("prehashed msgHash",q(h)));const Q=B(h),W=m(d),j=[T(W),T(Q)];if(M!=null&&M!==!1){const et=M===!0?A(e.BYTES):M;j.push(K("extraEntropy",et))}const it=St(...j),$=Q;function Ft(et){const st=y(et);if(!p(st))return;const te=u(st),Et=l.BASE.multiply(st).toAffine(),nt=o(Et.x);if(nt===D)return;const vt=o(te*o($+nt*W));if(vt===D)return;let Bt=(Et.x===nt?0:2)|Number(Et.y&U),ct=vt;return O&&R(vt)&&(ct=g(vt),Bt^=1),new _(nt,ct,Bt)}return{seed:it,k2sig:Ft}}const x={lowS:n.lowS,prehash:!1},N={lowS:n.lowS,prehash:!1};function S(h,d,b=x){const{seed:q,k2sig:A}=k(h,d,b),O=n;return Ue(O.hash.outputLen,O.nByteLength,O.hmac)(q,A)}l.BASE._setWindowSize(8);function z(h,d,b,q=N){var Bt;const A=h;d=K("msgHash",d),b=K("publicKey",b);const{lowS:O,prehash:C,format:M}=q;if(pe(q),"strict"in q)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const Q=typeof A=="string"||at(A),W=!Q&&!M&&typeof A=="object"&&A!==null&&typeof A.r=="bigint"&&typeof A.s=="bigint";if(!Q&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let j,it;try{if(W&&(j=new _(A.r,A.s)),Q){try{M!=="compact"&&(j=_.fromDER(A))}catch(ct){if(!(ct instanceof X.Err))throw ct}!j&&M!=="der"&&(j=_.fromCompact(A))}it=l.fromHex(b)}catch{return!1}if(!j||O&&j.hasHighS())return!1;C&&(d=n.hash(d));const{r:$,s:Ft}=j,et=B(d),st=u(Ft),te=o(et*st),Et=o($*st),nt=(Bt=l.BASE.multiplyAndAddUnsafe(it,te,Et))==null?void 0:Bt.toAffine();return nt?o(nt.x)===$:!1}return{CURVE:n,getPublicKey:E,getSharedSecret:w,sign:S,verify:z,ProjectivePoint:l,Signature:_,utils:Z}}function Qe(t,n){const e=t.ORDER;let r=D;for(let R=e-U;R%J===D;R/=J)r+=U;const i=r,s=J<<i-U-U,c=s*J,a=(e-U)/c,o=(a-U)/J,u=c-U,l=s,m=t.pow(n,a),v=t.pow(n,(a+U)/J);let p=(R,g)=>{let L=m,_=t.pow(g,u),Z=t.sqr(_);Z=t.mul(Z,g);let E=t.mul(R,Z);E=t.pow(E,o),E=t.mul(E,_),_=t.mul(E,g),Z=t.mul(E,R);let f=t.mul(Z,_);E=t.pow(f,l);let w=t.eql(E,t.ONE);_=t.mul(Z,v),E=t.mul(f,L),Z=t.cmov(_,Z,w),f=t.cmov(E,f,w);for(let y=i;y>U;y--){let B=y-J;B=J<<B-U;let I=t.pow(f,B);const T=t.eql(I,t.ONE);_=t.mul(Z,L),L=t.mul(L,L),I=t.mul(f,L),Z=t.cmov(_,Z,T),f=t.cmov(I,f,T)}return{isValid:w,value:Z}};if(t.ORDER%Yt===gt){const R=(t.ORDER-gt)/Yt,g=t.sqrt(t.neg(n));p=(L,_)=>{let Z=t.sqr(_);const E=t.mul(L,_);Z=t.mul(Z,E);let f=t.pow(Z,R);f=t.mul(f,E);const w=t.mul(f,g),y=t.mul(t.sqr(f),_),B=t.eql(y,L);let I=t.cmov(w,f,B);return{isValid:B,value:I}}}return p}function bn(t,n){if(validateField(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=Qe(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let i,s,c,a,o,u,l,m;i=t.sqr(r),i=t.mul(i,n.Z),s=t.sqr(i),s=t.add(s,i),c=t.add(s,t.ONE),c=t.mul(c,n.B),a=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),a=t.mul(a,n.A),s=t.sqr(c),u=t.sqr(a),o=t.mul(u,n.A),s=t.add(s,o),s=t.mul(s,c),u=t.mul(u,a),o=t.mul(u,n.B),s=t.add(s,o),l=t.mul(i,c);const{isValid:v,value:p}=e(s,u);m=t.mul(i,r),m=t.mul(m,p),l=t.cmov(l,c,v),m=t.cmov(m,p,v);const R=t.isOdd(r)===t.isOdd(m);m=t.cmov(t.neg(m),m,R);const g=FpInvertBatch(t,[a],!0)[0];return l=t.mul(l,g),{x:l,y:m}}}function Je(t){return{hash:t,hmac:(n,...e)=>(0,Re.b)(t,n,(0,Rt.eV)(...e)),randomBytes:Rt.O6}}function $e(t,n){const e=r=>Xe({...t,...Je(r)});return{...e(n),create:e}}const mt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Nt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Dt=BigInt(0),yt=BigInt(1),_t=BigInt(2),xe=(t,n)=>(t+n/_t)/n;function Se(t){const n=mt,e=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),c=BigInt(23),a=BigInt(44),o=BigInt(88),u=t*t*t%n,l=u*u*t%n,m=Y(l,e,n)*l%n,v=Y(m,e,n)*l%n,p=Y(v,_t,n)*u%n,R=Y(p,i,n)*p%n,g=Y(R,s,n)*R%n,L=Y(g,a,n)*g%n,_=Y(L,o,n)*L%n,Z=Y(_,a,n)*g%n,E=Y(Z,e,n)*l%n,f=Y(E,c,n)*R%n,w=Y(f,r,n)*u%n,y=Y(w,_t,n);if(!Wt.eql(Wt.sqr(y),t))throw new Error("Cannot find square root");return y}const Wt=qt(mt,void 0,void 0,{sqrt:Se}),Ae=$e({a:Dt,b:BigInt(7),Fp:Wt,n:Nt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Nt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-yt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,c=BigInt("0x100000000000000000000000000000000"),a=xe(s*t,n),o=xe(-r*t,n);let u=V(t-a*e-o*i,n),l=V(-a*r-o*s,n);const m=u>c,v=l>c;if(m&&(u=n-u),v&&(l=n-l),u>c||l>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:m,k1:u,k2neg:v,k2:l}}}},_e.JQ),Ie={};function Gt(t,...n){let e=Ie[t];if(e===void 0){const r=sha256(Uint8Array.from(t,i=>i.charCodeAt(0)));e=concatBytes(r,r),Ie[t]=e}return sha256(concatBytes(e,...n))}const Oe=t=>t.toRawBytes(!0).slice(1),Xt=t=>numberToBytesBE(t,32),Qt=t=>mod(t,mt),bt=t=>mod(t,Nt),Jt=null,Fe=(t,n,e)=>Jt.BASE.multiplyAndAddUnsafe(t,n,e);function $t(t){let n=Ae.utils.normPrivateKeyToScalar(t),e=Jt.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:bt(-n),bytes:Oe(e)}}function tn(t){aInRange("x",t,yt,mt);const n=Qt(t*t),e=Qt(n*t+BigInt(7));let r=Se(e);r%_t!==Dt&&(r=Qt(-r));const i=new Jt(t,r,yt);return i.assertValidity(),i}const ot=null;function qe(...t){return bt(ot(Gt("BIP0340/challenge",...t)))}function En(t){return $t(t).bytes}function vn(t,n,e=randomBytes(32)){const r=ensureBytes("message",t),{bytes:i,scalar:s}=$t(n),c=ensureBytes("auxRand",e,32),a=Xt(s^ot(Gt("BIP0340/aux",c))),o=Gt("BIP0340/nonce",a,i,r),u=bt(ot(o));if(u===Dt)throw new Error("sign failed: k is zero");const{bytes:l,scalar:m}=$t(u),v=qe(l,i,r),p=new Uint8Array(64);if(p.set(l,0),p.set(Xt(bt(m+v*s)),32),!en(p,r,i))throw new Error("sign: Invalid signature produced");return p}function en(t,n,e){const r=ensureBytes("signature",t,64),i=ensureBytes("message",n),s=ensureBytes("publicKey",e,32);try{const c=tn(ot(s)),a=ot(r.subarray(0,32));if(!inRange(a,yt,mt))return!1;const o=ot(r.subarray(32,64));if(!inRange(o,yt,Nt))return!1;const u=qe(Xt(a),Oe(c),i),l=Fe(c,o,bt(-u));return!(!l||!l.hasEvenY()||l.toAffine().x!==a)}catch{return!1}}const Bn=null,pn=null,xn=null,Sn=null,An=null,In=null}}]);
