"use strict";(self.webpackChunk_ant_design_web3_docs=self.webpackChunk_ant_design_web3_docs||[]).push([[8559],{98559:function(kl,ps,R){R.r(ps),R.d(ps,{UniversalProvider:function(){return Fl},default:function(){return vt}});var ve=R(72100),Pt=R.n(ve),_e=R(19994),Ui=R(94255),Ie=R(37353),Pe=R(41926);function $l(r){return r}const Ki="idb-keyval";var Vi=(r={})=>{const e=r.base&&r.base.length>0?`${r.base}:`:"",t=i=>e+i;let s;return r.dbName&&r.storeName&&(s=(0,Ie.MT)(r.dbName,r.storeName)),{name:Ki,options:r,async hasItem(i){return!(typeof await(0,Ie.U2)(t(i),s)>"u")},async getItem(i){return await(0,Ie.U2)(t(i),s)??null},setItem(i,o){return(0,Ie.t8)(t(i),o,s)},removeItem(i){return(0,Ie.IV)(t(i),s)},getKeys(){return(0,Ie.XP)(s)},clear(){return(0,Ie.ZH)(s)}}};const Bi="WALLET_CONNECT_V2_INDEXED_DB",Ji="keyvaluestorage";class Gi{constructor(){this.indexedDb=(0,Ui.o6)({driver:Vi({dbName:Bi,storeName:Ji})})}async getKeys(){return this.indexedDb.getKeys()}async getEntries(){return(await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e=>[e.key,e.value])}async getItem(e){const t=await this.indexedDb.getItem(e);if(t!==null)return t}async setItem(e,t){await this.indexedDb.setItem(e,(0,Pe.u)(t))}async removeItem(e){await this.indexedDb.removeItem(e)}}var Et=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof R.g<"u"?R.g:typeof self<"u"?self:{},ct={exports:{}};(function(){let r;function e(){}r=e,r.prototype.getItem=function(t){return this.hasOwnProperty(t)?String(this[t]):null},r.prototype.setItem=function(t,s){this[t]=String(s)},r.prototype.removeItem=function(t){delete this[t]},r.prototype.clear=function(){const t=this;Object.keys(t).forEach(function(s){t[s]=void 0,delete t[s]})},r.prototype.key=function(t){return t=t||0,Object.keys(this)[t]},r.prototype.__defineGetter__("length",function(){return Object.keys(this).length}),typeof Et<"u"&&Et.localStorage?ct.exports=Et.localStorage:typeof window<"u"&&window.localStorage?ct.exports=window.localStorage:ct.exports=new e})();function Qi(r){var e;return[r[0],(0,Pe.D)((e=r[1])!=null?e:"")]}class Wi{constructor(){this.localStorage=ct.exports}async getKeys(){return Object.keys(this.localStorage)}async getEntries(){return Object.entries(this.localStorage).map(Qi)}async getItem(e){const t=this.localStorage.getItem(e);if(t!==null)return(0,Pe.D)(t)}async setItem(e,t){this.localStorage.setItem(e,(0,Pe.u)(t))}async removeItem(e){this.localStorage.removeItem(e)}}const Yi="wc_storage_version",ds=1,Zi=async(r,e,t)=>{const s=Yi,i=await e.getItem(s);if(i&&i>=ds){t(e);return}const o=await r.getKeys();if(!o.length){t(e);return}const a=[];for(;o.length;){const h=o.shift();if(!h)continue;const p=h.toLowerCase();if(p.includes("wc@")||p.includes("walletconnect")||p.includes("wc_")||p.includes("wallet_connect")){const d=await r.getItem(h);await e.setItem(h,d),a.push(h)}}await e.setItem(s,ds),t(e),Xi(r,a)},Xi=async(r,e)=>{e.length&&e.forEach(async t=>{await r.removeItem(t)})};class er{constructor(){this.initialized=!1,this.setInitialized=t=>{this.storage=t,this.initialized=!0};const e=new Wi;this.storage=e;try{const t=new Gi;Zi(e,t,this.setInitialized)}catch{this.initialized=!0}}async getKeys(){return await this.initialize(),this.storage.getKeys()}async getEntries(){return await this.initialize(),this.storage.getEntries()}async getItem(e){return await this.initialize(),this.storage.getItem(e)}async setItem(e,t){return await this.initialize(),this.storage.setItem(e,t)}async removeItem(e){return await this.initialize(),this.storage.removeItem(e)}async initialize(){this.initialized||await new Promise(e=>{const t=setInterval(()=>{this.initialized&&(clearInterval(t),e())},20)})}}var O=R(56526),Ne=R(36900),tr=Object.defineProperty,sr=(r,e,t)=>e in r?tr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,us=(r,e,t)=>sr(r,typeof e!="symbol"?e+"":e,t);class ir extends Ne.q{constructor(e){super(),this.opts=e,us(this,"protocol","wc"),us(this,"version",2)}}class Ml{constructor(e,t,s){this.core=e,this.logger=t}}var rr=Object.defineProperty,nr=(r,e,t)=>e in r?rr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,or=(r,e,t)=>nr(r,typeof e!="symbol"?e+"":e,t);class ar extends Ne.q{constructor(e,t){super(),this.core=e,this.logger=t,or(this,"records",new Map)}}class cr{constructor(e,t){this.logger=e,this.core=t}}class hr extends Ne.q{constructor(e,t){super(),this.relayer=e,this.logger=t}}class lr extends Ne.q{constructor(e){super()}}class pr{constructor(e,t,s,i){this.core=e,this.logger=t,this.name=s}}var dr=Object.defineProperty,ur=(r,e,t)=>e in r?dr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,gr=(r,e,t)=>ur(r,typeof e!="symbol"?e+"":e,t);class Ll{constructor(){gr(this,"map",new Map)}}class yr extends Ne.q{constructor(e,t){super(),this.relayer=e,this.logger=t}}class Hl{constructor(e,t){this.core=e,this.logger=t}}class mr extends Ne.q{constructor(e,t){super(),this.core=e,this.logger=t}}class zl{constructor(e,t){this.logger=e,this.core=t}}class fr{constructor(e,t,s){this.core=e,this.logger=t,this.store=s}}class wr{constructor(e,t){this.projectId=e,this.logger=t}}class vr{constructor(e,t,s){this.core=e,this.logger=t,this.telemetryEnabled=s}}var br=Object.defineProperty,_r=(r,e,t)=>e in r?br(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,gs=(r,e,t)=>_r(r,typeof e!="symbol"?e+"":e,t);class Ul extends null{constructor(){super()}}class Ir{constructor(e){this.opts=e,gs(this,"protocol","wc"),gs(this,"version",2)}}class Kl extends null{constructor(){super()}}class Pr{constructor(e){this.client=e}}var b=R(46196),Fe=R(55710),c=R(24783),Er=R(5298),se=R(56390),P=R(23700),Sr=R(85452),xr=R(73079),St=R(55872).Buffer,Cr=R(14224);const ys="wc",fs=2,ht="core",ue=`${ys}@2:${ht}:`,Or={name:ht,logger:"error"},Rr={database:":memory:"},Tr="crypto",ws="client_ed25519_seed",Ar=b.ONE_DAY,qr="keychain",Nr="0.3",Fr="messages",Dr="0.3",jr=b.SIX_HOURS,kr="publisher",vs="irn",$r="error",bs="wss://relay.walletconnect.org",Mr="relayer",z={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},Lr="_subscription",ie={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},Hr=.1,Vl={database:":memory:"},xt="2.21.8",Bl=1e4,M={link_mode:"link_mode",relay:"relay"},lt={inbound:"inbound",outbound:"outbound"},zr="0.3",Ur="WALLETCONNECT_CLIENT_ID",_s="WALLETCONNECT_LINK_MODE_APPS",X={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},Jl=null,Kr="subscription",Vr="0.3",Gl=b.FIVE_SECONDS*1e3,Br="pairing",Jr="0.3",Ql=null,We={wc_pairingDelete:{req:{ttl:b.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:b.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:b.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:b.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:b.ONE_DAY,prompt:!1,tag:0},res:{ttl:b.ONE_DAY,prompt:!1,tag:0}}},Ee={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},he={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Gr="history",Qr="0.3",Wr="expirer",ne={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},Yr="0.3",Wl=null,Zr="verify-api",Xr="https://verify.walletconnect.com",Is="https://verify.walletconnect.org",Ye=Is,en=`${Ye}/v3`,tn=[Xr,Is],sn="echo",rn="https://echo.walletconnect.com",Yl="event-client",ge={pairing_started:"pairing_started",pairing_uri_validation_success:"pairing_uri_validation_success",pairing_uri_not_expired:"pairing_uri_not_expired",store_new_pairing:"store_new_pairing",subscribing_pairing_topic:"subscribing_pairing_topic",subscribe_pairing_topic_success:"subscribe_pairing_topic_success",existing_pairing:"existing_pairing",pairing_not_expired:"pairing_not_expired",emit_inactive_pairing:"emit_inactive_pairing",emit_session_proposal:"emit_session_proposal",subscribing_to_pairing_topic:"subscribing_to_pairing_topic"},fe={no_wss_connection:"no_wss_connection",no_internet_connection:"no_internet_connection",malformed_pairing_uri:"malformed_pairing_uri",active_pairing_already_exists:"active_pairing_already_exists",subscribe_pairing_topic_failure:"subscribe_pairing_topic_failure",pairing_expired:"pairing_expired",proposal_expired:"proposal_expired",proposal_listener_not_found:"proposal_listener_not_found"},be={session_approve_started:"session_approve_started",proposal_not_expired:"proposal_not_expired",session_namespaces_validation_success:"session_namespaces_validation_success",create_session_topic:"create_session_topic",subscribing_session_topic:"subscribing_session_topic",subscribe_session_topic_success:"subscribe_session_topic_success",publishing_session_approve:"publishing_session_approve",session_approve_publish_success:"session_approve_publish_success",store_session:"store_session",publishing_session_settle:"publishing_session_settle",session_settle_publish_success:"session_settle_publish_success"},Ze={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",proposal_expired:"proposal_expired",subscribe_session_topic_failure:"subscribe_session_topic_failure",session_approve_publish_failure:"session_approve_publish_failure",session_settle_publish_failure:"session_settle_publish_failure",session_approve_namespace_validation_failure:"session_approve_namespace_validation_failure",proposal_not_found:"proposal_not_found"},Se={authenticated_session_approve_started:"authenticated_session_approve_started",authenticated_session_not_expired:"authenticated_session_not_expired",chains_caip2_compliant:"chains_caip2_compliant",chains_evm_compliant:"chains_evm_compliant",create_authenticated_session_topic:"create_authenticated_session_topic",cacaos_verified:"cacaos_verified",store_authenticated_session:"store_authenticated_session",subscribing_authenticated_session_topic:"subscribing_authenticated_session_topic",subscribe_authenticated_session_topic_success:"subscribe_authenticated_session_topic_success",publishing_authenticated_session_approve:"publishing_authenticated_session_approve",authenticated_session_approve_publish_success:"authenticated_session_approve_publish_success"},Xe={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",missing_session_authenticate_request:"missing_session_authenticate_request",session_authenticate_request_expired:"session_authenticate_request_expired",chains_caip2_compliant_failure:"chains_caip2_compliant_failure",chains_evm_compliant_failure:"chains_evm_compliant_failure",invalid_cacao:"invalid_cacao",subscribe_authenticated_session_topic_failure:"subscribe_authenticated_session_topic_failure",authenticated_session_approve_publish_failure:"authenticated_session_approve_publish_failure",authenticated_session_pending_request_not_found:"authenticated_session_pending_request_not_found"},nn=.1,on="event-client",an=86400,cn="https://pulse.walletconnect.org/batch";function hn(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),s=0;s<t.length;s++)t[s]=255;for(var i=0;i<r.length;i++){var o=r.charAt(i),a=o.charCodeAt(0);if(t[a]!==255)throw new TypeError(o+" is ambiguous");t[a]=i}var h=r.length,p=r.charAt(0),d=Math.log(h)/Math.log(256),u=Math.log(256)/Math.log(h);function g(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var v=0,_=0,E=0,I=f.length;E!==I&&f[E]===0;)E++,v++;for(var F=(I-E)*u+1>>>0,C=new Uint8Array(F);E!==I;){for(var x=f[E],S=0,j=F-1;(x!==0||S<_)&&j!==-1;j--,S++)x+=256*C[j]>>>0,C[j]=x%h>>>0,x=x/h>>>0;if(x!==0)throw new Error("Non-zero carry");_=S,E++}for(var H=F-_;H!==F&&C[H]===0;)H++;for(var L=p.repeat(v);H<F;++H)L+=r.charAt(C[H]);return L}function w(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;var v=0;if(f[v]!==" "){for(var _=0,E=0;f[v]===p;)_++,v++;for(var I=(f.length-v)*d+1>>>0,F=new Uint8Array(I);f[v];){var C=t[f.charCodeAt(v)];if(C===255)return;for(var x=0,S=I-1;(C!==0||x<E)&&S!==-1;S--,x++)C+=h*F[S]>>>0,F[S]=C%256>>>0,C=C/256>>>0;if(C!==0)throw new Error("Non-zero carry");E=x,v++}if(f[v]!==" "){for(var j=I-E;j!==I&&F[j]===0;)j++;for(var H=new Uint8Array(_+(I-j)),L=_;j!==I;)H[L++]=F[j++];return H}}}function m(f){var v=w(f);if(v)return v;throw new Error(`Non-${e} character`)}return{encode:g,decodeUnsafe:w,decode:m}}var ln=hn,pn=ln;const Ps=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},dn=r=>new TextEncoder().encode(r),un=r=>new TextDecoder().decode(r);class gn{constructor(e,t,s){this.name=e,this.prefix=t,this.baseEncode=s}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class yn{constructor(e,t,s){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=s}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Es(this,e)}}class mn{constructor(e){this.decoders=e}or(e){return Es(this,e)}decode(e){const t=e[0],s=this.decoders[t];if(s)return s.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Es=(r,e)=>new mn({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class fn{constructor(e,t,s,i){this.name=e,this.prefix=t,this.baseEncode=s,this.baseDecode=i,this.encoder=new gn(e,t,s),this.decoder=new yn(e,t,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const pt=({name:r,prefix:e,encode:t,decode:s})=>new fn(r,e,t,s),et=({prefix:r,name:e,alphabet:t})=>{const{encode:s,decode:i}=pn(t,e);return pt({prefix:r,name:e,encode:s,decode:o=>Ps(i(o))})},wn=(r,e,t,s)=>{const i={};for(let u=0;u<e.length;++u)i[e[u]]=u;let o=r.length;for(;r[o-1]==="=";)--o;const a=new Uint8Array(o*t/8|0);let h=0,p=0,d=0;for(let u=0;u<o;++u){const g=i[r[u]];if(g===void 0)throw new SyntaxError(`Non-${s} character`);p=p<<t|g,h+=t,h>=8&&(h-=8,a[d++]=255&p>>h)}if(h>=t||255&p<<8-h)throw new SyntaxError("Unexpected end of data");return a},vn=(r,e,t)=>{const s=e[e.length-1]==="=",i=(1<<t)-1;let o="",a=0,h=0;for(let p=0;p<r.length;++p)for(h=h<<8|r[p],a+=8;a>t;)a-=t,o+=e[i&h>>a];if(a&&(o+=e[i&h<<t-a]),s)for(;o.length*t&7;)o+="=";return o},V=({name:r,prefix:e,bitsPerChar:t,alphabet:s})=>pt({prefix:e,name:r,encode(i){return vn(i,s,t)},decode(i){return wn(i,s,t,r)}}),bn=pt({prefix:"\0",name:"identity",encode:r=>un(r),decode:r=>dn(r)});var _n=Object.freeze({__proto__:null,identity:bn});const In=V({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Pn=Object.freeze({__proto__:null,base2:In});const En=V({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Sn=Object.freeze({__proto__:null,base8:En});const xn=et({prefix:"9",name:"base10",alphabet:"0123456789"});var Cn=Object.freeze({__proto__:null,base10:xn});const On=V({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Rn=V({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Tn=Object.freeze({__proto__:null,base16:On,base16upper:Rn});const An=V({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),qn=V({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Nn=V({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Fn=V({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Dn=V({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),jn=V({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),kn=V({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),$n=V({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Mn=V({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Ln=Object.freeze({__proto__:null,base32:An,base32upper:qn,base32pad:Nn,base32padupper:Fn,base32hex:Dn,base32hexupper:jn,base32hexpad:kn,base32hexpadupper:$n,base32z:Mn});const Hn=et({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),zn=et({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Un=Object.freeze({__proto__:null,base36:Hn,base36upper:zn});const Kn=et({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Vn=et({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Bn=Object.freeze({__proto__:null,base58btc:Kn,base58flickr:Vn});const Jn=V({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Gn=V({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Qn=V({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Wn=V({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Yn=Object.freeze({__proto__:null,base64:Jn,base64pad:Gn,base64url:Qn,base64urlpad:Wn});const Ss=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Zn=Ss.reduce((r,e,t)=>(r[t]=e,r),[]),Xn=Ss.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function eo(r){return r.reduce((e,t)=>(e+=Zn[t],e),"")}function to(r){const e=[];for(const t of r){const s=Xn[t.codePointAt(0)];if(s===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const so=pt({prefix:"\u{1F680}",name:"base256emoji",encode:eo,decode:to});var io=Object.freeze({__proto__:null,base256emoji:so}),ro=Cs,xs=128,no=127,oo=~no,ao=Math.pow(2,31);function Cs(r,e,t){e=e||[],t=t||0;for(var s=t;r>=ao;)e[t++]=r&255|xs,r/=128;for(;r&oo;)e[t++]=r&255|xs,r>>>=7;return e[t]=r|0,Cs.bytes=t-s+1,e}var co=Ct,ho=128,Os=127;function Ct(r,s){var t=0,s=s||0,i=0,o=s,a,h=r.length;do{if(o>=h)throw Ct.bytes=0,new RangeError("Could not decode varint");a=r[o++],t+=i<28?(a&Os)<<i:(a&Os)*Math.pow(2,i),i+=7}while(a>=ho);return Ct.bytes=o-s,t}var lo=Math.pow(2,7),po=Math.pow(2,14),uo=Math.pow(2,21),go=Math.pow(2,28),yo=Math.pow(2,35),mo=Math.pow(2,42),fo=Math.pow(2,49),wo=Math.pow(2,56),vo=Math.pow(2,63),bo=function(r){return r<lo?1:r<po?2:r<uo?3:r<go?4:r<yo?5:r<mo?6:r<fo?7:r<wo?8:r<vo?9:10},_o={encode:ro,decode:co,encodingLength:bo},Rs=_o;const Ts=(r,e,t=0)=>(Rs.encode(r,e,t),e),As=r=>Rs.encodingLength(r),Ot=(r,e)=>{const t=e.byteLength,s=As(r),i=s+As(t),o=new Uint8Array(i+t);return Ts(r,o,0),Ts(t,o,s),o.set(e,i),new Io(r,t,e,o)};class Io{constructor(e,t,s,i){this.code=e,this.size=t,this.digest=s,this.bytes=i}}const qs=({name:r,code:e,encode:t})=>new Po(r,e,t);class Po{constructor(e,t,s){this.name=e,this.code=t,this.encode=s}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?Ot(this.code,t):t.then(s=>Ot(this.code,s))}else throw Error("Unknown type, must be binary type")}}const Ns=r=>async e=>new Uint8Array(await crypto.subtle.digest(r,e)),Eo=qs({name:"sha2-256",code:18,encode:Ns("SHA-256")}),So=qs({name:"sha2-512",code:19,encode:Ns("SHA-512")});var xo=Object.freeze({__proto__:null,sha256:Eo,sha512:So});const Fs=0,Co="identity",Ds=Ps;var Oo=Object.freeze({__proto__:null,identity:{code:Fs,name:Co,encode:Ds,digest:r=>Ot(Fs,Ds(r))}});new TextEncoder,new TextDecoder;const js={..._n,...Pn,...Sn,...Cn,...Tn,...Ln,...Un,...Bn,...Yn,...io};({...xo,...Oo});function ks(r){return globalThis.Buffer!=null?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):r}function Ro(r=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?ks(globalThis.Buffer.allocUnsafe(r)):new Uint8Array(r)}function $s(r,e,t,s){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:s}}}const Ms=$s("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Rt=$s("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=Ro(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),To={utf8:Ms,"utf-8":Ms,hex:js.base16,latin1:Rt,ascii:Rt,binary:Rt,...js};function Ao(r,e="utf8"){const t=To[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?ks(globalThis.Buffer.from(r,"utf-8")):t.decoder.decode(`${t.prefix}${r}`)}var qo=Object.defineProperty,No=(r,e,t)=>e in r?qo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,ye=(r,e,t)=>No(r,typeof e!="symbol"?e+"":e,t);class Fo{constructor(e,t){this.core=e,this.logger=t,ye(this,"keychain",new Map),ye(this,"name",qr),ye(this,"version",Nr),ye(this,"initialized",!1),ye(this,"storagePrefix",ue),ye(this,"init",async()=>{if(!this.initialized){const s=await this.getKeyChain();typeof s<"u"&&(this.keychain=s),this.initialized=!0}}),ye(this,"has",s=>(this.isInitialized(),this.keychain.has(s))),ye(this,"set",async(s,i)=>{this.isInitialized(),this.keychain.set(s,i),await this.persist()}),ye(this,"get",s=>{this.isInitialized();const i=this.keychain.get(s);if(typeof i>"u"){const{message:o}=(0,c.kCb)("NO_MATCHING_KEY",`${this.name}: ${s}`);throw new Error(o)}return i}),ye(this,"del",async s=>{this.isInitialized(),this.keychain.delete(s),await this.persist()}),this.core=e,this.logger=(0,O.Ep)(t,this.name)}get context(){return(0,O.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,(0,c.KCv)(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?(0,c.IPd)(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}var Do=Object.defineProperty,jo=(r,e,t)=>e in r?Do(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,B=(r,e,t)=>jo(r,typeof e!="symbol"?e+"":e,t);class ko{constructor(e,t,s){this.core=e,this.logger=t,B(this,"name",Tr),B(this,"keychain"),B(this,"randomSessionIdentifier",(0,c.jdp)()),B(this,"initialized",!1),B(this,"init",async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)}),B(this,"hasKeys",i=>(this.isInitialized(),this.keychain.has(i))),B(this,"getClientId",async()=>{this.isInitialized();const i=await this.getClientSeed(),o=Fe.Au(i);return Fe.bG(o.publicKey)}),B(this,"generateKeyPair",()=>{this.isInitialized();const i=(0,c.Au2)();return this.setPrivateKey(i.publicKey,i.privateKey)}),B(this,"signJWT",async i=>{this.isInitialized();const o=await this.getClientSeed(),a=Fe.Au(o),h=this.randomSessionIdentifier,p=Ar;return await Fe.vf(h,i,p,a)}),B(this,"generateSharedKey",(i,o,a)=>{this.isInitialized();const h=this.getPrivateKey(i),p=(0,c.m$A)(h,o);return this.setSymKey(p,a)}),B(this,"setSymKey",async(i,o)=>{this.isInitialized();const a=o||(0,c.YmJ)(i);return await this.keychain.set(a,i),a}),B(this,"deleteKeyPair",async i=>{this.isInitialized(),await this.keychain.del(i)}),B(this,"deleteSymKey",async i=>{this.isInitialized(),await this.keychain.del(i)}),B(this,"encode",async(i,o,a)=>{this.isInitialized();const h=(0,c.ENt)(a),p=(0,Pe.u)(o);if((0,c.Hs$)(h))return(0,c.Spz)(p,a==null?void 0:a.encoding);if((0,c.Q8x)(h)){const w=h.senderPublicKey,m=h.receiverPublicKey;i=await this.generateSharedKey(w,m)}const d=this.getSymKey(i),{type:u,senderPublicKey:g}=h;return(0,c.HIp)({type:u,symKey:d,message:p,senderPublicKey:g,encoding:a==null?void 0:a.encoding})}),B(this,"decode",async(i,o,a)=>{this.isInitialized();const h=(0,c.Llj)(o,a);if((0,c.Hs$)(h)){const p=(0,c.xQU)(o,a==null?void 0:a.encoding);return(0,Pe.D)(p)}if((0,c.Q8x)(h)){const p=h.receiverPublicKey,d=h.senderPublicKey;i=await this.generateSharedKey(p,d)}try{const p=this.getSymKey(i),d=(0,c.peR)({symKey:p,encoded:o,encoding:a==null?void 0:a.encoding});return(0,Pe.D)(d)}catch(p){this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`),this.logger.error(p)}}),B(this,"getPayloadType",(i,o=c.$dT)=>{const a=(0,c.vBi)({encoded:i,encoding:o});return(0,c.WGe)(a.type)}),B(this,"getPayloadSenderPublicKey",(i,o=c.$dT)=>{const a=(0,c.vBi)({encoded:i,encoding:o});return a.senderPublicKey?(0,Er.BB)(a.senderPublicKey,c.AWt):void 0}),this.core=e,this.logger=(0,O.Ep)(t,this.name),this.keychain=s||new Fo(this.core,this.logger)}get context(){return(0,O.Fd)(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(ws)}catch{e=(0,c.jdp)(),await this.keychain.set(ws,e)}return Ao(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}var $o=Object.defineProperty,Mo=Object.defineProperties,Lo=Object.getOwnPropertyDescriptors,Ls=Object.getOwnPropertySymbols,Ho=Object.prototype.hasOwnProperty,zo=Object.prototype.propertyIsEnumerable,Tt=(r,e,t)=>e in r?$o(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Uo=(r,e)=>{for(var t in e||(e={}))Ho.call(e,t)&&Tt(r,t,e[t]);if(Ls)for(var t of Ls(e))zo.call(e,t)&&Tt(r,t,e[t]);return r},Ko=(r,e)=>Mo(r,Lo(e)),ee=(r,e,t)=>Tt(r,typeof e!="symbol"?e+"":e,t);class Vo extends cr{constructor(e,t){super(e,t),this.logger=e,this.core=t,ee(this,"messages",new Map),ee(this,"messagesWithoutClientAck",new Map),ee(this,"name",Fr),ee(this,"version",Dr),ee(this,"initialized",!1),ee(this,"storagePrefix",ue),ee(this,"init",async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const s=await this.getRelayerMessages();typeof s<"u"&&(this.messages=s);const i=await this.getRelayerMessagesWithoutClientAck();typeof i<"u"&&(this.messagesWithoutClientAck=i),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(s){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(s)}finally{this.initialized=!0}}}),ee(this,"set",async(s,i,o)=>{this.isInitialized();const a=(0,c.rjm)(i);let h=this.messages.get(s);if(typeof h>"u"&&(h={}),typeof h[a]<"u")return a;if(h[a]=i,this.messages.set(s,h),o===lt.inbound){const p=this.messagesWithoutClientAck.get(s)||{};this.messagesWithoutClientAck.set(s,Ko(Uo({},p),{[a]:i}))}return await this.persist(),a}),ee(this,"get",s=>{this.isInitialized();let i=this.messages.get(s);return typeof i>"u"&&(i={}),i}),ee(this,"getWithoutAck",s=>{this.isInitialized();const i={};for(const o of s){const a=this.messagesWithoutClientAck.get(o)||{};i[o]=Object.values(a)}return i}),ee(this,"has",(s,i)=>{this.isInitialized();const o=this.get(s),a=(0,c.rjm)(i);return typeof o[a]<"u"}),ee(this,"ack",async(s,i)=>{this.isInitialized();const o=this.messagesWithoutClientAck.get(s);if(typeof o>"u")return;const a=(0,c.rjm)(i);delete o[a],Object.keys(o).length===0?this.messagesWithoutClientAck.delete(s):this.messagesWithoutClientAck.set(s,o),await this.persist()}),ee(this,"del",async s=>{this.isInitialized(),this.messages.delete(s),this.messagesWithoutClientAck.delete(s),await this.persist()}),this.logger=(0,O.Ep)(e,this.name),this.core=t}get context(){return(0,O.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get storageKeyWithoutClientAck(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name+"_withoutClientAck"}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,(0,c.KCv)(e))}async setRelayerMessagesWithoutClientAck(e){await this.core.storage.setItem(this.storageKeyWithoutClientAck,(0,c.KCv)(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?(0,c.IPd)(e):void 0}async getRelayerMessagesWithoutClientAck(){const e=await this.core.storage.getItem(this.storageKeyWithoutClientAck);return typeof e<"u"?(0,c.IPd)(e):void 0}async persist(){await this.setRelayerMessages(this.messages),await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}var Bo=Object.defineProperty,Jo=Object.defineProperties,Go=Object.getOwnPropertyDescriptors,Hs=Object.getOwnPropertySymbols,Qo=Object.prototype.hasOwnProperty,Wo=Object.prototype.propertyIsEnumerable,At=(r,e,t)=>e in r?Bo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,De=(r,e)=>{for(var t in e||(e={}))Qo.call(e,t)&&At(r,t,e[t]);if(Hs)for(var t of Hs(e))Wo.call(e,t)&&At(r,t,e[t]);return r},zs=(r,e)=>Jo(r,Go(e)),oe=(r,e,t)=>At(r,typeof e!="symbol"?e+"":e,t);class Yo extends hr{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,oe(this,"events",new ve.EventEmitter),oe(this,"name",kr),oe(this,"queue",new Map),oe(this,"publishTimeout",(0,b.toMiliseconds)(b.ONE_MINUTE)),oe(this,"initialPublishTimeout",(0,b.toMiliseconds)(b.ONE_SECOND*15)),oe(this,"needsTransportRestart",!1),oe(this,"publish",async(s,i,o)=>{var a,h,p,d,u;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:s,message:i,opts:o}});const g=(o==null?void 0:o.ttl)||jr,w=(o==null?void 0:o.prompt)||!1,m=(o==null?void 0:o.tag)||0,f=(o==null?void 0:o.id)||(0,P.getBigIntRpcId)().toString(),v=(0,c.cOS)((0,c._HE)().protocol),_={id:f,method:(o==null?void 0:o.publishMethod)||v.publish,params:De({topic:s,message:i,ttl:g,prompt:w,tag:m,attestation:o==null?void 0:o.attestation},(o==null?void 0:o.tvf)&&{tvf:o.tvf})},E=`Failed to publish payload, please try again. id:${f} tag:${m}`;try{(0,c.o8e)((a=_.params)==null?void 0:a.prompt)&&((h=_.params)==null||delete h.prompt),(0,c.o8e)((p=_.params)==null?void 0:p.tag)&&((d=_.params)==null||delete d.tag);const I=new Promise(async F=>{const C=({id:S})=>{var j;((j=_.id)==null?void 0:j.toString())===S.toString()&&(this.removeRequestFromQueue(S),this.relayer.events.removeListener(z.publish,C),F())};this.relayer.events.on(z.publish,C);const x=(0,c.hFY)(new Promise((S,j)=>{this.rpcPublish(_,o).then(S).catch(H=>{this.logger.warn(H,H==null?void 0:H.message),j(H)})}),this.initialPublishTimeout,`Failed initial publish, retrying.... id:${f} tag:${m}`);try{await x,this.events.removeListener(z.publish,C)}catch(S){this.queue.set(f,{request:_,opts:o,attempt:1}),this.logger.warn(S,S==null?void 0:S.message)}});this.logger.trace({type:"method",method:"publish",params:{id:f,topic:s,message:i,opts:o}}),await(0,c.hFY)(I,this.publishTimeout,E)}catch(I){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(I),(u=o==null?void 0:o.internal)!=null&&u.throwOnFailedPublish)throw I}finally{this.queue.delete(f)}}),oe(this,"publishCustom",async s=>{var i,o,a,h,p;this.logger.debug("Publishing custom payload"),this.logger.trace({type:"method",method:"publishCustom",params:s});const{payload:d,opts:u={}}=s,{attestation:g,tvf:w,publishMethod:m,prompt:f,tag:v,ttl:_=b.FIVE_MINUTES}=u,E=u.id||(0,P.getBigIntRpcId)().toString(),I=(0,c.cOS)((0,c._HE)().protocol),F=m||I.publish,C={id:E,method:F,params:De(zs(De({},d),{ttl:_,prompt:f,tag:v,attestation:g}),w)},x=`Failed to publish custom payload, please try again. id:${E} tag:${v}`;try{(0,c.o8e)((i=C.params)==null?void 0:i.prompt)&&((o=C.params)==null||delete o.prompt),(0,c.o8e)((a=C.params)==null?void 0:a.tag)&&((h=C.params)==null||delete h.tag);const S=new Promise(async j=>{const H=({id:pe})=>{var Ae;((Ae=C.id)==null?void 0:Ae.toString())===pe.toString()&&(this.removeRequestFromQueue(pe),this.relayer.events.removeListener(z.publish,H),j())};this.relayer.events.on(z.publish,H);const L=(0,c.hFY)(new Promise((pe,Ae)=>{this.rpcPublish(C,u).then(pe).catch(we=>{this.logger.warn(we,we==null?void 0:we.message),Ae(we)})}),this.initialPublishTimeout,`Failed initial custom payload publish, retrying.... method:${F} id:${E} tag:${v}`);try{await L,this.events.removeListener(z.publish,H)}catch(pe){this.queue.set(E,{request:C,opts:u,attempt:1}),this.logger.warn(pe,pe==null?void 0:pe.message)}});this.logger.trace({type:"method",method:"publish",params:{id:E,payload:d,opts:u}}),await(0,c.hFY)(S,this.publishTimeout,x)}catch(S){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(S),(p=u==null?void 0:u.internal)!=null&&p.throwOnFailedPublish)throw S}finally{this.queue.delete(E)}}),oe(this,"on",(s,i)=>{this.events.on(s,i)}),oe(this,"once",(s,i)=>{this.events.once(s,i)}),oe(this,"off",(s,i)=>{this.events.off(s,i)}),oe(this,"removeListener",(s,i)=>{this.events.removeListener(s,i)}),this.relayer=e,this.logger=(0,O.Ep)(t,this.name),this.registerEventListeners()}get context(){return(0,O.Fd)(this.logger)}async rpcPublish(e,t){this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:e});const s=await this.relayer.request(e);return this.relayer.events.emit(z.publish,De(De({},e),t)),this.logger.debug("Successfully Published Payload"),s}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async(e,t)=>{var s;const i=e.attempt+1;this.queue.set(t,zs(De({},e),{attempt:i})),this.logger.warn({},`Publisher: queue->publishing: ${e.request.id}, tag: ${(s=e.request.params)==null?void 0:s.tag}, attempt: ${i}`),await this.rpcPublish(e.request,e.opts),this.logger.warn({},`Publisher: queue->published: ${e.request.id}`)})}registerEventListeners(){this.relayer.core.heartbeat.on(_e.Lx.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(z.connection_stalled);return}this.checkQueue()}),this.relayer.on(z.message_ack,e=>{this.removeRequestFromQueue(e.id.toString())})}}var Zo=Object.defineProperty,Xo=(r,e,t)=>e in r?Zo(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,je=(r,e,t)=>Xo(r,typeof e!="symbol"?e+"":e,t);class ea{constructor(){je(this,"map",new Map),je(this,"set",(e,t)=>{const s=this.get(e);this.exists(e,t)||this.map.set(e,[...s,t])}),je(this,"get",e=>this.map.get(e)||[]),je(this,"exists",(e,t)=>this.get(e).includes(t)),je(this,"delete",(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const s=this.get(e);if(!this.exists(e,t))return;const i=s.filter(o=>o!==t);if(!i.length){this.map.delete(e);return}this.map.set(e,i)}),je(this,"clear",()=>{this.map.clear()})}get topics(){return Array.from(this.map.keys())}}var ta=Object.defineProperty,sa=Object.defineProperties,ia=Object.getOwnPropertyDescriptors,Us=Object.getOwnPropertySymbols,ra=Object.prototype.hasOwnProperty,na=Object.prototype.propertyIsEnumerable,qt=(r,e,t)=>e in r?ta(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,tt=(r,e)=>{for(var t in e||(e={}))ra.call(e,t)&&qt(r,t,e[t]);if(Us)for(var t of Us(e))na.call(e,t)&&qt(r,t,e[t]);return r},Nt=(r,e)=>sa(r,ia(e)),k=(r,e,t)=>qt(r,typeof e!="symbol"?e+"":e,t);class oa extends yr{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,k(this,"subscriptions",new Map),k(this,"topicMap",new ea),k(this,"events",new ve.EventEmitter),k(this,"name",Kr),k(this,"version",Vr),k(this,"pending",new Map),k(this,"cached",[]),k(this,"initialized",!1),k(this,"storagePrefix",ue),k(this,"subscribeTimeout",(0,b.toMiliseconds)(b.ONE_MINUTE)),k(this,"initialSubscribeTimeout",(0,b.toMiliseconds)(b.ONE_SECOND*15)),k(this,"clientId"),k(this,"batchSubscribeTopicsLimit",500),k(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),await this.restore()),this.initialized=!0}),k(this,"subscribe",async(s,i)=>{var o;this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:i}});try{const a=(0,c._HE)(i),h={topic:s,relay:a,transportType:i==null?void 0:i.transportType};(o=i==null?void 0:i.internal)!=null&&o.skipSubscribe||this.pending.set(s,h);const p=await this.rpcSubscribe(s,a,i);return typeof p=="string"&&(this.onSubscribe(p,h),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:i}})),p}catch(a){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(a),a}}),k(this,"unsubscribe",async(s,i)=>{this.isInitialized(),typeof(i==null?void 0:i.id)<"u"?await this.unsubscribeById(s,i.id,i):await this.unsubscribeByTopic(s,i)}),k(this,"isSubscribed",s=>new Promise(i=>{i(this.topicMap.topics.includes(s))})),k(this,"isKnownTopic",s=>new Promise(i=>{i(this.topicMap.topics.includes(s)||this.pending.has(s)||this.cached.some(o=>o.topic===s))})),k(this,"on",(s,i)=>{this.events.on(s,i)}),k(this,"once",(s,i)=>{this.events.once(s,i)}),k(this,"off",(s,i)=>{this.events.off(s,i)}),k(this,"removeListener",(s,i)=>{this.events.removeListener(s,i)}),k(this,"start",async()=>{await this.onConnect()}),k(this,"stop",async()=>{await this.onDisconnect()}),k(this,"restart",async()=>{await this.restore(),await this.onRestart()}),k(this,"checkPending",async()=>{if(this.pending.size===0&&(!this.initialized||!this.relayer.connected))return;const s=[];this.pending.forEach(i=>{s.push(i)}),await this.batchSubscribe(s)}),k(this,"registerEventListeners",()=>{this.relayer.core.heartbeat.on(_e.Lx.pulse,async()=>{await this.checkPending()}),this.events.on(X.created,async s=>{const i=X.created;this.logger.info(`Emitting ${i}`),this.logger.debug({type:"event",event:i,data:s}),await this.persist()}),this.events.on(X.deleted,async s=>{const i=X.deleted;this.logger.info(`Emitting ${i}`),this.logger.debug({type:"event",event:i,data:s}),await this.persist()})}),this.relayer=e,this.logger=(0,O.Ep)(t,this.name),this.clientId=""}get context(){return(0,O.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}get hasAnyTopics(){return this.topicMap.topics.length>0||this.pending.size>0||this.cached.length>0||this.subscriptions.size>0}hasSubscription(e,t){let s=!1;try{s=this.getSubscription(e).topic===t}catch{}return s}reset(){this.cached=[],this.initialized=!0}onDisable(){this.values.length>0&&(this.cached=this.values),this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const s=this.topicMap.get(e);await Promise.all(s.map(async i=>await this.unsubscribeById(e,i,t)))}async unsubscribeById(e,t,s){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}});try{const i=(0,c._HE)(s);await this.restartToComplete({topic:e,id:t,relay:i}),await this.rpcUnsubscribe(e,t,i);const o=(0,c.D6H)("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,o),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}})}catch(i){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(i),i}}async rpcSubscribe(e,t,s){var i,o;const a=await this.getSubscriptionId(e);if((i=s==null?void 0:s.internal)!=null&&i.skipSubscribe)return a;(!s||(s==null?void 0:s.transportType)===M.relay)&&await this.restartToComplete({topic:e,id:e,relay:t});const h={method:(0,c.cOS)(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:h});const p=(o=s==null?void 0:s.internal)==null?void 0:o.throwOnFailedPublish;try{if((s==null?void 0:s.transportType)===M.link_mode)return setTimeout(()=>{(this.relayer.connected||this.relayer.connecting)&&this.relayer.request(h).catch(g=>this.logger.warn(g))},(0,b.toMiliseconds)(b.ONE_SECOND)),a;const d=new Promise(async g=>{const w=m=>{m.topic===e&&(this.events.removeListener(X.created,w),g(m.id))};this.events.on(X.created,w);try{const m=await(0,c.hFY)(new Promise((f,v)=>{this.relayer.request(h).catch(_=>{this.logger.warn(_,_==null?void 0:_.message),v(_)}).then(f)}),this.initialSubscribeTimeout,`Subscribing to ${e} failed, please try again`);this.events.removeListener(X.created,w),g(m)}catch{}}),u=await(0,c.hFY)(d,this.subscribeTimeout,`Subscribing to ${e} failed, please try again`);if(!u&&p)throw new Error(`Subscribing to ${e} failed, please try again`);return u?a:null}catch(d){if(this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(z.connection_stalled),p)throw d}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,s={method:(0,c.cOS)(t.protocol).batchSubscribe,params:{topics:e.map(i=>i.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});try{await await(0,c.hFY)(new Promise(i=>{this.relayer.request(s).catch(o=>this.logger.warn(o)).then(i)}),this.subscribeTimeout,"rpcBatchSubscribe failed, please try again")}catch{this.relayer.events.emit(z.connection_stalled)}}async rpcBatchFetchMessages(e){if(!e.length)return;const t=e[0].relay,s={method:(0,c.cOS)(t.protocol).batchFetchMessages,params:{topics:e.map(o=>o.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});let i;try{i=await await(0,c.hFY)(new Promise((o,a)=>{this.relayer.request(s).catch(h=>{this.logger.warn(h),a(h)}).then(o)}),this.subscribeTimeout,"rpcBatchFetchMessages failed, please try again")}catch{this.relayer.events.emit(z.connection_stalled)}return i}rpcUnsubscribe(e,t,s){const i={method:(0,c.cOS)(s.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i}),this.relayer.request(i)}onSubscribe(e,t){this.setSubscription(e,Nt(tt({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,tt({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,s){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,s),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,tt({},t)),this.topicMap.set(t.topic,e),this.events.emit(X.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:s}=(0,c.kCb)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const s=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(s.topic,e),this.events.emit(X.deleted,Nt(tt({},s),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(X.sync)}async onRestart(){if(this.cached.length){const e=[...this.cached],t=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let s=0;s<t;s++){const i=e.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(i)}}this.events.emit(X.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size&&!e.every(t=>{var s;return t.topic===((s=this.subscriptions.get(t.id))==null?void 0:s.topic)})){const{message:t}=(0,c.kCb)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){e.length&&(await this.rpcBatchSubscribe(e),this.onBatchSubscribe(await Promise.all(e.map(async t=>Nt(tt({},t),{id:await this.getSubscriptionId(t.topic)})))))}async batchFetchMessages(e){if(!e.length)return;this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);const t=await this.rpcBatchFetchMessages(e);t&&t.messages&&(await(0,c._vH)((0,b.toMiliseconds)(b.ONE_SECOND)),await this.relayer.handleBatchMessageEvents(t.messages))}async onConnect(){await this.restart(),this.reset()}onDisconnect(){this.onDisable()}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(e){!this.relayer.connected&&!this.relayer.connecting&&(this.cached.push(e),await this.relayer.transportOpen())}async getClientId(){return this.clientId||(this.clientId=await this.relayer.core.crypto.getClientId()),this.clientId}async getSubscriptionId(e){return(0,c.rjm)(e+await this.getClientId())}}var aa=Object.defineProperty,Ks=Object.getOwnPropertySymbols,ca=Object.prototype.hasOwnProperty,ha=Object.prototype.propertyIsEnumerable,Ft=(r,e,t)=>e in r?aa(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Vs=(r,e)=>{for(var t in e||(e={}))ca.call(e,t)&&Ft(r,t,e[t]);if(Ks)for(var t of Ks(e))ha.call(e,t)&&Ft(r,t,e[t]);return r},q=(r,e,t)=>Ft(r,typeof e!="symbol"?e+"":e,t);class la extends lr{constructor(e){super(e),q(this,"protocol","wc"),q(this,"version",2),q(this,"core"),q(this,"logger"),q(this,"events",new ve.EventEmitter),q(this,"provider"),q(this,"messages"),q(this,"subscriber"),q(this,"publisher"),q(this,"name",Mr),q(this,"transportExplicitlyClosed",!1),q(this,"initialized",!1),q(this,"connectionAttemptInProgress",!1),q(this,"relayUrl"),q(this,"projectId"),q(this,"packageName"),q(this,"bundleId"),q(this,"hasExperiencedNetworkDisruption",!1),q(this,"pingTimeout"),q(this,"heartBeatTimeout",(0,b.toMiliseconds)(b.THIRTY_SECONDS+b.FIVE_SECONDS)),q(this,"reconnectTimeout"),q(this,"connectPromise"),q(this,"reconnectInProgress",!1),q(this,"requestsInFlight",[]),q(this,"connectTimeout",(0,b.toMiliseconds)(b.ONE_SECOND*15)),q(this,"request",async t=>{var s,i;this.logger.debug("Publishing Request Payload");const o=t.id||(0,P.getBigIntRpcId)().toString();await this.toEstablishConnection();try{this.logger.trace({id:o,method:t.method,topic:(s=t.params)==null?void 0:s.topic},"relayer.request - publishing...");const a=`${o}:${((i=t.params)==null?void 0:i.tag)||""}`;this.requestsInFlight.push(a);const h=await this.provider.request(t);return this.requestsInFlight=this.requestsInFlight.filter(p=>p!==a),h}catch(a){throw this.logger.debug(`Failed to Publish Request: ${o}`),a}}),q(this,"resetPingTimeout",()=>{(0,c.UGU)()&&(clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout(()=>{var t,s,i,o;try{this.logger.debug({},"pingTimeout: Connection stalled, terminating..."),(o=(i=(s=(t=this.provider)==null?void 0:t.connection)==null?void 0:s.socket)==null?void 0:i.terminate)==null||o.call(i)}catch(a){this.logger.warn(a,a==null?void 0:a.message)}},this.heartBeatTimeout))}),q(this,"onPayloadHandler",t=>{this.onProviderPayload(t),this.resetPingTimeout()}),q(this,"onConnectHandler",()=>{this.logger.warn({},"Relayer connected \u{1F6DC}"),this.startPingTimeout(),this.events.emit(z.connect)}),q(this,"onDisconnectHandler",()=>{this.logger.warn({},"Relayer disconnected \u{1F6D1}"),this.requestsInFlight=[],this.onProviderDisconnect()}),q(this,"onProviderErrorHandler",t=>{this.logger.fatal(`Fatal socket error: ${t.message}`),this.events.emit(z.error,t),this.logger.fatal("Fatal socket error received, closing transport"),this.transportClose()}),q(this,"registerProviderListeners",()=>{this.provider.on(ie.payload,this.onPayloadHandler),this.provider.on(ie.connect,this.onConnectHandler),this.provider.on(ie.disconnect,this.onDisconnectHandler),this.provider.on(ie.error,this.onProviderErrorHandler)}),this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?(0,O.Ep)(e.logger,this.name):(0,O.gw)((0,O.jI)({level:e.logger||$r})),this.messages=new Vo(this.logger,e.core),this.subscriber=new oa(this,this.logger),this.publisher=new Yo(this,this.logger),this.projectId=e==null?void 0:e.projectId,this.relayUrl=(e==null?void 0:e.relayUrl)||bs,(0,c.DtP)()?this.packageName=(0,c.rhL)():(0,c.sa_)()&&(this.bundleId=(0,c.rhL)()),this.provider={}}async init(){this.logger.trace("Initialized"),this.registerEventListeners(),await Promise.all([this.messages.init(),this.subscriber.init()]),this.initialized=!0,this.transportOpen().catch(e=>this.logger.warn(e,e==null?void 0:e.message))}get context(){return(0,O.Fd)(this.logger)}get connected(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===1||!1}get connecting(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===0||this.connectPromise!==void 0||!1}async publish(e,t,s){this.isInitialized(),await this.publisher.publish(e,t,s),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now(),transportType:M.relay},lt.outbound)}async publishCustom(e){this.isInitialized(),await this.publisher.publishCustom(e)}async subscribe(e,t){var s,i,o;this.isInitialized(),(!(t!=null&&t.transportType)||(t==null?void 0:t.transportType)==="relay")&&await this.toEstablishConnection();const a=typeof((s=t==null?void 0:t.internal)==null?void 0:s.throwOnFailedPublish)>"u"?!0:(i=t==null?void 0:t.internal)==null?void 0:i.throwOnFailedPublish;let h=((o=this.subscriber.topicMap.get(e))==null?void 0:o[0])||"",p;const d=u=>{u.topic===e&&(this.subscriber.off(X.created,d),p())};return await Promise.all([new Promise(u=>{p=u,this.subscriber.on(X.created,d)}),new Promise(async(u,g)=>{h=await this.subscriber.subscribe(e,Vs({internal:{throwOnFailedPublish:a}},t)).catch(w=>{a&&g(w)})||h,u()})]),h}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){this.provider.disconnect&&(this.hasExperiencedNetworkDisruption||this.connected)?await(0,c.hFY)(this.provider.disconnect(),2e3,"provider.disconnect()").catch(()=>this.onProviderDisconnect()):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){if(!this.subscriber.hasAnyTopics){this.logger.info("Starting WS connection skipped because the client has no topics to work with.");return}if(this.connectPromise?(this.logger.debug({},"Waiting for existing connection attempt to resolve..."),await this.connectPromise,this.logger.debug({},"Existing connection attempt resolved")):(this.connectPromise=new Promise(async(t,s)=>{await this.connect(e).then(t).catch(s).finally(()=>{this.connectPromise=void 0})}),await this.connectPromise),!this.connected)throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)}async restartTransport(e){this.logger.debug({},"Restarting transport..."),!this.connectionAttemptInProgress&&(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await(0,c.Ggh)())throw new Error("No internet connection detected. Please restart your network and try again.")}async handleBatchMessageEvents(e){if((e==null?void 0:e.length)===0){this.logger.trace("Batch message events is empty. Ignoring...");return}const t=e.sort((s,i)=>s.publishedAt-i.publishedAt);this.logger.debug(`Batch of ${t.length} message events sorted`);for(const s of t)try{await this.onMessageEvent(s)}catch(i){this.logger.warn(i,"Error while processing batch message event: "+(i==null?void 0:i.message))}this.logger.trace(`Batch of ${t.length} message events processed`)}async onLinkMessageEvent(e,t){const{topic:s}=e;if(!t.sessionExists){const i=(0,c.gn4)(b.FIVE_MINUTES),o={topic:s,expiry:i,relay:{protocol:"irn"},active:!1};await this.core.pairing.pairings.set(s,o)}this.events.emit(z.message,e),await this.recordMessageEvent(e,lt.inbound)}async connect(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect()),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;let t=1;for(;t<6;){try{if(this.transportExplicitlyClosed)break;this.logger.debug({},`Connecting to ${this.relayUrl}, attempt: ${t}...`),await this.createProvider(),await new Promise(async(s,i)=>{const o=()=>{i(new Error("Connection interrupted while trying to connect"))};this.provider.once(ie.disconnect,o),await(0,c.hFY)(new Promise((a,h)=>{this.provider.connect().then(a).catch(h)}),this.connectTimeout,`Socket stalled when trying to connect to ${this.relayUrl}`).catch(a=>{i(a)}).finally(()=>{this.provider.off(ie.disconnect,o),clearTimeout(this.reconnectTimeout)}),await new Promise(async(a,h)=>{const p=()=>{i(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(ie.disconnect,p),await this.subscriber.start().then(a).catch(h).finally(()=>{this.provider.off(ie.disconnect,p)})}),this.hasExperiencedNetworkDisruption=!1,s()})}catch(s){await this.subscriber.stop();const i=s;this.logger.warn({},i.message),this.hasExperiencedNetworkDisruption=!0}finally{this.connectionAttemptInProgress=!1}if(this.connected){this.logger.debug({},`Connected to ${this.relayUrl} successfully on attempt: ${t}`);break}await new Promise(s=>setTimeout(s,(0,b.toMiliseconds)(t*1))),t++}}startPingTimeout(){var e,t,s,i,o;if((0,c.UGU)())try{(t=(e=this.provider)==null?void 0:e.connection)!=null&&t.socket&&((o=(i=(s=this.provider)==null?void 0:s.connection)==null?void 0:i.socket)==null||o.on("ping",()=>{this.resetPingTimeout()})),this.resetPingTimeout()}catch(a){this.logger.warn(a,a==null?void 0:a.message)}}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new se.r(new Sr.Z((0,c.$0m)({sdkVersion:xt,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId,packageName:this.packageName}))),this.registerProviderListeners()}async recordMessageEvent(e,t){const{topic:s,message:i}=e;await this.messages.set(s,i,t)}async shouldIgnoreMessageEvent(e){const{topic:t,message:s}=e;if(!s||s.length===0)return this.logger.warn(`Ignoring invalid/empty message: ${s}`),!0;if(!await this.subscriber.isKnownTopic(t))return this.logger.warn(`Ignoring message for unknown topic ${t}`),!0;const i=this.messages.has(t,s);return i&&this.logger.warn(`Ignoring duplicate message: ${s}`),i}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),(0,P.isJsonRpcRequest)(e)){if(!e.method.endsWith(Lr))return;const t=e.params,{topic:s,message:i,publishedAt:o,attestation:a}=t.data,h={topic:s,message:i,publishedAt:o,transportType:M.relay,attestation:a};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(Vs({type:"event",event:t.id},h)),this.events.emit(t.id,h),await this.acknowledgePayload(e),await this.onMessageEvent(h)}else(0,P.isJsonRpcResponse)(e)&&this.events.emit(z.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(await this.recordMessageEvent(e,lt.inbound),this.events.emit(z.message,e))}async acknowledgePayload(e){const t=(0,P.formatJsonRpcResult)(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(ie.payload,this.onPayloadHandler),this.provider.off(ie.connect,this.onConnectHandler),this.provider.off(ie.disconnect,this.onDisconnectHandler),this.provider.off(ie.error,this.onProviderErrorHandler),clearTimeout(this.pingTimeout)}async registerEventListeners(){let e=await(0,c.Ggh)();(0,c.uwg)(async t=>{e!==t&&(e=t,t?await this.transportOpen().catch(s=>this.logger.error(s,s==null?void 0:s.message)):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))}),this.core.heartbeat.on(_e.Lx.pulse,async()=>{if(!this.transportExplicitlyClosed&&!this.connected&&(0,c.YTu)())try{await this.confirmOnlineStateOrThrow(),await this.transportOpen()}catch(t){this.logger.warn(t,t==null?void 0:t.message)}})}async onProviderDisconnect(){clearTimeout(this.pingTimeout),this.events.emit(z.disconnect),this.connectionAttemptInProgress=!1,!this.reconnectInProgress&&(this.reconnectInProgress=!0,await this.subscriber.stop(),this.subscriber.hasAnyTopics&&(this.transportExplicitlyClosed||(this.reconnectTimeout=setTimeout(async()=>{await this.transportOpen().catch(e=>this.logger.error(e,e==null?void 0:e.message)),this.reconnectTimeout=void 0,this.reconnectInProgress=!1},(0,b.toMiliseconds)(Hr)))))}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(await this.confirmOnlineStateOrThrow(),!this.connected){if(this.connectPromise){await this.connectPromise;return}await this.connect()}}}function pa(r,e){return r===e||Number.isNaN(r)&&Number.isNaN(e)}function Bs(r){return Object.getOwnPropertySymbols(r).filter(e=>Object.prototype.propertyIsEnumerable.call(r,e))}function Js(r){return r==null?r===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(r)}const da="[object RegExp]",ua="[object String]",ga="[object Number]",ya="[object Boolean]",Gs="[object Arguments]",ma="[object Symbol]",fa="[object Date]",wa="[object Map]",va="[object Set]",ba="[object Array]",_a="[object Function]",Ia="[object ArrayBuffer]",Dt="[object Object]",Pa="[object Error]",Ea="[object DataView]",Sa="[object Uint8Array]",xa="[object Uint8ClampedArray]",Ca="[object Uint16Array]",Oa="[object Uint32Array]",Ra="[object BigUint64Array]",Ta="[object Int8Array]",Aa="[object Int16Array]",qa="[object Int32Array]",Na="[object BigInt64Array]",Fa="[object Float32Array]",Da="[object Float64Array]";function ja(){}function Qs(r){if(!r||typeof r!="object")return!1;const e=Object.getPrototypeOf(r);return e===null||e===Object.prototype||Object.getPrototypeOf(e)===null?Object.prototype.toString.call(r)==="[object Object]":!1}function ka(r,e,t){return st(r,e,void 0,void 0,void 0,void 0,t)}function st(r,e,t,s,i,o,a){const h=a(r,e,t,s,i,o);if(h!==void 0)return h;if(typeof r==typeof e)switch(typeof r){case"bigint":case"string":case"boolean":case"symbol":case"undefined":return r===e;case"number":return r===e||Object.is(r,e);case"function":return r===e;case"object":return it(r,e,o,a)}return it(r,e,o,a)}function it(r,e,t,s){if(Object.is(r,e))return!0;let i=Js(r),o=Js(e);if(i===Gs&&(i=Dt),o===Gs&&(o=Dt),i!==o)return!1;switch(i){case ua:return r.toString()===e.toString();case ga:{const p=r.valueOf(),d=e.valueOf();return pa(p,d)}case ya:case fa:case ma:return Object.is(r.valueOf(),e.valueOf());case da:return r.source===e.source&&r.flags===e.flags;case _a:return r===e}t=t??new Map;const a=t.get(r),h=t.get(e);if(a!=null&&h!=null)return a===e;t.set(r,e),t.set(e,r);try{switch(i){case wa:{if(r.size!==e.size)return!1;for(const[p,d]of r.entries())if(!e.has(p)||!st(d,e.get(p),p,r,e,t,s))return!1;return!0}case va:{if(r.size!==e.size)return!1;const p=Array.from(r.values()),d=Array.from(e.values());for(let u=0;u<p.length;u++){const g=p[u],w=d.findIndex(m=>st(g,m,void 0,r,e,t,s));if(w===-1)return!1;d.splice(w,1)}return!0}case ba:case Sa:case xa:case Ca:case Oa:case Ra:case Ta:case Aa:case qa:case Na:case Fa:case Da:{if(typeof St<"u"&&St.isBuffer(r)!==St.isBuffer(e)||r.length!==e.length)return!1;for(let p=0;p<r.length;p++)if(!st(r[p],e[p],p,r,e,t,s))return!1;return!0}case Ia:return r.byteLength!==e.byteLength?!1:it(new Uint8Array(r),new Uint8Array(e),t,s);case Ea:return r.byteLength!==e.byteLength||r.byteOffset!==e.byteOffset?!1:it(new Uint8Array(r),new Uint8Array(e),t,s);case Pa:return r.name===e.name&&r.message===e.message;case Dt:{if(!(it(r.constructor,e.constructor,t,s)||Qs(r)&&Qs(e)))return!1;const p=[...Object.keys(r),...Bs(r)],d=[...Object.keys(e),...Bs(e)];if(p.length!==d.length)return!1;for(let u=0;u<p.length;u++){const g=p[u],w=r[g];if(!Object.hasOwn(e,g))return!1;const m=e[g];if(!st(w,m,g,r,e,t,s))return!1}return!0}default:return!1}}finally{t.delete(r),t.delete(e)}}function $a(r,e){return ka(r,e,ja)}var Ma=Object.defineProperty,Ws=Object.getOwnPropertySymbols,La=Object.prototype.hasOwnProperty,Ha=Object.prototype.propertyIsEnumerable,jt=(r,e,t)=>e in r?Ma(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Ys=(r,e)=>{for(var t in e||(e={}))La.call(e,t)&&jt(r,t,e[t]);if(Ws)for(var t of Ws(e))Ha.call(e,t)&&jt(r,t,e[t]);return r},Y=(r,e,t)=>jt(r,typeof e!="symbol"?e+"":e,t);class xe extends pr{constructor(e,t,s,i=ue,o=void 0){super(e,t,s,i),this.core=e,this.logger=t,this.name=s,Y(this,"map",new Map),Y(this,"version",zr),Y(this,"cached",[]),Y(this,"initialized",!1),Y(this,"getKey"),Y(this,"storagePrefix",ue),Y(this,"recentlyDeleted",[]),Y(this,"recentlyDeletedLimit",200),Y(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(a=>{this.getKey&&a!==null&&!(0,c.o8e)(a)?this.map.set(this.getKey(a),a):(0,c.xWS)(a)?this.map.set(a.id,a):(0,c.h1R)(a)&&this.map.set(a.topic,a)}),this.cached=[],this.initialized=!0)}),Y(this,"set",async(a,h)=>{this.isInitialized(),this.map.has(a)?await this.update(a,h):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:a,value:h}),this.map.set(a,h),await this.persist())}),Y(this,"get",a=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:a}),this.getData(a))),Y(this,"getAll",a=>(this.isInitialized(),a?this.values.filter(h=>Object.keys(a).every(p=>$a(h[p],a[p]))):this.values)),Y(this,"update",async(a,h)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:a,update:h});const p=Ys(Ys({},this.getData(a)),h);this.map.set(a,p),await this.persist()}),Y(this,"delete",async(a,h)=>{this.isInitialized(),this.map.has(a)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:a,reason:h}),this.map.delete(a),this.addToRecentlyDeleted(a),await this.persist())}),this.logger=(0,O.Ep)(t,this.name),this.storagePrefix=i,this.getKey=o}get context(){return(0,O.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:i}=(0,c.kCb)("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}const{message:s}=(0,c.kCb)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(s),new Error(s)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=(0,c.kCb)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}var za=Object.defineProperty,Ua=(r,e,t)=>e in r?za(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,T=(r,e,t)=>Ua(r,typeof e!="symbol"?e+"":e,t);class Ka{constructor(e,t){this.core=e,this.logger=t,T(this,"name",Br),T(this,"version",Jr),T(this,"events",new(Pt())),T(this,"pairings"),T(this,"initialized",!1),T(this,"storagePrefix",ue),T(this,"ignoredPayloadTypes",[c.rVF]),T(this,"registeredMethods",[]),T(this,"init",async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))}),T(this,"register",({methods:s})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...s])]}),T(this,"create",async s=>{this.isInitialized();const i=(0,c.jdp)(),o=await this.core.crypto.setSymKey(i),a=(0,c.gn4)(b.FIVE_MINUTES),h={protocol:vs},p={topic:o,expiry:a,relay:h,active:!1,methods:s==null?void 0:s.methods},d=(0,c.Bvr)({protocol:this.core.protocol,version:this.core.version,topic:o,symKey:i,relay:h,expiryTimestamp:a,methods:s==null?void 0:s.methods});return this.events.emit(Ee.create,p),this.core.expirer.set(o,a),await this.pairings.set(o,p),await this.core.relayer.subscribe(o,{transportType:s==null?void 0:s.transportType,internal:s==null?void 0:s.internal}),{topic:o,uri:d}}),T(this,"pair",async s=>{this.isInitialized();const i=this.core.eventClient.createEvent({properties:{topic:s==null?void 0:s.uri,trace:[ge.pairing_started]}});this.isValidPair(s,i);const{topic:o,symKey:a,relay:h,expiryTimestamp:p,methods:d}=(0,c.heJ)(s.uri);i.props.properties.topic=o,i.addTrace(ge.pairing_uri_validation_success),i.addTrace(ge.pairing_uri_not_expired);let u;if(this.pairings.keys.includes(o)){if(u=this.pairings.get(o),i.addTrace(ge.existing_pairing),u.active)throw i.setError(fe.active_pairing_already_exists),new Error(`Pairing already exists: ${o}. Please try again with a new connection URI.`);i.addTrace(ge.pairing_not_expired)}const g=p||(0,c.gn4)(b.FIVE_MINUTES),w={topic:o,relay:h,expiry:g,active:!1,methods:d};this.core.expirer.set(o,g),await this.pairings.set(o,w),i.addTrace(ge.store_new_pairing),s.activatePairing&&await this.activate({topic:o}),this.events.emit(Ee.create,w),i.addTrace(ge.emit_inactive_pairing),this.core.crypto.keychain.has(o)||await this.core.crypto.setSymKey(a,o),i.addTrace(ge.subscribing_pairing_topic);try{await this.core.relayer.confirmOnlineStateOrThrow()}catch{i.setError(fe.no_internet_connection)}try{await this.core.relayer.subscribe(o,{relay:h})}catch(m){throw i.setError(fe.subscribe_pairing_topic_failure),m}return i.addTrace(ge.subscribe_pairing_topic_success),w}),T(this,"activate",async({topic:s})=>{this.isInitialized();const i=(0,c.gn4)(b.FIVE_MINUTES);this.core.expirer.set(s,i),await this.pairings.update(s,{active:!0,expiry:i})}),T(this,"ping",async s=>{this.isInitialized(),await this.isValidPing(s),this.logger.warn("ping() is deprecated and will be removed in the next major release.");const{topic:i}=s;if(this.pairings.keys.includes(i)){const o=await this.sendRequest(i,"wc_pairingPing",{}),{done:a,resolve:h,reject:p}=(0,c.H1S)();this.events.once((0,c.E0T)("pairing_ping",o),({error:d})=>{d?p(d):h()}),await a()}}),T(this,"updateExpiry",async({topic:s,expiry:i})=>{this.isInitialized(),await this.pairings.update(s,{expiry:i})}),T(this,"updateMetadata",async({topic:s,metadata:i})=>{this.isInitialized(),await this.pairings.update(s,{peerMetadata:i})}),T(this,"getPairings",()=>(this.isInitialized(),this.pairings.values)),T(this,"disconnect",async s=>{this.isInitialized(),await this.isValidDisconnect(s);const{topic:i}=s;this.pairings.keys.includes(i)&&(await this.sendRequest(i,"wc_pairingDelete",(0,c.D6H)("USER_DISCONNECTED")),await this.deletePairing(i))}),T(this,"formatUriFromPairing",s=>{this.isInitialized();const{topic:i,relay:o,expiry:a,methods:h}=s,p=this.core.crypto.keychain.get(i);return(0,c.Bvr)({protocol:this.core.protocol,version:this.core.version,topic:i,symKey:p,relay:o,expiryTimestamp:a,methods:h})}),T(this,"sendRequest",async(s,i,o)=>{const a=(0,P.formatJsonRpcRequest)(i,o),h=await this.core.crypto.encode(s,a),p=We[i].req;return this.core.history.set(s,a),this.core.relayer.publish(s,h,p),a.id}),T(this,"sendResult",async(s,i,o)=>{const a=(0,P.formatJsonRpcResult)(s,o),h=await this.core.crypto.encode(i,a),p=(await this.core.history.get(i,s)).request.method,d=We[p].res;await this.core.relayer.publish(i,h,d),await this.core.history.resolve(a)}),T(this,"sendError",async(s,i,o)=>{const a=(0,P.formatJsonRpcError)(s,o),h=await this.core.crypto.encode(i,a),p=(await this.core.history.get(i,s)).request.method,d=We[p]?We[p].res:We.unregistered_method.res;await this.core.relayer.publish(i,h,d),await this.core.history.resolve(a)}),T(this,"deletePairing",async(s,i)=>{await this.core.relayer.unsubscribe(s),await Promise.all([this.pairings.delete(s,(0,c.D6H)("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(s),i?Promise.resolve():this.core.expirer.del(s)])}),T(this,"cleanup",async()=>{const s=this.pairings.getAll().filter(i=>(0,c.BwD)(i.expiry));await Promise.all(s.map(i=>this.deletePairing(i.topic)))}),T(this,"onRelayEventRequest",async s=>{const{topic:i,payload:o}=s;switch(o.method){case"wc_pairingPing":return await this.onPairingPingRequest(i,o);case"wc_pairingDelete":return await this.onPairingDeleteRequest(i,o);default:return await this.onUnknownRpcMethodRequest(i,o)}}),T(this,"onRelayEventResponse",async s=>{const{topic:i,payload:o}=s,a=(await this.core.history.get(i,o.id)).request.method;switch(a){case"wc_pairingPing":return this.onPairingPingResponse(i,o);default:return this.onUnknownRpcMethodResponse(a)}}),T(this,"onPairingPingRequest",async(s,i)=>{const{id:o}=i;try{this.isValidPing({topic:s}),await this.sendResult(o,s,!0),this.events.emit(Ee.ping,{id:o,topic:s})}catch(a){await this.sendError(o,s,a),this.logger.error(a)}}),T(this,"onPairingPingResponse",(s,i)=>{const{id:o}=i;setTimeout(()=>{(0,P.isJsonRpcResult)(i)?this.events.emit((0,c.E0T)("pairing_ping",o),{}):(0,P.isJsonRpcError)(i)&&this.events.emit((0,c.E0T)("pairing_ping",o),{error:i.error})},500)}),T(this,"onPairingDeleteRequest",async(s,i)=>{const{id:o}=i;try{this.isValidDisconnect({topic:s}),await this.deletePairing(s),this.events.emit(Ee.delete,{id:o,topic:s})}catch(a){await this.sendError(o,s,a),this.logger.error(a)}}),T(this,"onUnknownRpcMethodRequest",async(s,i)=>{const{id:o,method:a}=i;try{if(this.registeredMethods.includes(a))return;const h=(0,c.D6H)("WC_METHOD_UNSUPPORTED",a);await this.sendError(o,s,h),this.logger.error(h)}catch(h){await this.sendError(o,s,h),this.logger.error(h)}}),T(this,"onUnknownRpcMethodResponse",s=>{this.registeredMethods.includes(s)||this.logger.error((0,c.D6H)("WC_METHOD_UNSUPPORTED",s))}),T(this,"isValidPair",(s,i)=>{var o;if(!(0,c.EJd)(s)){const{message:h}=(0,c.kCb)("MISSING_OR_INVALID",`pair() params: ${s}`);throw i.setError(fe.malformed_pairing_uri),new Error(h)}if(!(0,c.jvJ)(s.uri)){const{message:h}=(0,c.kCb)("MISSING_OR_INVALID",`pair() uri: ${s.uri}`);throw i.setError(fe.malformed_pairing_uri),new Error(h)}const a=(0,c.heJ)(s==null?void 0:s.uri);if(!((o=a==null?void 0:a.relay)!=null&&o.protocol)){const{message:h}=(0,c.kCb)("MISSING_OR_INVALID","pair() uri#relay-protocol");throw i.setError(fe.malformed_pairing_uri),new Error(h)}if(!(a!=null&&a.symKey)){const{message:h}=(0,c.kCb)("MISSING_OR_INVALID","pair() uri#symKey");throw i.setError(fe.malformed_pairing_uri),new Error(h)}if(a!=null&&a.expiryTimestamp&&(0,b.toMiliseconds)(a==null?void 0:a.expiryTimestamp)<Date.now()){i.setError(fe.pairing_expired);const{message:h}=(0,c.kCb)("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(h)}}),T(this,"isValidPing",async s=>{if(!(0,c.EJd)(s)){const{message:o}=(0,c.kCb)("MISSING_OR_INVALID",`ping() params: ${s}`);throw new Error(o)}const{topic:i}=s;await this.isValidPairingTopic(i)}),T(this,"isValidDisconnect",async s=>{if(!(0,c.EJd)(s)){const{message:o}=(0,c.kCb)("MISSING_OR_INVALID",`disconnect() params: ${s}`);throw new Error(o)}const{topic:i}=s;await this.isValidPairingTopic(i)}),T(this,"isValidPairingTopic",async s=>{if(!(0,c.M_r)(s,!1)){const{message:i}=(0,c.kCb)("MISSING_OR_INVALID",`pairing topic should be a string: ${s}`);throw new Error(i)}if(!this.pairings.keys.includes(s)){const{message:i}=(0,c.kCb)("NO_MATCHING_KEY",`pairing topic doesn't exist: ${s}`);throw new Error(i)}if((0,c.BwD)(this.pairings.get(s).expiry)){await this.deletePairing(s);const{message:i}=(0,c.kCb)("EXPIRED",`pairing topic: ${s}`);throw new Error(i)}}),this.core=e,this.logger=(0,O.Ep)(t,this.name),this.pairings=new xe(this.core,this.logger,this.name,this.storagePrefix)}get context(){return(0,O.Fd)(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(z.message,async e=>{const{topic:t,message:s,transportType:i}=e;if(this.pairings.keys.includes(t)&&i!==M.link_mode&&!this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s)))try{const o=await this.core.crypto.decode(t,s);(0,P.isJsonRpcRequest)(o)?(this.core.history.set(t,o),await this.onRelayEventRequest({topic:t,payload:o})):(0,P.isJsonRpcResponse)(o)&&(await this.core.history.resolve(o),await this.onRelayEventResponse({topic:t,payload:o}),this.core.history.delete(t,o.id)),await this.core.relayer.messages.ack(t,s)}catch(o){this.logger.error(o)}})}registerExpirerEvents(){this.core.expirer.on(ne.expired,async e=>{const{topic:t}=(0,c.iPz)(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(Ee.expire,{topic:t}))})}}var Va=Object.defineProperty,Ba=(r,e,t)=>e in r?Va(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,J=(r,e,t)=>Ba(r,typeof e!="symbol"?e+"":e,t);class Ja extends ar{constructor(e,t){super(e,t),this.core=e,this.logger=t,J(this,"records",new Map),J(this,"events",new ve.EventEmitter),J(this,"name",Gr),J(this,"version",Qr),J(this,"cached",[]),J(this,"initialized",!1),J(this,"storagePrefix",ue),J(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.records.set(s.id,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),J(this,"set",(s,i,o)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:s,request:i,chainId:o}),this.records.has(i.id))return;const a={id:i.id,topic:s,request:{method:i.method,params:i.params||null},chainId:o,expiry:(0,c.gn4)(b.THIRTY_DAYS)};this.records.set(a.id,a),this.persist(),this.events.emit(he.created,a)}),J(this,"resolve",async s=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:s}),!this.records.has(s.id))return;const i=await this.getRecord(s.id);typeof i.response>"u"&&(i.response=(0,P.isJsonRpcError)(s)?{error:s.error}:{result:s.result},this.records.set(i.id,i),this.persist(),this.events.emit(he.updated,i))}),J(this,"get",async(s,i)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:s,id:i}),await this.getRecord(i))),J(this,"delete",(s,i)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:i}),this.values.forEach(o=>{if(o.topic===s){if(typeof i<"u"&&o.id!==i)return;this.records.delete(o.id),this.events.emit(he.deleted,o)}}),this.persist()}),J(this,"exists",async(s,i)=>(this.isInitialized(),this.records.has(i)?(await this.getRecord(i)).topic===s:!1)),J(this,"on",(s,i)=>{this.events.on(s,i)}),J(this,"once",(s,i)=>{this.events.once(s,i)}),J(this,"off",(s,i)=>{this.events.off(s,i)}),J(this,"removeListener",(s,i)=>{this.events.removeListener(s,i)}),this.logger=(0,O.Ep)(t,this.name)}get context(){return(0,O.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const s={topic:t.topic,request:(0,P.formatJsonRpcRequest)(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(s)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:s}=(0,c.kCb)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(he.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=(0,c.kCb)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(he.created,e=>{const t=he.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(he.updated,e=>{const t=he.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(he.deleted,e=>{const t=he.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.core.heartbeat.on(_e.Lx.pulse,()=>{this.cleanup()})}cleanup(){try{this.isInitialized();let e=!1;this.records.forEach(t=>{(0,b.toMiliseconds)(t.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${t.id}`),this.records.delete(t.id),this.events.emit(he.deleted,t,!1),e=!0)}),e&&this.persist()}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}var Ga=Object.defineProperty,Qa=(r,e,t)=>e in r?Ga(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Q=(r,e,t)=>Qa(r,typeof e!="symbol"?e+"":e,t);class Wa extends mr{constructor(e,t){super(e,t),this.core=e,this.logger=t,Q(this,"expirations",new Map),Q(this,"events",new ve.EventEmitter),Q(this,"name",Wr),Q(this,"version",Yr),Q(this,"cached",[]),Q(this,"initialized",!1),Q(this,"storagePrefix",ue),Q(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.expirations.set(s.target,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),Q(this,"has",s=>{try{const i=this.formatTarget(s);return typeof this.getExpiration(i)<"u"}catch{return!1}}),Q(this,"set",(s,i)=>{this.isInitialized();const o=this.formatTarget(s),a={target:o,expiry:i};this.expirations.set(o,a),this.checkExpiry(o,a),this.events.emit(ne.created,{target:o,expiration:a})}),Q(this,"get",s=>{this.isInitialized();const i=this.formatTarget(s);return this.getExpiration(i)}),Q(this,"del",s=>{if(this.isInitialized(),this.has(s)){const i=this.formatTarget(s),o=this.getExpiration(i);this.expirations.delete(i),this.events.emit(ne.deleted,{target:i,expiration:o})}}),Q(this,"on",(s,i)=>{this.events.on(s,i)}),Q(this,"once",(s,i)=>{this.events.once(s,i)}),Q(this,"off",(s,i)=>{this.events.off(s,i)}),Q(this,"removeListener",(s,i)=>{this.events.removeListener(s,i)}),this.logger=(0,O.Ep)(t,this.name)}get context(){return(0,O.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return(0,c.Z42)(e);if(typeof e=="number")return(0,c.GqV)(e);const{message:t}=(0,c.kCb)("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(ne.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=(0,c.kCb)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:s}=(0,c.kCb)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(s),new Error(s)}return t}checkExpiry(e,t){const{expiry:s}=t;(0,b.toMiliseconds)(s)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(ne.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(_e.Lx.pulse,()=>this.checkExpirations()),this.events.on(ne.created,e=>{const t=ne.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(ne.expired,e=>{const t=ne.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(ne.deleted,e=>{const t=ne.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}}var Ya=Object.defineProperty,Za=(r,e,t)=>e in r?Ya(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,U=(r,e,t)=>Za(r,typeof e!="symbol"?e+"":e,t);class Xa extends fr{constructor(e,t,s){super(e,t,s),this.core=e,this.logger=t,this.store=s,U(this,"name",Zr),U(this,"abortController"),U(this,"isDevEnv"),U(this,"verifyUrlV3",en),U(this,"storagePrefix",ue),U(this,"version",fs),U(this,"publicKey"),U(this,"fetchPromise"),U(this,"init",async()=>{var i;this.isDevEnv||(this.publicKey=await this.store.getItem(this.storeKey),this.publicKey&&(0,b.toMiliseconds)((i=this.publicKey)==null?void 0:i.expiresAt)<Date.now()&&(this.logger.debug("verify v2 public key expired"),await this.removePublicKey()))}),U(this,"register",async i=>{if(!(0,c.jUY)()||this.isDevEnv)return;const o=window.location.origin,{id:a,decryptedId:h}=i,p=`${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${o}&id=${a}&decryptedId=${h}`;try{const d=(0,xr.getDocument)(),u=this.startAbortTimer(b.ONE_SECOND*5),g=await new Promise((w,m)=>{const f=()=>{window.removeEventListener("message",_),d.body.removeChild(v),m("attestation aborted")};this.abortController.signal.addEventListener("abort",f);const v=d.createElement("iframe");v.src=p,v.style.display="none",v.addEventListener("error",f,{signal:this.abortController.signal});const _=E=>{if(E.data&&typeof E.data=="string")try{const I=JSON.parse(E.data);if(I.type==="verify_attestation"){if((0,Fe.xp)(I.attestation).payload.id!==a)return;clearInterval(u),d.body.removeChild(v),this.abortController.signal.removeEventListener("abort",f),window.removeEventListener("message",_),w(I.attestation===null?"":I.attestation)}}catch(I){this.logger.warn(I)}};d.body.appendChild(v),window.addEventListener("message",_,{signal:this.abortController.signal})});return this.logger.debug("jwt attestation",g),g}catch(d){this.logger.warn(d)}return""}),U(this,"resolve",async i=>{if(this.isDevEnv)return"";const{attestationId:o,hash:a,encryptedId:h}=i;if(o===""){this.logger.debug("resolve: attestationId is empty, skipping");return}if(o){if((0,Fe.xp)(o).payload.id!==h)return;const d=await this.isValidJwtAttestation(o);if(d){if(!d.isVerified){this.logger.warn("resolve: jwt attestation: origin url not verified");return}return d}}if(!a)return;const p=this.getVerifyUrl(i==null?void 0:i.verifyUrl);return this.fetchAttestation(a,p)}),U(this,"fetchAttestation",async(i,o)=>{this.logger.debug(`resolving attestation: ${i} from url: ${o}`);const a=this.startAbortTimer(b.ONE_SECOND*5),h=await fetch(`${o}/attestation/${i}?v2Supported=true`,{signal:this.abortController.signal});return clearTimeout(a),h.status===200?await h.json():void 0}),U(this,"getVerifyUrl",i=>{let o=i||Ye;return tn.includes(o)||(this.logger.info(`verify url: ${o}, not included in trusted list, assigning default: ${Ye}`),o=Ye),o}),U(this,"fetchPublicKey",async()=>{try{this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);const i=this.startAbortTimer(b.FIVE_SECONDS),o=await fetch(`${this.verifyUrlV3}/public-key`,{signal:this.abortController.signal});return clearTimeout(i),await o.json()}catch(i){this.logger.warn(i)}}),U(this,"persistPublicKey",async i=>{this.logger.debug("persisting public key to local storage",i),await this.store.setItem(this.storeKey,i),this.publicKey=i}),U(this,"removePublicKey",async()=>{this.logger.debug("removing verify v2 public key from storage"),await this.store.removeItem(this.storeKey),this.publicKey=void 0}),U(this,"isValidJwtAttestation",async i=>{const o=await this.getPublicKey();try{if(o)return this.validateAttestation(i,o)}catch(h){this.logger.error(h),this.logger.warn("error validating attestation")}const a=await this.fetchAndPersistPublicKey();try{if(a)return this.validateAttestation(i,a)}catch(h){this.logger.error(h),this.logger.warn("error validating attestation")}}),U(this,"getPublicKey",async()=>this.publicKey?this.publicKey:await this.fetchAndPersistPublicKey()),U(this,"fetchAndPersistPublicKey",async()=>{if(this.fetchPromise)return await this.fetchPromise,this.publicKey;this.fetchPromise=new Promise(async o=>{const a=await this.fetchPublicKey();a&&(await this.persistPublicKey(a),o(a))});const i=await this.fetchPromise;return this.fetchPromise=void 0,i}),U(this,"validateAttestation",(i,o)=>{const a=(0,c.NbI)(i,o.publicKey),h={hasExpired:(0,b.toMiliseconds)(a.exp)<Date.now(),payload:a};if(h.hasExpired)throw this.logger.warn("resolve: jwt attestation expired"),new Error("JWT attestation expired");return{origin:h.payload.origin,isScam:h.payload.isScam,isVerified:h.payload.isVerified}}),this.logger=(0,O.Ep)(t,this.name),this.abortController=new AbortController,this.isDevEnv=(0,c.h9F)(),this.init()}get storeKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//verify:public:key"}get context(){return(0,O.Fd)(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),(0,b.toMiliseconds)(e))}}var ec=Object.defineProperty,tc=(r,e,t)=>e in r?ec(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Zs=(r,e,t)=>tc(r,typeof e!="symbol"?e+"":e,t);class sc extends wr{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,Zs(this,"context",sn),Zs(this,"registerDeviceToken",async s=>{const{clientId:i,token:o,notificationType:a,enableEncrypted:h=!1}=s,p=`${rn}/${this.projectId}/clients`;await fetch(p,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:i,type:a,token:o,always_raw:h})})}),this.logger=(0,O.Ep)(t,this.context)}}var ic=Object.defineProperty,Xs=Object.getOwnPropertySymbols,rc=Object.prototype.hasOwnProperty,nc=Object.prototype.propertyIsEnumerable,kt=(r,e,t)=>e in r?ic(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,rt=(r,e)=>{for(var t in e||(e={}))rc.call(e,t)&&kt(r,t,e[t]);if(Xs)for(var t of Xs(e))nc.call(e,t)&&kt(r,t,e[t]);return r},K=(r,e,t)=>kt(r,typeof e!="symbol"?e+"":e,t);class oc extends vr{constructor(e,t,s=!0){super(e,t,s),this.core=e,this.logger=t,K(this,"context",on),K(this,"storagePrefix",ue),K(this,"storageVersion",nn),K(this,"events",new Map),K(this,"shouldPersist",!1),K(this,"init",async()=>{if(!(0,c.h9F)())try{const i={eventId:(0,c.k$y)(),timestamp:Date.now(),domain:this.getAppDomain(),props:{event:"INIT",type:"",properties:{client_id:await this.core.crypto.getClientId(),user_agent:(0,c.oIp)(this.core.relayer.protocol,this.core.relayer.version,xt)}}};await this.sendEvent([i])}catch(i){this.logger.warn(i)}}),K(this,"createEvent",i=>{const{event:o="ERROR",type:a="",properties:{topic:h,trace:p}}=i,d=(0,c.k$y)(),u=this.core.projectId||"",g=Date.now(),w=rt({eventId:d,timestamp:g,props:{event:o,type:a,properties:{topic:h,trace:p}},bundleId:u,domain:this.getAppDomain()},this.setMethods(d));return this.telemetryEnabled&&(this.events.set(d,w),this.shouldPersist=!0),w}),K(this,"getEvent",i=>{const{eventId:o,topic:a}=i;if(o)return this.events.get(o);const h=Array.from(this.events.values()).find(p=>p.props.properties.topic===a);if(h)return rt(rt({},h),this.setMethods(h.eventId))}),K(this,"deleteEvent",i=>{const{eventId:o}=i;this.events.delete(o),this.shouldPersist=!0}),K(this,"setEventListeners",()=>{this.core.heartbeat.on(_e.Lx.pulse,async()=>{this.shouldPersist&&await this.persist(),this.events.forEach(i=>{(0,b.fromMiliseconds)(Date.now())-(0,b.fromMiliseconds)(i.timestamp)>an&&(this.events.delete(i.eventId),this.shouldPersist=!0)})})}),K(this,"setMethods",i=>({addTrace:o=>this.addTrace(i,o),setError:o=>this.setError(i,o)})),K(this,"addTrace",(i,o)=>{const a=this.events.get(i);a&&(a.props.properties.trace.push(o),this.events.set(i,a),this.shouldPersist=!0)}),K(this,"setError",(i,o)=>{const a=this.events.get(i);a&&(a.props.type=o,a.timestamp=Date.now(),this.events.set(i,a),this.shouldPersist=!0)}),K(this,"persist",async()=>{await this.core.storage.setItem(this.storageKey,Array.from(this.events.values())),this.shouldPersist=!1}),K(this,"restore",async()=>{try{const i=await this.core.storage.getItem(this.storageKey)||[];if(!i.length)return;i.forEach(o=>{this.events.set(o.eventId,rt(rt({},o),this.setMethods(o.eventId)))})}catch(i){this.logger.warn(i)}}),K(this,"submit",async()=>{if(!this.telemetryEnabled||this.events.size===0)return;const i=[];for(const[o,a]of this.events)a.props.type&&i.push(a);if(i.length!==0)try{if((await this.sendEvent(i)).ok)for(const o of i)this.events.delete(o.eventId),this.shouldPersist=!0}catch(o){this.logger.warn(o)}}),K(this,"sendEvent",async i=>{const o=this.getAppDomain()?"":"&sp=desktop";return await fetch(`${cn}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${xt}${o}`,{method:"POST",body:JSON.stringify(i)})}),K(this,"getAppDomain",()=>(0,c.DaH)().url),this.logger=(0,O.Ep)(t,this.context),this.telemetryEnabled=s,s?this.restore().then(async()=>{await this.submit(),this.setEventListeners()}):this.persist()}get storageKey(){return this.storagePrefix+this.storageVersion+this.core.customStoragePrefix+"//"+this.context}}var ac=Object.defineProperty,ei=Object.getOwnPropertySymbols,cc=Object.prototype.hasOwnProperty,hc=Object.prototype.propertyIsEnumerable,$t=(r,e,t)=>e in r?ac(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,ti=(r,e)=>{for(var t in e||(e={}))cc.call(e,t)&&$t(r,t,e[t]);if(ei)for(var t of ei(e))hc.call(e,t)&&$t(r,t,e[t]);return r},$=(r,e,t)=>$t(r,typeof e!="symbol"?e+"":e,t);class Mt extends ir{constructor(e){var t;super(e),$(this,"protocol",ys),$(this,"version",fs),$(this,"name",ht),$(this,"relayUrl"),$(this,"projectId"),$(this,"customStoragePrefix"),$(this,"events",new ve.EventEmitter),$(this,"logger"),$(this,"heartbeat"),$(this,"relayer"),$(this,"crypto"),$(this,"storage"),$(this,"history"),$(this,"expirer"),$(this,"pairing"),$(this,"verify"),$(this,"echoClient"),$(this,"linkModeSupportedApps"),$(this,"eventClient"),$(this,"initialized",!1),$(this,"logChunkController"),$(this,"on",(h,p)=>this.events.on(h,p)),$(this,"once",(h,p)=>this.events.once(h,p)),$(this,"off",(h,p)=>this.events.off(h,p)),$(this,"removeListener",(h,p)=>this.events.removeListener(h,p)),$(this,"dispatchEnvelope",({topic:h,message:p,sessionExists:d})=>{if(!h||!p)return;const u={topic:h,message:p,publishedAt:Date.now(),transportType:M.link_mode};this.relayer.onLinkMessageEvent(u,{sessionExists:d})});const s=this.getGlobalCore(e==null?void 0:e.customStoragePrefix);if(s)try{return this.customStoragePrefix=s.customStoragePrefix,this.logger=s.logger,this.heartbeat=s.heartbeat,this.crypto=s.crypto,this.history=s.history,this.expirer=s.expirer,this.storage=s.storage,this.relayer=s.relayer,this.pairing=s.pairing,this.verify=s.verify,this.echoClient=s.echoClient,this.linkModeSupportedApps=s.linkModeSupportedApps,this.eventClient=s.eventClient,this.initialized=s.initialized,this.logChunkController=s.logChunkController,s}catch(h){console.warn("Failed to copy global core",h)}this.projectId=e==null?void 0:e.projectId,this.relayUrl=(e==null?void 0:e.relayUrl)||bs,this.customStoragePrefix=e!=null&&e.customStoragePrefix?`:${e.customStoragePrefix}`:"";const i=(0,O.jI)({level:typeof(e==null?void 0:e.logger)=="string"&&e.logger?e.logger:Or.logger,name:ht}),{logger:o,chunkLoggerController:a}=(0,O.Rt)({opts:i,maxSizeInBytes:e==null?void 0:e.maxLogBlobSizeInBytes,loggerOverride:e==null?void 0:e.logger});this.logChunkController=a,(t=this.logChunkController)!=null&&t.downloadLogsBlobInBrowser&&(window.downloadLogsBlobInBrowser=async()=>{var h,p;(h=this.logChunkController)!=null&&h.downloadLogsBlobInBrowser&&((p=this.logChunkController)==null||p.downloadLogsBlobInBrowser({clientId:await this.crypto.getClientId()}))}),this.logger=(0,O.Ep)(o,this.name),this.heartbeat=new _e.C$,this.crypto=new ko(this,this.logger,e==null?void 0:e.keychain),this.history=new Ja(this,this.logger),this.expirer=new Wa(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new er(ti(ti({},Rr),e==null?void 0:e.storageOptions)),this.relayer=new la({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new Ka(this,this.logger),this.verify=new Xa(this,this.logger,this.storage),this.echoClient=new sc(this.projectId||"",this.logger),this.linkModeSupportedApps=[],this.eventClient=new oc(this,this.logger,e==null?void 0:e.telemetryEnabled),this.setGlobalCore(this)}static async init(e){const t=new Mt(e);await t.initialize();const s=await t.crypto.getClientId();return await t.storage.setItem(Ur,s),t}get context(){return(0,O.Fd)(this.logger)}async start(){this.initialized||await this.initialize()}async getLogsBlob(){var e;return(e=this.logChunkController)==null?void 0:e.logsToBlob({clientId:await this.crypto.getClientId()})}async addLinkModeSupportedApp(e){this.linkModeSupportedApps.includes(e)||(this.linkModeSupportedApps.push(e),await this.storage.setItem(_s,this.linkModeSupportedApps))}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.linkModeSupportedApps=await this.storage.getItem(_s)||[],this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}getGlobalCore(e=""){try{if(this.isGlobalCoreDisabled())return;const t=`_walletConnectCore_${e}`,s=`${t}_count`;return globalThis[s]=(globalThis[s]||0)+1,globalThis[s]>1&&console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[s]} times.`),globalThis[t]}catch(t){console.warn("Failed to get global WalletConnect core",t);return}}setGlobalCore(e){var t;try{if(this.isGlobalCoreDisabled())return;const s=`_walletConnectCore_${((t=e.opts)==null?void 0:t.customStoragePrefix)||""}`;globalThis[s]=e}catch(s){console.warn("Failed to set global WalletConnect core",s)}}isGlobalCoreDisabled(){try{return typeof Cr<"u"&&{NODE_ENV:"production",PUBLIC_PATH:"/"}.DISABLE_GLOBAL_CORE==="true"}catch{return!0}}}const lc=Mt,si="wc",ii=2,ri="client",Lt=`${si}@${ii}:${ri}:`,Ht={name:ri,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"},ep={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire",session_connect:"session_connect"},tp={database:":memory:"},ni="WALLETCONNECT_DEEPLINK_CHOICE",sp={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},ip="history",rp="0.3",pc="proposal",np=null,oi="Proposal expired",dc="session",ke=b.SEVEN_DAYS,uc="engine",G={wc_sessionPropose:{req:{ttl:b.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:b.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:b.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:b.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:b.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:b.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:b.ONE_DAY,prompt:!1,tag:1104},res:{ttl:b.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:b.ONE_DAY,prompt:!1,tag:1106},res:{ttl:b.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:b.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:b.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:b.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:b.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:b.ONE_DAY,prompt:!1,tag:1112},res:{ttl:b.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:b.ONE_DAY,prompt:!1,tag:1114},res:{ttl:b.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:b.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:b.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:b.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:b.FIVE_MINUTES,prompt:!1,tag:1119}}},zt={min:b.FIVE_MINUTES,max:b.SEVEN_DAYS},me={idle:"IDLE",active:"ACTIVE"},gc={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"},sui_signAndExecuteTransaction:{key:"digest"},sui_signTransaction:{key:""},hedera_signAndExecuteTransaction:{key:"transactionId"},hedera_executeTransaction:{key:"transactionId"},near_signTransaction:{key:""},near_signTransactions:{key:""},tron_signTransaction:{key:"txID"},xrpl_signTransaction:{key:""},xrpl_signTransactionFor:{key:""},algo_signTxn:{key:""},sendTransfer:{key:"txid"},stacks_stxTransfer:{key:"txId"},polkadot_signTransaction:{key:""},cosmos_signDirect:{key:""}},yc="request",mc=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],fc="wc",op=1.5,wc="auth",vc="authKeys",bc="pairingTopics",_c="requests",dt=`${fc}@${1.5}:${wc}:`,ut=`${dt}:PUB_KEY`;var Ic=Object.defineProperty,Pc=Object.defineProperties,Ec=Object.getOwnPropertyDescriptors,ai=Object.getOwnPropertySymbols,Sc=Object.prototype.hasOwnProperty,xc=Object.prototype.propertyIsEnumerable,Ut=(r,e,t)=>e in r?Ic(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,D=(r,e)=>{for(var t in e||(e={}))Sc.call(e,t)&&Ut(r,t,e[t]);if(ai)for(var t of ai(e))xc.call(e,t)&&Ut(r,t,e[t]);return r},W=(r,e)=>Pc(r,Ec(e)),y=(r,e,t)=>Ut(r,typeof e!="symbol"?e+"":e,t);class Cc extends Pr{constructor(e){super(e),y(this,"name",uc),y(this,"events",new(Pt())),y(this,"initialized",!1),y(this,"requestQueue",{state:me.idle,queue:[]}),y(this,"sessionRequestQueue",{state:me.idle,queue:[]}),y(this,"emittedSessionRequests",new c._xQ({limit:500})),y(this,"requestQueueDelay",b.ONE_SECOND),y(this,"expectedPairingMethodMap",new Map),y(this,"recentlyDeletedMap",new Map),y(this,"recentlyDeletedLimit",200),y(this,"relayMessageCache",[]),y(this,"pendingSessions",new Map),y(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(G)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},(0,b.toMiliseconds)(this.requestQueueDelay)))}),y(this,"connect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const s=W(D({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(s),s.optionalNamespaces=(0,c.wrP)(s.requiredNamespaces,s.optionalNamespaces),s.requiredNamespaces={};const{pairingTopic:i,requiredNamespaces:o,optionalNamespaces:a,sessionProperties:h,scopedProperties:p,relays:d}=s;let u=i,g,w=!1;try{if(u){const S=this.client.core.pairing.pairings.get(u);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),w=S.active}}catch(S){throw this.client.logger.error(`connect() -> pairing.get(${u}) failed`),S}if(!u||!w){const{topic:S,uri:j}=await this.client.core.pairing.create({internal:{skipSubscribe:!0}});u=S,g=j}if(!u){const{message:S}=(0,c.kCb)("NO_MATCHING_KEY",`connect() pairing topic: ${u}`);throw new Error(S)}const m=await this.client.core.crypto.generateKeyPair(),f=G.wc_sessionPropose.req.ttl||b.FIVE_MINUTES,v=(0,c.gn4)(f),_=W(D(D({requiredNamespaces:o,optionalNamespaces:a,relays:d??[{protocol:vs}],proposer:{publicKey:m,metadata:this.client.metadata},expiryTimestamp:v,pairingTopic:u},h&&{sessionProperties:h}),p&&{scopedProperties:p}),{id:(0,P.payloadId)()}),E=(0,c.E0T)("session_connect",_.id),{reject:I,resolve:F,done:C}=(0,c.H1S)(f,oi),x=({id:S})=>{S===_.id&&(this.client.events.off("proposal_expire",x),this.pendingSessions.delete(_.id),this.events.emit(E,{error:{message:oi,code:0}}))};return this.client.events.on("proposal_expire",x),this.events.once(E,({error:S,session:j})=>{this.client.events.off("proposal_expire",x),S?I(S):j&&F(j)}),await this.sendProposeSession({proposal:_,publishOpts:{internal:{throwOnFailedPublish:!0},tvf:{correlationId:_.id}}}),await this.setProposal(_.id,_),{uri:g,approval:C}}),y(this,"pair",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(t)}catch(s){throw this.client.logger.error("pair() failed"),s}}),y(this,"approve",async t=>{var s,i,o;const a=this.client.core.eventClient.createEvent({properties:{topic:(s=t==null?void 0:t.id)==null?void 0:s.toString(),trace:[be.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(L){throw a.setError(Ze.no_internet_connection),L}try{await this.isValidProposalId(t==null?void 0:t.id)}catch(L){throw this.client.logger.error(`approve() -> proposal.get(${t==null?void 0:t.id}) failed`),a.setError(Ze.proposal_not_found),L}try{await this.isValidApprove(t)}catch(L){throw this.client.logger.error("approve() -> isValidApprove() failed"),a.setError(Ze.session_approve_namespace_validation_failure),L}const{id:h,relayProtocol:p,namespaces:d,sessionProperties:u,scopedProperties:g,sessionConfig:w}=t,m=this.client.proposal.get(h);this.client.core.eventClient.deleteEvent({eventId:a.eventId});const{pairingTopic:f,proposer:v,requiredNamespaces:_,optionalNamespaces:E}=m;let I=(i=this.client.core.eventClient)==null?void 0:i.getEvent({topic:f});I||(I=(o=this.client.core.eventClient)==null?void 0:o.createEvent({type:be.session_approve_started,properties:{topic:f,trace:[be.session_approve_started,be.session_namespaces_validation_success]}}));const F=await this.client.core.crypto.generateKeyPair(),C=v.publicKey,x=await this.client.core.crypto.generateSharedKey(F,C),S=D(D(D({relay:{protocol:p??"irn"},namespaces:d,controller:{publicKey:F,metadata:this.client.metadata},expiry:(0,c.gn4)(ke)},u&&{sessionProperties:u}),g&&{scopedProperties:g}),w&&{sessionConfig:w}),j=M.relay;I.addTrace(be.subscribing_session_topic);try{await this.client.core.relayer.subscribe(x,{transportType:j,internal:{skipSubscribe:!0}})}catch(L){throw I.setError(Ze.subscribe_session_topic_failure),L}I.addTrace(be.subscribe_session_topic_success);const H=W(D({},S),{topic:x,requiredNamespaces:_,optionalNamespaces:E,pairingTopic:f,acknowledged:!1,self:S.controller,peer:{publicKey:v.publicKey,metadata:v.metadata},controller:F,transportType:M.relay});await this.client.session.set(x,H),I.addTrace(be.store_session);try{await this.sendApproveSession({sessionTopic:x,proposal:m,pairingProposalResponse:{relay:{protocol:p??"irn"},responderPublicKey:F},sessionSettleRequest:S,publishOpts:{internal:{throwOnFailedPublish:!0},tvf:{correlationId:h}}}),I.addTrace(be.session_approve_publish_success)}catch(L){throw this.client.logger.error(L),this.client.session.delete(x,(0,c.D6H)("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(x),L}return this.client.core.eventClient.deleteEvent({eventId:I.eventId}),await this.client.core.pairing.updateMetadata({topic:f,metadata:v.metadata}),await this.deleteProposal(h),await this.client.core.pairing.activate({topic:f}),await this.setExpiry(x,(0,c.gn4)(ke)),{topic:x,acknowledged:()=>Promise.resolve(this.client.session.get(x))}}),y(this,"reject",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(t)}catch(a){throw this.client.logger.error("reject() -> isValidReject() failed"),a}const{id:s,reason:i}=t;let o;try{o=this.client.proposal.get(s).pairingTopic}catch(a){throw this.client.logger.error(`reject() -> proposal.get(${s}) failed`),a}o&&await this.sendError({id:s,topic:o,error:i,rpcOpts:G.wc_sessionPropose.reject}),await this.deleteProposal(s)}),y(this,"update",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(t)}catch(g){throw this.client.logger.error("update() -> isValidUpdate() failed"),g}const{topic:s,namespaces:i}=t,{done:o,resolve:a,reject:h}=(0,c.H1S)(),p=(0,P.payloadId)(),d=(0,P.getBigIntRpcId)().toString(),u=this.client.session.get(s).namespaces;return this.events.once((0,c.E0T)("session_update",p),({error:g})=>{g?h(g):a()}),await this.client.session.update(s,{namespaces:i}),await this.sendRequest({topic:s,method:"wc_sessionUpdate",params:{namespaces:i},throwOnFailedPublish:!0,clientRpcId:p,relayRpcId:d}).catch(g=>{this.client.logger.error(g),this.client.session.update(s,{namespaces:u}),h(g)}),{acknowledged:o}}),y(this,"extend",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(t)}catch(p){throw this.client.logger.error("extend() -> isValidExtend() failed"),p}const{topic:s}=t,i=(0,P.payloadId)(),{done:o,resolve:a,reject:h}=(0,c.H1S)();return this.events.once((0,c.E0T)("session_extend",i),({error:p})=>{p?h(p):a()}),await this.setExpiry(s,(0,c.gn4)(ke)),this.sendRequest({topic:s,method:"wc_sessionExtend",params:{},clientRpcId:i,throwOnFailedPublish:!0}).catch(p=>{h(p)}),{acknowledged:o}}),y(this,"request",async t=>{this.isInitialized();try{await this.isValidRequest(t)}catch(_){throw this.client.logger.error("request() -> isValidRequest() failed"),_}const{chainId:s,request:i,topic:o,expiry:a=G.wc_sessionRequest.req.ttl}=t,h=this.client.session.get(o);(h==null?void 0:h.transportType)===M.relay&&await this.confirmOnlineStateOrThrow();const p=(0,P.payloadId)(),d=(0,P.getBigIntRpcId)().toString(),{done:u,resolve:g,reject:w}=(0,c.H1S)(a,"Request expired. Please try again.");this.events.once((0,c.E0T)("session_request",p),({error:_,result:E})=>{_?w(_):g(E)});const m="wc_sessionRequest",f=this.getAppLinkIfEnabled(h.peer.metadata,h.transportType);if(f)return await this.sendRequest({clientRpcId:p,relayRpcId:d,topic:o,method:m,params:{request:W(D({},i),{expiryTimestamp:(0,c.gn4)(a)}),chainId:s},expiry:a,throwOnFailedPublish:!0,appLink:f}).catch(_=>w(_)),this.client.events.emit("session_request_sent",{topic:o,request:i,chainId:s,id:p}),await u();const v={request:W(D({},i),{expiryTimestamp:(0,c.gn4)(a)}),chainId:s};return await Promise.all([new Promise(async _=>{await this.sendRequest({clientRpcId:p,relayRpcId:d,topic:o,method:m,params:v,expiry:a,throwOnFailedPublish:!0,tvf:this.getTVFParams(p,v)}).catch(E=>w(E)),this.client.events.emit("session_request_sent",{topic:o,request:i,chainId:s,id:p}),_()}),new Promise(async _=>{var E;if(!((E=h.sessionConfig)!=null&&E.disableDeepLink)){const I=await(0,c.bW6)(this.client.core.storage,ni);await(0,c.HhN)({id:p,topic:o,wcDeepLink:I})}_()}),u()]).then(_=>_[2])}),y(this,"respond",async t=>{this.isInitialized(),await this.isValidRespond(t);const{topic:s,response:i}=t,{id:o}=i,a=this.client.session.get(s);a.transportType===M.relay&&await this.confirmOnlineStateOrThrow();const h=this.getAppLinkIfEnabled(a.peer.metadata,a.transportType);(0,P.isJsonRpcResult)(i)?await this.sendResult({id:o,topic:s,result:i.result,throwOnFailedPublish:!0,appLink:h}):(0,P.isJsonRpcError)(i)&&await this.sendError({id:o,topic:s,error:i.error,appLink:h}),this.cleanupAfterResponse(t)}),y(this,"ping",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(t)}catch(i){throw this.client.logger.error("ping() -> isValidPing() failed"),i}const{topic:s}=t;if(this.client.session.keys.includes(s)){const i=(0,P.payloadId)(),o=(0,P.getBigIntRpcId)().toString(),{done:a,resolve:h,reject:p}=(0,c.H1S)();this.events.once((0,c.E0T)("session_ping",i),({error:d})=>{d?p(d):h()}),await Promise.all([this.sendRequest({topic:s,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:i,relayRpcId:o}),a()])}else this.client.core.pairing.pairings.keys.includes(s)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:s}))}),y(this,"emit",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(t);const{topic:s,event:i,chainId:o}=t,a=(0,P.getBigIntRpcId)().toString(),h=(0,P.payloadId)();await this.sendRequest({topic:s,method:"wc_sessionEvent",params:{event:i,chainId:o},throwOnFailedPublish:!0,relayRpcId:a,clientRpcId:h})}),y(this,"disconnect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(t);const{topic:s}=t;if(this.client.session.keys.includes(s))await this.sendRequest({topic:s,method:"wc_sessionDelete",params:(0,c.D6H)("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:s,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(s))await this.client.core.pairing.disconnect({topic:s});else{const{message:i}=(0,c.kCb)("MISMATCHED_TOPIC",`Session or pairing topic not found: ${s}`);throw new Error(i)}}),y(this,"find",t=>(this.isInitialized(),this.client.session.getAll().filter(s=>(0,c.Ih8)(s,t)))),y(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),y(this,"authenticate",async(t,s)=>{var i;this.isInitialized(),this.isValidAuthenticate(t);const o=s&&this.client.core.linkModeSupportedApps.includes(s)&&((i=this.client.metadata.redirect)==null?void 0:i.linkMode),a=o?M.link_mode:M.relay;a===M.relay&&await this.confirmOnlineStateOrThrow();const{chains:h,statement:p="",uri:d,domain:u,nonce:g,type:w,exp:m,nbf:f,methods:v=[],expiry:_}=t,E=[...t.resources||[]],{topic:I,uri:F}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:a});this.client.logger.info({message:"Generated new pairing",pairing:{topic:I,uri:F}});const C=await this.client.core.crypto.generateKeyPair(),x=(0,c.YmJ)(C);if(await Promise.all([this.client.auth.authKeys.set(ut,{responseTopic:x,publicKey:C}),this.client.auth.pairingTopics.set(x,{topic:x,pairingTopic:I})]),await this.client.core.relayer.subscribe(x,{transportType:a}),this.client.logger.info(`sending request to new pairing topic: ${I}`),v.length>0){const{namespace:Z}=(0,c.DQe)(h[0]);let de=(0,c.IkP)(Z,"request",v);(0,c.hA9)(E)&&(de=(0,c.qJM)(de,E.pop())),E.push(de)}const S=_&&_>G.wc_sessionAuthenticate.req.ttl?_:G.wc_sessionAuthenticate.req.ttl,j={authPayload:{type:w??"caip122",chains:h,statement:p,aud:d,domain:u,version:"1",nonce:g,iat:new Date().toISOString(),exp:m,nbf:f,resources:E},requester:{publicKey:C,metadata:this.client.metadata},expiryTimestamp:(0,c.gn4)(S)},H={eip155:{chains:h,methods:[...new Set(["personal_sign",...v])],events:["chainChanged","accountsChanged"]}},L={requiredNamespaces:{},optionalNamespaces:H,relays:[{protocol:"irn"}],pairingTopic:I,proposer:{publicKey:C,metadata:this.client.metadata},expiryTimestamp:(0,c.gn4)(G.wc_sessionPropose.req.ttl),id:(0,P.payloadId)()},{done:pe,resolve:Ae,reject:we}=(0,c.H1S)(S,"Request expired"),nt=(0,P.payloadId)(),bt=(0,c.E0T)("session_connect",L.id),ns=(0,c.E0T)("session_request",nt),_t=async({error:Z,session:de})=>{this.events.off(ns,os),Z?we(Z):de&&Ae({session:de})},os=async Z=>{var de,$i,Mi;if(await this.deletePendingAuthRequest(nt,{message:"fulfilled",code:0}),Z.error){const at=(0,c.D6H)("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return Z.error.code===at.code?void 0:(this.events.off(bt,_t),we(Z.error.message))}await this.deleteProposal(L.id),this.events.off(bt,_t);const{cacaos:Li,responder:qe}=Z.result,as=[],Hi=[];for(const at of Li){await(0,c.c4l)({cacao:at,projectId:this.client.core.projectId})||(this.client.logger.error(at,"Signature verification failed"),we((0,c.D6H)("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:cs}=at,hs=(0,c.hA9)(cs.resources),zi=[(0,c.DJo)(cs.iss)],Dl=(0,c.NmC)(cs.iss);if(hs){const ls=(0,c.Y31)(hs),jl=(0,c.ouN)(hs);as.push(...ls),zi.push(...jl)}for(const ls of zi)Hi.push(`${ls}:${Dl}`)}const ot=await this.client.core.crypto.generateSharedKey(C,qe.publicKey);let It;as.length>0&&(It={topic:ot,acknowledged:!0,self:{publicKey:C,metadata:this.client.metadata},peer:qe,controller:qe.publicKey,expiry:(0,c.gn4)(ke),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:I,namespaces:(0,c.E12)([...new Set(as)],[...new Set(Hi)]),transportType:a},await this.client.core.relayer.subscribe(ot,{transportType:a}),await this.client.session.set(ot,It),I&&await this.client.core.pairing.updateMetadata({topic:I,metadata:qe.metadata}),It=this.client.session.get(ot)),(de=this.client.metadata.redirect)!=null&&de.linkMode&&($i=qe.metadata.redirect)!=null&&$i.linkMode&&(Mi=qe.metadata.redirect)!=null&&Mi.universal&&s&&(this.client.core.addLinkModeSupportedApp(qe.metadata.redirect.universal),this.client.session.update(ot,{transportType:M.link_mode})),Ae({auths:Li,session:It})};this.events.once(bt,_t),this.events.once(ns,os);let ki;try{if(o){const Z=(0,P.formatJsonRpcRequest)("wc_sessionAuthenticate",j,nt);this.client.core.history.set(I,Z);const de=await this.client.core.crypto.encode("",Z,{type:c.FpL,encoding:c.zl_});ki=(0,c.L9d)(s,I,de)}else await Promise.all([this.sendRequest({topic:I,method:"wc_sessionAuthenticate",params:j,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:nt}),this.sendRequest({topic:I,method:"wc_sessionPropose",params:L,expiry:G.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:L.id})])}catch(Z){throw this.events.off(bt,_t),this.events.off(ns,os),Z}return await this.setProposal(L.id,L),await this.setAuthRequest(nt,{request:W(D({},j),{verifyContext:{}}),pairingTopic:I,transportType:a}),{uri:ki??F,response:pe}}),y(this,"approveSessionAuthenticate",async t=>{const{id:s,auths:i}=t,o=this.client.core.eventClient.createEvent({properties:{topic:s.toString(),trace:[Se.authenticated_session_approve_started]}});try{this.isInitialized()}catch(_){throw o.setError(Xe.no_internet_connection),_}const a=this.getPendingAuthRequest(s);if(!a)throw o.setError(Xe.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${s}`);const h=a.transportType||M.relay;h===M.relay&&await this.confirmOnlineStateOrThrow();const p=a.requester.publicKey,d=await this.client.core.crypto.generateKeyPair(),u=(0,c.YmJ)(p),g={type:c.rVF,receiverPublicKey:p,senderPublicKey:d},w=[],m=[];for(const _ of i){if(!await(0,c.c4l)({cacao:_,projectId:this.client.core.projectId})){o.setError(Xe.invalid_cacao);const x=(0,c.D6H)("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:s,topic:u,error:x,encodeOpts:g}),new Error(x.message)}o.addTrace(Se.cacaos_verified);const{p:E}=_,I=(0,c.hA9)(E.resources),F=[(0,c.DJo)(E.iss)],C=(0,c.NmC)(E.iss);if(I){const x=(0,c.Y31)(I),S=(0,c.ouN)(I);w.push(...x),F.push(...S)}for(const x of F)m.push(`${x}:${C}`)}const f=await this.client.core.crypto.generateSharedKey(d,p);o.addTrace(Se.create_authenticated_session_topic);let v;if((w==null?void 0:w.length)>0){v={topic:f,acknowledged:!0,self:{publicKey:d,metadata:this.client.metadata},peer:{publicKey:p,metadata:a.requester.metadata},controller:p,expiry:(0,c.gn4)(ke),authentication:i,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:a.pairingTopic,namespaces:(0,c.E12)([...new Set(w)],[...new Set(m)]),transportType:h},o.addTrace(Se.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(f,{transportType:h})}catch(_){throw o.setError(Xe.subscribe_authenticated_session_topic_failure),_}o.addTrace(Se.subscribe_authenticated_session_topic_success),await this.client.session.set(f,v),o.addTrace(Se.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:a.pairingTopic,metadata:a.requester.metadata})}o.addTrace(Se.publishing_authenticated_session_approve);try{await this.sendResult({topic:u,id:s,result:{cacaos:i,responder:{publicKey:d,metadata:this.client.metadata}},encodeOpts:g,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(a.requester.metadata,h)})}catch(_){throw o.setError(Xe.authenticated_session_approve_publish_failure),_}return await this.client.auth.requests.delete(s,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:a.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:o.eventId}),{session:v}}),y(this,"rejectSessionAuthenticate",async t=>{this.isInitialized();const{id:s,reason:i}=t,o=this.getPendingAuthRequest(s);if(!o)throw new Error(`Could not find pending auth request with id ${s}`);o.transportType===M.relay&&await this.confirmOnlineStateOrThrow();const a=o.requester.publicKey,h=await this.client.core.crypto.generateKeyPair(),p=(0,c.YmJ)(a),d={type:c.rVF,receiverPublicKey:a,senderPublicKey:h};await this.sendError({id:s,topic:p,error:i,encodeOpts:d,rpcOpts:G.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(o.requester.metadata,o.transportType)}),await this.client.auth.requests.delete(s,{message:"rejected",code:0}),await this.deleteProposal(s)}),y(this,"formatAuthMessage",t=>{this.isInitialized();const{request:s,iss:i}=t;return(0,c.wvx)(s,i)}),y(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)}),y(this,"cleanupDuplicatePairings",async t=>{if(t.pairingTopic)try{const s=this.client.core.pairing.pairings.get(t.pairingTopic),i=this.client.core.pairing.pairings.getAll().filter(o=>{var a,h;return((a=o.peerMetadata)==null?void 0:a.url)&&((h=o.peerMetadata)==null?void 0:h.url)===t.peer.metadata.url&&o.topic&&o.topic!==s.topic});if(i.length===0)return;this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`),await Promise.all(i.map(o=>this.client.core.pairing.disconnect({topic:o.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(s){this.client.logger.error(s)}}),y(this,"deleteSession",async t=>{var s;const{topic:i,expirerHasDeleted:o=!1,emitEvent:a=!0,id:h=0}=t,{self:p}=this.client.session.get(i);await this.client.core.relayer.unsubscribe(i),await this.client.session.delete(i,(0,c.D6H)("USER_DISCONNECTED")),this.addToRecentlyDeleted(i,"session"),this.client.core.crypto.keychain.has(p.publicKey)&&await this.client.core.crypto.deleteKeyPair(p.publicKey),this.client.core.crypto.keychain.has(i)&&await this.client.core.crypto.deleteSymKey(i),o||this.client.core.expirer.del(i),this.client.core.storage.removeItem(ni).catch(d=>this.client.logger.warn(d)),this.getPendingSessionRequests().forEach(d=>{d.topic===i&&this.deletePendingSessionRequest(d.id,(0,c.D6H)("USER_DISCONNECTED"))}),i===((s=this.sessionRequestQueue.queue[0])==null?void 0:s.topic)&&(this.sessionRequestQueue.state=me.idle),a&&this.client.events.emit("session_delete",{id:h,topic:i})}),y(this,"deleteProposal",async(t,s)=>{if(s)try{const i=this.client.proposal.get(t),o=this.client.core.eventClient.getEvent({topic:i.pairingTopic});o==null||o.setError(Ze.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,(0,c.D6H)("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")}),y(this,"deletePendingSessionRequest",async(t,s,i=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,s),i?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(o=>o.id!==t),i&&(this.sessionRequestQueue.state=me.idle,this.client.events.emit("session_request_expire",{id:t}))}),y(this,"deletePendingAuthRequest",async(t,s,i=!1)=>{await Promise.all([this.client.auth.requests.delete(t,s),i?Promise.resolve():this.client.core.expirer.del(t)])}),y(this,"setExpiry",async(t,s)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,s),await this.client.session.update(t,{expiry:s}))}),y(this,"setProposal",async(t,s)=>{this.client.core.expirer.set(t,(0,c.gn4)(G.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,s)}),y(this,"setAuthRequest",async(t,s)=>{const{request:i,pairingTopic:o,transportType:a=M.relay}=s;this.client.core.expirer.set(t,i.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:i.authPayload,requester:i.requester,expiryTimestamp:i.expiryTimestamp,id:t,pairingTopic:o,verifyContext:i.verifyContext,transportType:a})}),y(this,"setPendingSessionRequest",async t=>{const{id:s,topic:i,params:o,verifyContext:a}=t,h=o.request.expiryTimestamp||(0,c.gn4)(G.wc_sessionRequest.req.ttl);this.client.core.expirer.set(s,h),await this.client.pendingRequest.set(s,{id:s,topic:i,params:o,verifyContext:a})}),y(this,"sendRequest",async t=>{const{topic:s,method:i,params:o,expiry:a,relayRpcId:h,clientRpcId:p,throwOnFailedPublish:d,appLink:u,tvf:g,publishOpts:w={}}=t,m=(0,P.formatJsonRpcRequest)(i,o,p);let f;const v=!!u;try{const I=v?c.zl_:c.$dT;f=await this.client.core.crypto.encode(s,m,{encoding:I})}catch(I){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${s} failed`),I}let _;if(mc.includes(i)){const I=(0,c.rjm)(JSON.stringify(m)),F=(0,c.rjm)(f);_=await this.client.core.verify.register({id:F,decryptedId:I})}const E=D(D({},G[i].req),w);if(E.attestation=_,a&&(E.ttl=a),h&&(E.id=h),this.client.core.history.set(s,m),v){const I=(0,c.L9d)(u,s,f);await R.g.Linking.openURL(I,this.client.name)}else E.tvf=W(D({},g),{correlationId:m.id}),d?(E.internal=W(D({},E.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,f,E)):this.client.core.relayer.publish(s,f,E).catch(I=>this.client.logger.error(I));return m.id}),y(this,"sendProposeSession",async t=>{const{proposal:s,publishOpts:i}=t,o=(0,P.formatJsonRpcRequest)("wc_sessionPropose",s,s.id);this.client.core.history.set(s.pairingTopic,o);const a=await this.client.core.crypto.encode(s.pairingTopic,o,{encoding:c.$dT}),h=(0,c.rjm)(JSON.stringify(o)),p=(0,c.rjm)(a),d=await this.client.core.verify.register({id:p,decryptedId:h});await this.client.core.relayer.publishCustom({payload:{pairingTopic:s.pairingTopic,sessionProposal:a},opts:W(D({},i),{publishMethod:"wc_proposeSession",attestation:d})})}),y(this,"sendApproveSession",async t=>{const{sessionTopic:s,pairingProposalResponse:i,proposal:o,sessionSettleRequest:a,publishOpts:h}=t,p=(0,P.formatJsonRpcResult)(o.id,i),d=await this.client.core.crypto.encode(o.pairingTopic,p,{encoding:c.$dT}),u=(0,P.formatJsonRpcRequest)("wc_sessionSettle",a,h==null?void 0:h.id),g=await this.client.core.crypto.encode(s,u,{encoding:c.$dT});this.client.core.history.set(s,u),await this.client.core.relayer.publishCustom({payload:{sessionTopic:s,pairingTopic:o.pairingTopic,sessionProposalResponse:d,sessionSettlementRequest:g},opts:W(D({},h),{publishMethod:"wc_approveSession"})})}),y(this,"sendResult",async t=>{const{id:s,topic:i,result:o,throwOnFailedPublish:a,encodeOpts:h,appLink:p}=t,d=(0,P.formatJsonRpcResult)(s,o);let u;const g=p&&typeof(R.g==null?void 0:R.g.Linking)<"u";try{const f=g?c.zl_:c.$dT;u=await this.client.core.crypto.encode(i,d,W(D({},h||{}),{encoding:f}))}catch(f){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`),f}let w,m;try{w=await this.client.core.history.get(i,s);const f=w.request;try{m=this.getTVFParams(s,f.params,o)}catch(v){this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${v==null?void 0:v.message}`)}}catch(f){throw this.client.logger.error(`sendResult() -> history.get(${i}, ${s}) failed`),f}if(g){const f=(0,c.L9d)(p,i,u);await R.g.Linking.openURL(f,this.client.name)}else{const f=w.request.method,v=G[f].res;v.tvf=W(D({},m),{correlationId:s}),a?(v.internal=W(D({},v.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(i,u,v)):this.client.core.relayer.publish(i,u,v).catch(_=>this.client.logger.error(_))}await this.client.core.history.resolve(d)}),y(this,"sendError",async t=>{const{id:s,topic:i,error:o,encodeOpts:a,rpcOpts:h,appLink:p}=t,d=(0,P.formatJsonRpcError)(s,o);let u;const g=p&&typeof(R.g==null?void 0:R.g.Linking)<"u";try{const m=g?c.zl_:c.$dT;u=await this.client.core.crypto.encode(i,d,W(D({},a||{}),{encoding:m}))}catch(m){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`),m}let w;try{w=await this.client.core.history.get(i,s)}catch(m){throw this.client.logger.error(`sendError() -> history.get(${i}, ${s}) failed`),m}if(g){const m=(0,c.L9d)(p,i,u);await R.g.Linking.openURL(m,this.client.name)}else{const m=w.request.method,f=h||G[m].res;this.client.core.relayer.publish(i,u,f)}await this.client.core.history.resolve(d)}),y(this,"cleanup",async()=>{const t=[],s=[];this.client.session.getAll().forEach(i=>{let o=!1;(0,c.BwD)(i.expiry)&&(o=!0),this.client.core.crypto.keychain.has(i.topic)||(o=!0),o&&t.push(i.topic)}),this.client.proposal.getAll().forEach(i=>{(0,c.BwD)(i.expiryTimestamp)&&s.push(i.id)}),await Promise.all([...t.map(i=>this.deleteSession({topic:i})),...s.map(i=>this.deleteProposal(i))])}),y(this,"onProviderMessageEvent",async t=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(t):await this.onRelayMessage(t)}),y(this,"onRelayEventRequest",async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()}),y(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===me.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=me.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(s){this.client.logger.warn(s)}}this.requestQueue.state=me.idle}),y(this,"processRequest",async t=>{const{topic:s,payload:i,attestation:o,transportType:a,encryptedId:h}=t,p=i.method;if(!this.shouldIgnorePairingRequest({topic:s,requestMethod:p}))switch(p){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:s,payload:i,attestation:o,encryptedId:h});case"wc_sessionSettle":return await this.onSessionSettleRequest(s,i);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(s,i);case"wc_sessionExtend":return await this.onSessionExtendRequest(s,i);case"wc_sessionPing":return await this.onSessionPingRequest(s,i);case"wc_sessionDelete":return await this.onSessionDeleteRequest(s,i);case"wc_sessionRequest":return await this.onSessionRequest({topic:s,payload:i,attestation:o,encryptedId:h,transportType:a});case"wc_sessionEvent":return await this.onSessionEventRequest(s,i);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:s,payload:i,attestation:o,encryptedId:h,transportType:a});default:return this.client.logger.info(`Unsupported request method ${p}`)}}),y(this,"onRelayEventResponse",async t=>{const{topic:s,payload:i,transportType:o}=t,a=(await this.client.core.history.get(s,i.id)).request.method;switch(a){case"wc_sessionPropose":return this.onSessionProposeResponse(s,i,o);case"wc_sessionSettle":return this.onSessionSettleResponse(s,i);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,i);case"wc_sessionExtend":return this.onSessionExtendResponse(s,i);case"wc_sessionPing":return this.onSessionPingResponse(s,i);case"wc_sessionRequest":return this.onSessionRequestResponse(s,i);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(s,i);default:return this.client.logger.info(`Unsupported response method ${a}`)}}),y(this,"onRelayEventUnknownPayload",t=>{const{topic:s}=t,{message:i}=(0,c.kCb)("MISSING_OR_INVALID",`Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);throw new Error(i)}),y(this,"shouldIgnorePairingRequest",t=>{const{topic:s,requestMethod:i}=t,o=this.expectedPairingMethodMap.get(s);return!o||o.includes(i)?!1:!!(o.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),y(this,"onSessionProposeRequest",async t=>{const{topic:s,payload:i,attestation:o,encryptedId:a}=t,{params:h,id:p}=i;try{const d=this.client.core.eventClient.getEvent({topic:s});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),d==null||d.setError(fe.proposal_listener_not_found)),this.isValidConnect(D({},i.params));const u=h.expiryTimestamp||(0,c.gn4)(G.wc_sessionPropose.req.ttl),g=D({id:p,pairingTopic:s,expiryTimestamp:u,attestation:o,encryptedId:a},h);await this.setProposal(p,g);const w=await this.getVerifyContext({attestationId:o,hash:(0,c.rjm)(JSON.stringify(i)),encryptedId:a,metadata:g.proposer.metadata});d==null||d.addTrace(ge.emit_session_proposal),this.client.events.emit("session_proposal",{id:p,params:g,verifyContext:w})}catch(d){await this.sendError({id:p,topic:s,error:d,rpcOpts:G.wc_sessionPropose.autoReject}),this.client.logger.error(d)}}),y(this,"onSessionProposeResponse",async(t,s,i)=>{const{id:o}=s;if((0,P.isJsonRpcResult)(s)){const{result:a}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:a});const h=this.client.proposal.get(o);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:h});const p=h.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:p});const d=a.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:d});const u=await this.client.core.crypto.generateSharedKey(p,d);this.pendingSessions.set(o,{sessionTopic:u,pairingTopic:t,proposalId:o,publicKey:p});const g=await this.client.core.relayer.subscribe(u,{transportType:i});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:g}),await this.client.core.pairing.activate({topic:t})}else if((0,P.isJsonRpcError)(s)){await this.deleteProposal(o);const a=(0,c.E0T)("session_connect",o);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners, 954`);this.events.emit(a,{error:s.error})}}),y(this,"onSessionSettleRequest",async(t,s)=>{const{id:i,params:o}=s;try{this.isValidSessionSettleRequest(o);const{relay:a,controller:h,expiry:p,namespaces:d,sessionProperties:u,scopedProperties:g,sessionConfig:w}=s.params,m=[...this.pendingSessions.values()].find(_=>_.sessionTopic===t);if(!m)return this.client.logger.error(`Pending session not found for topic ${t}`);const f=this.client.proposal.get(m.proposalId),v=W(D(D(D({topic:t,relay:a,expiry:p,namespaces:d,acknowledged:!0,pairingTopic:m.pairingTopic,requiredNamespaces:f.requiredNamespaces,optionalNamespaces:f.optionalNamespaces,controller:h.publicKey,self:{publicKey:m.publicKey,metadata:this.client.metadata},peer:{publicKey:h.publicKey,metadata:h.metadata}},u&&{sessionProperties:u}),g&&{scopedProperties:g}),w&&{sessionConfig:w}),{transportType:M.relay});await this.client.session.set(v.topic,v),await this.setExpiry(v.topic,v.expiry),await this.client.core.pairing.updateMetadata({topic:m.pairingTopic,metadata:v.peer.metadata}),this.client.events.emit("session_connect",{session:v}),this.events.emit((0,c.E0T)("session_connect",m.proposalId),{session:v}),this.pendingSessions.delete(m.proposalId),this.deleteProposal(m.proposalId,!1),this.cleanupDuplicatePairings(v),await this.sendResult({id:s.id,topic:t,result:!0})}catch(a){await this.sendError({id:i,topic:t,error:a}),this.client.logger.error(a)}}),y(this,"onSessionSettleResponse",async(t,s)=>{const{id:i}=s;(0,P.isJsonRpcResult)(s)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit((0,c.E0T)("session_approve",i),{})):(0,P.isJsonRpcError)(s)&&(await this.client.session.delete(t,(0,c.D6H)("USER_DISCONNECTED")),this.events.emit((0,c.E0T)("session_approve",i),{error:s.error}))}),y(this,"onSessionUpdateRequest",async(t,s)=>{const{params:i,id:o}=s;try{const a=`${t}_session_update`,h=c.O6B.get(a);if(h&&this.isRequestOutOfSync(h,o)){this.client.logger.warn(`Discarding out of sync request - ${o}`),this.sendError({id:o,topic:t,error:(0,c.D6H)("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(D({topic:t},i));try{c.O6B.set(a,o),await this.client.session.update(t,{namespaces:i.namespaces}),await this.sendResult({id:o,topic:t,result:!0})}catch(p){throw c.O6B.delete(a),p}this.client.events.emit("session_update",{id:o,topic:t,params:i})}catch(a){await this.sendError({id:o,topic:t,error:a}),this.client.logger.error(a)}}),y(this,"isRequestOutOfSync",(t,s)=>s.toString().slice(0,-3)<t.toString().slice(0,-3)),y(this,"onSessionUpdateResponse",(t,s)=>{const{id:i}=s,o=(0,c.E0T)("session_update",i);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);(0,P.isJsonRpcResult)(s)?this.events.emit((0,c.E0T)("session_update",i),{}):(0,P.isJsonRpcError)(s)&&this.events.emit((0,c.E0T)("session_update",i),{error:s.error})}),y(this,"onSessionExtendRequest",async(t,s)=>{const{id:i}=s;try{this.isValidExtend({topic:t}),await this.setExpiry(t,(0,c.gn4)(ke)),await this.sendResult({id:i,topic:t,result:!0}),this.client.events.emit("session_extend",{id:i,topic:t})}catch(o){await this.sendError({id:i,topic:t,error:o}),this.client.logger.error(o)}}),y(this,"onSessionExtendResponse",(t,s)=>{const{id:i}=s,o=(0,c.E0T)("session_extend",i);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);(0,P.isJsonRpcResult)(s)?this.events.emit((0,c.E0T)("session_extend",i),{}):(0,P.isJsonRpcError)(s)&&this.events.emit((0,c.E0T)("session_extend",i),{error:s.error})}),y(this,"onSessionPingRequest",async(t,s)=>{const{id:i}=s;try{this.isValidPing({topic:t}),await this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:i,topic:t})}catch(o){await this.sendError({id:i,topic:t,error:o}),this.client.logger.error(o)}}),y(this,"onSessionPingResponse",(t,s)=>{const{id:i}=s,o=(0,c.E0T)("session_ping",i);setTimeout(()=>{if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners 2176`);(0,P.isJsonRpcResult)(s)?this.events.emit((0,c.E0T)("session_ping",i),{}):(0,P.isJsonRpcError)(s)&&this.events.emit((0,c.E0T)("session_ping",i),{error:s.error})},500)}),y(this,"onSessionDeleteRequest",async(t,s)=>{const{id:i}=s;try{this.isValidDisconnect({topic:t,reason:s.params}),await Promise.all([new Promise(o=>{this.client.core.relayer.once(z.publish,async()=>{o(await this.deleteSession({topic:t,id:i}))})}),this.sendResult({id:i,topic:t,result:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:(0,c.D6H)("USER_DISCONNECTED")})]).catch(o=>this.client.logger.error(o))}catch(o){this.client.logger.error(o)}}),y(this,"onSessionRequest",async t=>{var s,i,o;const{topic:a,payload:h,attestation:p,encryptedId:d,transportType:u}=t,{id:g,params:w}=h;try{await this.isValidRequest(D({topic:a},w));const m=this.client.session.get(a),f=await this.getVerifyContext({attestationId:p,hash:(0,c.rjm)(JSON.stringify((0,P.formatJsonRpcRequest)("wc_sessionRequest",w,g))),encryptedId:d,metadata:m.peer.metadata,transportType:u}),v={id:g,topic:a,params:w,verifyContext:f};await this.setPendingSessionRequest(v),u===M.link_mode&&(s=m.peer.metadata.redirect)!=null&&s.universal&&this.client.core.addLinkModeSupportedApp((i=m.peer.metadata.redirect)==null?void 0:i.universal),(o=this.client.signConfig)!=null&&o.disableRequestQueue?this.emitSessionRequest(v):(this.addSessionRequestToSessionRequestQueue(v),this.processSessionRequestQueue())}catch(m){await this.sendError({id:g,topic:a,error:m}),this.client.logger.error(m)}}),y(this,"onSessionRequestResponse",(t,s)=>{const{id:i}=s,o=(0,c.E0T)("session_request",i);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);(0,P.isJsonRpcResult)(s)?this.events.emit((0,c.E0T)("session_request",i),{result:s.result}):(0,P.isJsonRpcError)(s)&&this.events.emit((0,c.E0T)("session_request",i),{error:s.error})}),y(this,"onSessionEventRequest",async(t,s)=>{const{id:i,params:o}=s;try{const a=`${t}_session_event_${o.event.name}`,h=c.O6B.get(a);if(h&&this.isRequestOutOfSync(h,i)){this.client.logger.info(`Discarding out of sync request - ${i}`);return}this.isValidEmit(D({topic:t},o)),this.client.events.emit("session_event",{id:i,topic:t,params:o}),c.O6B.set(a,i)}catch(a){await this.sendError({id:i,topic:t,error:a}),this.client.logger.error(a)}}),y(this,"onSessionAuthenticateResponse",(t,s)=>{const{id:i}=s;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:s}),(0,P.isJsonRpcResult)(s)?this.events.emit((0,c.E0T)("session_request",i),{result:s.result}):(0,P.isJsonRpcError)(s)&&this.events.emit((0,c.E0T)("session_request",i),{error:s.error})}),y(this,"onSessionAuthenticateRequest",async t=>{var s;const{topic:i,payload:o,attestation:a,encryptedId:h,transportType:p}=t;try{const{requester:d,authPayload:u,expiryTimestamp:g}=o.params,w=await this.getVerifyContext({attestationId:a,hash:(0,c.rjm)(JSON.stringify(o)),encryptedId:h,metadata:d.metadata,transportType:p}),m={requester:d,pairingTopic:i,id:o.id,authPayload:u,verifyContext:w,expiryTimestamp:g};await this.setAuthRequest(o.id,{request:m,pairingTopic:i,transportType:p}),p===M.link_mode&&(s=d.metadata.redirect)!=null&&s.universal&&this.client.core.addLinkModeSupportedApp(d.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:i,params:o.params,id:o.id,verifyContext:w})}catch(d){this.client.logger.error(d);const u=o.params.requester.publicKey,g=await this.client.core.crypto.generateKeyPair(),w=this.getAppLinkIfEnabled(o.params.requester.metadata,p),m={type:c.rVF,receiverPublicKey:u,senderPublicKey:g};await this.sendError({id:o.id,topic:i,error:d,encodeOpts:m,rpcOpts:G.wc_sessionAuthenticate.autoReject,appLink:w})}}),y(this,"addSessionRequestToSessionRequestQueue",t=>{this.sessionRequestQueue.queue.push(t)}),y(this,"cleanupAfterResponse",t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=me.idle,this.processSessionRequestQueue()},(0,b.toMiliseconds)(this.requestQueueDelay))}),y(this,"cleanupPendingSentRequestsForTopic",({topic:t,error:s})=>{const i=this.client.core.history.pending;i.length>0&&i.filter(o=>o.topic===t&&o.request.method==="wc_sessionRequest").forEach(o=>{const a=o.request.id,h=(0,c.E0T)("session_request",a);if(this.events.listenerCount(h)===0)throw new Error(`emitting ${h} without any listeners`);this.events.emit((0,c.E0T)("session_request",o.request.id),{error:s})})}),y(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===me.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.emitSessionRequest(t)}catch(s){this.client.logger.error(s)}}),y(this,"emitSessionRequest",t=>{if(this.emittedSessionRequests.has(t.id)){this.client.logger.warn({id:t.id},`Skipping emitting \`session_request\` event for duplicate request. id: ${t.id}`);return}this.sessionRequestQueue.state=me.active,this.emittedSessionRequests.add(t.id),this.client.events.emit("session_request",t)}),y(this,"onPairingCreated",t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const s=this.client.proposal.getAll().find(i=>i.pairingTopic===t.topic);s&&this.onSessionProposeRequest({topic:t.topic,payload:(0,P.formatJsonRpcRequest)("wc_sessionPropose",W(D({},s),{requiredNamespaces:s.requiredNamespaces,optionalNamespaces:s.optionalNamespaces,relays:s.relays,proposer:s.proposer,sessionProperties:s.sessionProperties,scopedProperties:s.scopedProperties}),s.id),attestation:s.attestation,encryptedId:s.encryptedId})}),y(this,"isValidConnect",async t=>{if(!(0,c.EJd)(t)){const{message:d}=(0,c.kCb)("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(d)}const{pairingTopic:s,requiredNamespaces:i,optionalNamespaces:o,sessionProperties:a,scopedProperties:h,relays:p}=t;if((0,c.o8e)(s)||await this.isValidPairingTopic(s),!(0,c.PMr)(p,!0)){const{message:d}=(0,c.kCb)("MISSING_OR_INVALID",`connect() relays: ${p}`);throw new Error(d)}if(!(0,c.o8e)(i)&&(0,c.L5o)(i)!==0){const d="requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";["fatal","error","silent"].includes(this.client.logger.level)?console.warn(d):this.client.logger.warn(d),this.validateNamespaces(i,"requiredNamespaces")}if(!(0,c.o8e)(o)&&(0,c.L5o)(o)!==0&&this.validateNamespaces(o,"optionalNamespaces"),(0,c.o8e)(a)||this.validateSessionProps(a,"sessionProperties"),!(0,c.o8e)(h)){this.validateSessionProps(h,"scopedProperties");const d=Object.keys(i||{}).concat(Object.keys(o||{}));if(!Object.keys(h).every(u=>d.includes(u.split(":")[0])))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(h)}, required/optional namespaces: ${JSON.stringify(d)}`)}}),y(this,"validateNamespaces",(t,s)=>{const i=(0,c.naP)(t,"connect()",s);if(i)throw new Error(i.message)}),y(this,"isValidApprove",async t=>{if(!(0,c.EJd)(t))throw new Error((0,c.kCb)("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:s,namespaces:i,relayProtocol:o,sessionProperties:a,scopedProperties:h}=t;this.checkRecentlyDeleted(s),await this.isValidProposalId(s);const p=this.client.proposal.get(s),d=(0,c.ing)(i,"approve()");if(d)throw new Error(d.message);const u=(0,c.rFo)(p.requiredNamespaces,i,"approve()");if(u)throw new Error(u.message);if(!(0,c.M_r)(o,!0)){const{message:g}=(0,c.kCb)("MISSING_OR_INVALID",`approve() relayProtocol: ${o}`);throw new Error(g)}if((0,c.o8e)(a)||this.validateSessionProps(a,"sessionProperties"),!(0,c.o8e)(h)){this.validateSessionProps(h,"scopedProperties");const g=new Set(Object.keys(i));if(!Object.keys(h).every(w=>g.has(w.split(":")[0])))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(h)}, approved namespaces: ${Array.from(g).join(", ")}`)}}),y(this,"isValidReject",async t=>{if(!(0,c.EJd)(t)){const{message:o}=(0,c.kCb)("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(o)}const{id:s,reason:i}=t;if(this.checkRecentlyDeleted(s),await this.isValidProposalId(s),!(0,c.H4H)(i)){const{message:o}=(0,c.kCb)("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(i)}`);throw new Error(o)}}),y(this,"isValidSessionSettleRequest",t=>{if(!(0,c.EJd)(t)){const{message:d}=(0,c.kCb)("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(d)}const{relay:s,controller:i,namespaces:o,expiry:a}=t;if(!(0,c.Z26)(s)){const{message:d}=(0,c.kCb)("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(d)}const h=(0,c.DdM)(i,"onSessionSettleRequest()");if(h)throw new Error(h.message);const p=(0,c.ing)(o,"onSessionSettleRequest()");if(p)throw new Error(p.message);if((0,c.BwD)(a)){const{message:d}=(0,c.kCb)("EXPIRED","onSessionSettleRequest()");throw new Error(d)}}),y(this,"isValidUpdate",async t=>{if(!(0,c.EJd)(t)){const{message:p}=(0,c.kCb)("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(p)}const{topic:s,namespaces:i}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s);const o=this.client.session.get(s),a=(0,c.ing)(i,"update()");if(a)throw new Error(a.message);const h=(0,c.rFo)(o.requiredNamespaces,i,"update()");if(h)throw new Error(h.message)}),y(this,"isValidExtend",async t=>{if(!(0,c.EJd)(t)){const{message:i}=(0,c.kCb)("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(i)}const{topic:s}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s)}),y(this,"isValidRequest",async t=>{if(!(0,c.EJd)(t)){const{message:p}=(0,c.kCb)("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(p)}const{topic:s,request:i,chainId:o,expiry:a}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s);const{namespaces:h}=this.client.session.get(s);if(!(0,c.p8o)(h,o)){const{message:p}=(0,c.kCb)("MISSING_OR_INVALID",`request() chainId: ${o}`);throw new Error(p)}if(!(0,c.hHR)(i)){const{message:p}=(0,c.kCb)("MISSING_OR_INVALID",`request() ${JSON.stringify(i)}`);throw new Error(p)}if(!(0,c.alS)(h,o,i.method)){const{message:p}=(0,c.kCb)("MISSING_OR_INVALID",`request() method: ${i.method}`);throw new Error(p)}if(a&&!(0,c.ONw)(a,zt)){const{message:p}=(0,c.kCb)("MISSING_OR_INVALID",`request() expiry: ${a}. Expiry must be a number (in seconds) between ${zt.min} and ${zt.max}`);throw new Error(p)}}),y(this,"isValidRespond",async t=>{var s;if(!(0,c.EJd)(t)){const{message:a}=(0,c.kCb)("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(a)}const{topic:i,response:o}=t;try{await this.isValidSessionTopic(i)}catch(a){throw(s=t==null?void 0:t.response)!=null&&s.id&&this.cleanupAfterResponse(t),a}if(!(0,c.JTI)(o)){const{message:a}=(0,c.kCb)("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(o)}`);throw new Error(a)}}),y(this,"isValidPing",async t=>{if(!(0,c.EJd)(t)){const{message:i}=(0,c.kCb)("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(i)}const{topic:s}=t;await this.isValidSessionOrPairingTopic(s)}),y(this,"isValidEmit",async t=>{if(!(0,c.EJd)(t)){const{message:h}=(0,c.kCb)("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(h)}const{topic:s,event:i,chainId:o}=t;await this.isValidSessionTopic(s);const{namespaces:a}=this.client.session.get(s);if(!(0,c.p8o)(a,o)){const{message:h}=(0,c.kCb)("MISSING_OR_INVALID",`emit() chainId: ${o}`);throw new Error(h)}if(!(0,c.nfW)(i)){const{message:h}=(0,c.kCb)("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(h)}if(!(0,c.B95)(a,o,i.name)){const{message:h}=(0,c.kCb)("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(h)}}),y(this,"isValidDisconnect",async t=>{if(!(0,c.EJd)(t)){const{message:i}=(0,c.kCb)("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(i)}const{topic:s}=t;await this.isValidSessionOrPairingTopic(s)}),y(this,"isValidAuthenticate",t=>{const{chains:s,uri:i,domain:o,nonce:a}=t;if(!Array.isArray(s)||s.length===0)throw new Error("chains is required and must be a non-empty array");if(!(0,c.M_r)(i,!1))throw new Error("uri is required parameter");if(!(0,c.M_r)(o,!1))throw new Error("domain is required parameter");if(!(0,c.M_r)(a,!1))throw new Error("nonce is required parameter");if([...new Set(s.map(p=>(0,c.DQe)(p).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:h}=(0,c.DQe)(s[0]);if(h!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),y(this,"getVerifyContext",async t=>{const{attestationId:s,hash:i,encryptedId:o,metadata:a,transportType:h}=t,p={verified:{verifyUrl:a.verifyUrl||Ye,validation:"UNKNOWN",origin:a.url||""}};try{if(h===M.link_mode){const u=this.getAppLinkIfEnabled(a,h);return p.verified.validation=u&&new URL(u).origin===new URL(a.url).origin?"VALID":"INVALID",p}const d=await this.client.core.verify.resolve({attestationId:s,hash:i,encryptedId:o,verifyUrl:a.verifyUrl});d&&(p.verified.origin=d.origin,p.verified.isScam=d.isScam,p.verified.validation=d.origin===new URL(a.url).origin?"VALID":"INVALID")}catch(d){this.client.logger.warn(d)}return this.client.logger.debug(`Verify context: ${JSON.stringify(p)}`),p}),y(this,"validateSessionProps",(t,s)=>{Object.values(t).forEach((i,o)=>{if(i==null){const{message:a}=(0,c.kCb)("MISSING_OR_INVALID",`${s} must contain an existing value for each key. Received: ${i} for key ${Object.keys(t)[o]}`);throw new Error(a)}})}),y(this,"getPendingAuthRequest",t=>{const s=this.client.auth.requests.get(t);return typeof s=="object"?s:void 0}),y(this,"addToRecentlyDeleted",(t,s)=>{if(this.recentlyDeletedMap.set(t,s),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let i=0;const o=this.recentlyDeletedLimit/2;for(const a of this.recentlyDeletedMap.keys()){if(i++>=o)break;this.recentlyDeletedMap.delete(a)}}}),y(this,"checkRecentlyDeleted",t=>{const s=this.recentlyDeletedMap.get(t);if(s){const{message:i}=(0,c.kCb)("MISSING_OR_INVALID",`Record was recently deleted - ${s}: ${t}`);throw new Error(i)}}),y(this,"isLinkModeEnabled",(t,s)=>{var i,o,a,h,p,d,u,g,w;return!t||s!==M.link_mode?!1:((o=(i=this.client.metadata)==null?void 0:i.redirect)==null?void 0:o.linkMode)===!0&&((h=(a=this.client.metadata)==null?void 0:a.redirect)==null?void 0:h.universal)!==void 0&&((d=(p=this.client.metadata)==null?void 0:p.redirect)==null?void 0:d.universal)!==""&&((u=t==null?void 0:t.redirect)==null?void 0:u.universal)!==void 0&&((g=t==null?void 0:t.redirect)==null?void 0:g.universal)!==""&&((w=t==null?void 0:t.redirect)==null?void 0:w.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(t.redirect.universal)&&typeof(R.g==null?void 0:R.g.Linking)<"u"}),y(this,"getAppLinkIfEnabled",(t,s)=>{var i;return this.isLinkModeEnabled(t,s)?(i=t==null?void 0:t.redirect)==null?void 0:i.universal:void 0}),y(this,"handleLinkModeMessage",({url:t})=>{if(!t||!t.includes("wc_ev")||!t.includes("topic"))return;const s=(0,c.waw)(t,"topic")||"",i=decodeURIComponent((0,c.waw)(t,"wc_ev")||""),o=this.client.session.keys.includes(s);o&&this.client.session.update(s,{transportType:M.link_mode}),this.client.core.dispatchEnvelope({topic:s,message:i,sessionExists:o})}),y(this,"registerLinkModeListeners",async()=>{var t;if((0,c.h9F)()||(0,c.b$m)()&&(t=this.client.metadata.redirect)!=null&&t.linkMode){const s=R.g==null?void 0:R.g.Linking;if(typeof s<"u"){s.addEventListener("url",this.handleLinkModeMessage,this.client.name);const i=await s.getInitialURL();i&&setTimeout(()=>{this.handleLinkModeMessage({url:i})},50)}}}),y(this,"getTVFParams",(t,s,i)=>{var o,a,h;if(!((o=s.request)!=null&&o.method))return{};const p={correlationId:t,rpcMethods:[s.request.method],chainId:s.chainId};try{const d=this.extractTxHashesFromResult(s.request,i);p.txHashes=d,p.contractAddresses=this.isValidContractData(s.request.params)?[(h=(a=s.request.params)==null?void 0:a[0])==null?void 0:h.to]:[]}catch(d){this.client.logger.warn("Error getting TVF params",d)}return p}),y(this,"isValidContractData",t=>{var s;if(!t)return!1;try{const i=(t==null?void 0:t.data)||((s=t==null?void 0:t[0])==null?void 0:s.data);if(!i.startsWith("0x"))return!1;const o=i.slice(2);return/^[0-9a-fA-F]*$/.test(o)?o.length%2===0:!1}catch{}return!1}),y(this,"extractTxHashesFromResult",(t,s)=>{var i;try{if(!s)return[];const o=t.method,a=gc[o];if(o==="sui_signTransaction")return[(0,c.O4P)(s.transactionBytes)];if(o==="near_signTransaction")return[(0,c.Gpr)(s)];if(o==="near_signTransactions")return s.map(p=>(0,c.Gpr)(p));if(o==="xrpl_signTransactionFor"||o==="xrpl_signTransaction")return[(i=s.tx_json)==null?void 0:i.hash];if(o==="polkadot_signTransaction")return[(0,c.ukW)({transaction:t.params.transactionPayload,signature:s.signature})];if(o==="algo_signTxn")return(0,c.qt8)(s)?s.map(p=>(0,c.iGn)(p)):[(0,c.iGn)(s)];if(o==="cosmos_signDirect")return[(0,c.xjP)(s)];if(typeof s=="string")return[s];const h=s[a.key];if((0,c.qt8)(h))return o==="solana_signAllTransactions"?h.map(p=>(0,c.P56)(p)):h;if(typeof h=="string")return[h]}catch(o){this.client.logger.warn("Error extracting tx hashes from result",o)}return[]})}async processPendingMessageEvents(){try{const e=this.client.session.keys,t=this.client.core.relayer.messages.getWithoutAck(e);for(const[s,i]of Object.entries(t))for(const o of i)try{await this.onProviderMessageEvent({topic:s,message:o,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${s}, message: ${o}`)}}catch(e){this.client.logger.warn("processPendingMessageEvents failed",e)}}isInitialized(){if(!this.initialized){const{message:e}=(0,c.kCb)("NOT_INITIALIZED",this.name);throw new Error(e)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(z.message,e=>{this.onProviderMessageEvent(e)})}async onRelayMessage(e){const{topic:t,message:s,attestation:i,transportType:o}=e,{publicKey:a}=this.client.auth.authKeys.keys.includes(ut)?this.client.auth.authKeys.get(ut):{responseTopic:void 0,publicKey:void 0};try{const h=await this.client.core.crypto.decode(t,s,{receiverPublicKey:a,encoding:o===M.link_mode?c.zl_:c.$dT});(0,P.isJsonRpcRequest)(h)?(this.client.core.history.set(t,h),await this.onRelayEventRequest({topic:t,payload:h,attestation:i,transportType:o,encryptedId:(0,c.rjm)(s)})):(0,P.isJsonRpcResponse)(h)?(await this.client.core.history.resolve(h),await this.onRelayEventResponse({topic:t,payload:h,transportType:o}),this.client.core.history.delete(t,h.id)):await this.onRelayEventUnknownPayload({topic:t,payload:h,transportType:o}),await this.client.core.relayer.messages.ack(t,s)}catch(h){this.client.logger.error(h)}}registerExpirerEvents(){this.client.core.expirer.on(ne.expired,async e=>{const{topic:t,id:s}=(0,c.iPz)(e.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,(0,c.kCb)("EXPIRED"),!0);if(s&&this.client.auth.requests.keys.includes(s))return await this.deletePendingAuthRequest(s,(0,c.kCb)("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s}))})}registerPairingEvents(){this.client.core.pairing.events.on(Ee.create,e=>this.onPairingCreated(e)),this.client.core.pairing.events.on(Ee.delete,e=>{this.addToRecentlyDeleted(e.topic,"pairing")})}isValidPairingTopic(e){if(!(0,c.M_r)(e,!1)){const{message:t}=(0,c.kCb)("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(e)){const{message:t}=(0,c.kCb)("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if((0,c.BwD)(this.client.core.pairing.pairings.get(e).expiry)){const{message:t}=(0,c.kCb)("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}}async isValidSessionTopic(e){if(!(0,c.M_r)(e,!1)){const{message:t}=(0,c.kCb)("MISSING_OR_INVALID",`session topic should be a string: ${e}`);throw new Error(t)}if(this.checkRecentlyDeleted(e),!this.client.session.keys.includes(e)){const{message:t}=(0,c.kCb)("NO_MATCHING_KEY",`session topic doesn't exist: ${e}`);throw new Error(t)}if((0,c.BwD)(this.client.session.get(e).expiry)){await this.deleteSession({topic:e});const{message:t}=(0,c.kCb)("EXPIRED",`session topic: ${e}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(e)){const{message:t}=(0,c.kCb)("MISSING_OR_INVALID",`session topic does not exist in keychain: ${e}`);throw await this.deleteSession({topic:e}),new Error(t)}}async isValidSessionOrPairingTopic(e){if(this.checkRecentlyDeleted(e),this.client.session.keys.includes(e))await this.isValidSessionTopic(e);else if(this.client.core.pairing.pairings.keys.includes(e))this.isValidPairingTopic(e);else if((0,c.M_r)(e,!1)){const{message:t}=(0,c.kCb)("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${e}`);throw new Error(t)}else{const{message:t}=(0,c.kCb)("MISSING_OR_INVALID",`session or pairing topic should be a string: ${e}`);throw new Error(t)}}async isValidProposalId(e){if(!(0,c.Q01)(e)){const{message:t}=(0,c.kCb)("MISSING_OR_INVALID",`proposal id should be a number: ${e}`);throw new Error(t)}if(!this.client.proposal.keys.includes(e)){const{message:t}=(0,c.kCb)("NO_MATCHING_KEY",`proposal id doesn't exist: ${e}`);throw new Error(t)}if((0,c.BwD)(this.client.proposal.get(e).expiryTimestamp)){await this.deleteProposal(e);const{message:t}=(0,c.kCb)("EXPIRED",`proposal id: ${e}`);throw new Error(t)}}}class Oc extends xe{constructor(e,t){super(e,t,pc,Lt),this.core=e,this.logger=t}}class Rc extends xe{constructor(e,t){super(e,t,dc,Lt),this.core=e,this.logger=t}}class Tc extends xe{constructor(e,t){super(e,t,yc,Lt,s=>s.id),this.core=e,this.logger=t}}class Ac extends xe{constructor(e,t){super(e,t,vc,dt,()=>ut),this.core=e,this.logger=t}}class qc extends xe{constructor(e,t){super(e,t,bc,dt),this.core=e,this.logger=t}}class Nc extends xe{constructor(e,t){super(e,t,_c,dt,s=>s.id),this.core=e,this.logger=t}}var Fc=Object.defineProperty,Dc=(r,e,t)=>e in r?Fc(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Kt=(r,e,t)=>Dc(r,typeof e!="symbol"?e+"":e,t);class jc{constructor(e,t){this.core=e,this.logger=t,Kt(this,"authKeys"),Kt(this,"pairingTopics"),Kt(this,"requests"),this.authKeys=new Ac(this.core,this.logger),this.pairingTopics=new qc(this.core,this.logger),this.requests=new Nc(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var kc=Object.defineProperty,$c=(r,e,t)=>e in r?kc(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,A=(r,e,t)=>$c(r,typeof e!="symbol"?e+"":e,t);class Vt extends Ir{constructor(e){super(e),A(this,"protocol",si),A(this,"version",ii),A(this,"name",Ht.name),A(this,"metadata"),A(this,"core"),A(this,"logger"),A(this,"events",new ve.EventEmitter),A(this,"engine"),A(this,"session"),A(this,"proposal"),A(this,"pendingRequest"),A(this,"auth"),A(this,"signConfig"),A(this,"on",(s,i)=>this.events.on(s,i)),A(this,"once",(s,i)=>this.events.once(s,i)),A(this,"off",(s,i)=>this.events.off(s,i)),A(this,"removeListener",(s,i)=>this.events.removeListener(s,i)),A(this,"removeAllListeners",s=>this.events.removeAllListeners(s)),A(this,"connect",async s=>{try{return await this.engine.connect(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"pair",async s=>{try{return await this.engine.pair(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"approve",async s=>{try{return await this.engine.approve(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"reject",async s=>{try{return await this.engine.reject(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"update",async s=>{try{return await this.engine.update(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"extend",async s=>{try{return await this.engine.extend(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"request",async s=>{try{return await this.engine.request(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"respond",async s=>{try{return await this.engine.respond(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"ping",async s=>{try{return await this.engine.ping(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"emit",async s=>{try{return await this.engine.emit(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"disconnect",async s=>{try{return await this.engine.disconnect(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"find",s=>{try{return this.engine.find(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}}),A(this,"authenticate",async(s,i)=>{try{return await this.engine.authenticate(s,i)}catch(o){throw this.logger.error(o.message),o}}),A(this,"formatAuthMessage",s=>{try{return this.engine.formatAuthMessage(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"approveSessionAuthenticate",async s=>{try{return await this.engine.approveSessionAuthenticate(s)}catch(i){throw this.logger.error(i.message),i}}),A(this,"rejectSessionAuthenticate",async s=>{try{return await this.engine.rejectSessionAuthenticate(s)}catch(i){throw this.logger.error(i.message),i}}),this.name=(e==null?void 0:e.name)||Ht.name,this.metadata=(0,c.WPw)(e==null?void 0:e.metadata),this.signConfig=e==null?void 0:e.signConfig;const t=typeof(e==null?void 0:e.logger)<"u"&&typeof(e==null?void 0:e.logger)!="string"?e.logger:(0,O.gw)((0,O.jI)({level:(e==null?void 0:e.logger)||Ht.logger}));this.core=(e==null?void 0:e.core)||new lc(e),this.logger=(0,O.Ep)(t,this.name),this.session=new Rc(this.core,this.logger),this.proposal=new Oc(this.core,this.logger),this.pendingRequest=new Tc(this.core,this.logger),this.engine=new Cc(this),this.auth=new jc(this.core,this.logger)}static async init(e){const t=new Vt(e);return await t.initialize(),t}get context(){return(0,O.Fd)(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success")}catch(e){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(e.message),e}}}const ap=null,cp=null;var le=R(51916),gt=R(55872).Buffer;const ci="error",Mc="wss://relay.walletconnect.org",Lc="wc",Hc="universal_provider",yt=`${Lc}@2:${Hc}:`,hi="https://rpc.walletconnect.org/v1/",li="generic",zc=`${hi}bundler`,$e="call_status",Uc=86400,ae={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function Bt(r){return r==null||typeof r!="object"&&typeof r!="function"}function pi(r){return Object.getOwnPropertySymbols(r).filter(e=>Object.prototype.propertyIsEnumerable.call(r,e))}function di(r){return r==null?r===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(r)}const Kc="[object RegExp]",ui="[object String]",gi="[object Number]",yi="[object Boolean]",mi="[object Arguments]",Vc="[object Symbol]",Bc="[object Date]",Jc="[object Map]",Gc="[object Set]",Qc="[object Array]",Wc="[object ArrayBuffer]",Yc="[object Object]",Zc="[object DataView]",Xc="[object Uint8Array]",eh="[object Uint8ClampedArray]",th="[object Uint16Array]",sh="[object Uint32Array]",ih="[object Int8Array]",rh="[object Int16Array]",nh="[object Int32Array]",oh="[object Float32Array]",ah="[object Float64Array]";function Jt(r){return ArrayBuffer.isView(r)&&!(r instanceof DataView)}function ch(r,e){return Me(r,void 0,r,new Map,e)}function Me(r,e,t,s=new Map,i=void 0){const o=i==null?void 0:i(r,e,t,s);if(o!=null)return o;if(Bt(r))return r;if(s.has(r))return s.get(r);if(Array.isArray(r)){const a=new Array(r.length);s.set(r,a);for(let h=0;h<r.length;h++)a[h]=Me(r[h],h,t,s,i);return Object.hasOwn(r,"index")&&(a.index=r.index),Object.hasOwn(r,"input")&&(a.input=r.input),a}if(r instanceof Date)return new Date(r.getTime());if(r instanceof RegExp){const a=new RegExp(r.source,r.flags);return a.lastIndex=r.lastIndex,a}if(r instanceof Map){const a=new Map;s.set(r,a);for(const[h,p]of r)a.set(h,Me(p,h,t,s,i));return a}if(r instanceof Set){const a=new Set;s.set(r,a);for(const h of r)a.add(Me(h,void 0,t,s,i));return a}if(typeof gt<"u"&&gt.isBuffer(r))return r.subarray();if(Jt(r)){const a=new(Object.getPrototypeOf(r)).constructor(r.length);s.set(r,a);for(let h=0;h<r.length;h++)a[h]=Me(r[h],h,t,s,i);return a}if(r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer)return r.slice(0);if(r instanceof DataView){const a=new DataView(r.buffer.slice(0),r.byteOffset,r.byteLength);return s.set(r,a),Ce(a,r,t,s,i),a}if(typeof File<"u"&&r instanceof File){const a=new File([r],r.name,{type:r.type});return s.set(r,a),Ce(a,r,t,s,i),a}if(r instanceof Blob){const a=new Blob([r],{type:r.type});return s.set(r,a),Ce(a,r,t,s,i),a}if(r instanceof Error){const a=new r.constructor;return s.set(r,a),a.message=r.message,a.name=r.name,a.stack=r.stack,a.cause=r.cause,Ce(a,r,t,s,i),a}if(typeof r=="object"&&hh(r)){const a=Object.create(Object.getPrototypeOf(r));return s.set(r,a),Ce(a,r,t,s,i),a}return r}function Ce(r,e,t=r,s,i){const o=[...Object.keys(e),...pi(e)];for(let a=0;a<o.length;a++){const h=o[a],p=Object.getOwnPropertyDescriptor(r,h);(p==null||p.writable)&&(r[h]=Me(e[h],h,t,s,i))}}function hh(r){switch(di(r)){case mi:case Qc:case Wc:case Zc:case yi:case Bc:case oh:case ah:case ih:case rh:case nh:case Jc:case gi:case Yc:case Kc:case Gc:case ui:case Vc:case Xc:case eh:case th:case sh:return!0;default:return!1}}function lh(r,e){return ch(r,(t,s,i,o)=>{const a=e==null?void 0:e(t,s,i,o);if(a!=null)return a;if(typeof r=="object")switch(Object.prototype.toString.call(r)){case gi:case ui:case yi:{const h=new r.constructor(r==null?void 0:r.valueOf());return Ce(h,r),h}case mi:{const h={};return Ce(h,r),h.length=r.length,h[Symbol.iterator]=r[Symbol.iterator],h}default:return}})}function fi(r){return lh(r)}function wi(r){return r!==null&&typeof r=="object"&&di(r)==="[object Arguments]"}function vi(r){return typeof r=="object"&&r!==null}function ph(){}function dh(r){return Jt(r)}function uh(r){var t;if(typeof r!="object"||r==null)return!1;if(Object.getPrototypeOf(r)===null)return!0;if(Object.prototype.toString.call(r)!=="[object Object]"){const s=r[Symbol.toStringTag];return s==null||!((t=Object.getOwnPropertyDescriptor(r,Symbol.toStringTag))!=null&&t.writable)?!1:r.toString()===`[object ${s}]`}let e=r;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(r)===e}function gh(r){if(Bt(r))return r;if(Array.isArray(r)||Jt(r)||r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer)return r.slice(0);const e=Object.getPrototypeOf(r),t=e.constructor;if(r instanceof Date||r instanceof Map||r instanceof Set)return new t(r);if(r instanceof RegExp){const s=new t(r);return s.lastIndex=r.lastIndex,s}if(r instanceof DataView)return new t(r.buffer.slice(0));if(r instanceof Error){const s=new t(r.message);return s.stack=r.stack,s.name=r.name,s.cause=r.cause,s}if(typeof File<"u"&&r instanceof File)return new t([r],r.name,{type:r.type,lastModified:r.lastModified});if(typeof r=="object"){const s=Object.create(e);return Object.assign(s,r)}return r}function yh(r,...e){const t=e.slice(0,-1),s=e[e.length-1];let i=r;for(let o=0;o<t.length;o++){const a=t[o];i=Gt(i,a,s,new Map)}return i}function Gt(r,e,t,s){if(Bt(r)&&(r=Object(r)),e==null||typeof e!="object")return r;if(s.has(e))return gh(s.get(e));if(s.set(e,r),Array.isArray(e)){e=e.slice();for(let o=0;o<e.length;o++)e[o]=e[o]??void 0}const i=[...Object.keys(e),...pi(e)];for(let o=0;o<i.length;o++){const a=i[o];let h=e[a],p=r[a];if(wi(h)&&(h={...h}),wi(p)&&(p={...p}),typeof gt<"u"&&gt.isBuffer(h)&&(h=fi(h)),Array.isArray(h))if(typeof p=="object"&&p!=null){const u=[],g=Reflect.ownKeys(p);for(let w=0;w<g.length;w++){const m=g[w];u[m]=p[m]}p=u}else p=[];const d=t(p,h,a,r,e,s);d!=null?r[a]=d:Array.isArray(h)||vi(p)&&vi(h)?r[a]=Gt(p,h,t,s):p==null&&uh(h)?r[a]=Gt({},h,t,s):p==null&&dh(h)?r[a]=fi(h):(p===void 0||h!==void 0)&&(r[a]=h)}return r}function mh(r,...e){return yh(r,...e,ph)}var fh=Object.defineProperty,wh=Object.defineProperties,vh=Object.getOwnPropertyDescriptors,bi=Object.getOwnPropertySymbols,bh=Object.prototype.hasOwnProperty,_h=Object.prototype.propertyIsEnumerable,_i=(r,e,t)=>e in r?fh(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,mt=(r,e)=>{for(var t in e||(e={}))bh.call(e,t)&&_i(r,t,e[t]);if(bi)for(var t of bi(e))_h.call(e,t)&&_i(r,t,e[t]);return r},Ih=(r,e)=>wh(r,vh(e));function te(r,e,t){var s;const i=(0,c.DQe)(r);return((s=e.rpcMap)==null?void 0:s[i.reference])||`${hi}?chainId=${i.namespace}:${i.reference}&projectId=${t}`}function Oe(r){return r.includes(":")?r.split(":")[1]:r}function Ii(r){return r.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}function Ph(r,e){const t=Object.keys(e.namespaces).filter(i=>i.includes(r));if(!t.length)return[];const s=[];return t.forEach(i=>{const o=e.namespaces[i].accounts;s.push(...o)}),s}function Pi(r){return Object.fromEntries(Object.entries(r).filter(([e,t])=>{var s,i;return((s=t==null?void 0:t.chains)==null?void 0:s.length)&&((i=t==null?void 0:t.chains)==null?void 0:i.length)>0}))}function ft(r={},e={}){const t=Pi(Ei(r)),s=Pi(Ei(e));return mh(t,s)}function Ei(r){var e,t,s,i,o;const a={};if(!(0,c.L5o)(r))return a;for(const[h,p]of Object.entries(r)){const d=(0,c.gpE)(h)?[h]:p.chains,u=p.methods||[],g=p.events||[],w=p.rpcMap||{},m=(0,c.Maj)(h);a[m]=Ih(mt(mt({},a[m]),p),{chains:(0,c.eGA)(d,(e=a[m])==null?void 0:e.chains),methods:(0,c.eGA)(u,(t=a[m])==null?void 0:t.methods),events:(0,c.eGA)(g,(s=a[m])==null?void 0:s.events)}),((0,c.L5o)(w)||(0,c.L5o)(((i=a[m])==null?void 0:i.rpcMap)||{}))&&(a[m].rpcMap=mt(mt({},w),(o=a[m])==null?void 0:o.rpcMap))}return a}function Si(r){return r.includes(":")?r.split(":")[2]:r}function xi(r){const e={};for(const[t,s]of Object.entries(r)){const i=s.methods||[],o=s.events||[],a=s.accounts||[],h=(0,c.gpE)(t)?[t]:s.chains?s.chains:Ii(s.accounts);e[t]={chains:h,methods:i,events:o,accounts:a}}return e}function Qt(r){return typeof r=="number"?r:r.includes("0x")?parseInt(r,16):(r=r.includes(":")?r.split(":")[1]:r,isNaN(Number(r))?r:Number(r))}function Eh(r){try{const e=JSON.parse(r);return typeof e=="object"&&e!==null&&!Array.isArray(e)}catch{return!1}}const Ci={},N=r=>Ci[r],Wt=(r,e)=>{Ci[r]=e};var Sh=Object.defineProperty,Oi=Object.getOwnPropertySymbols,xh=Object.prototype.hasOwnProperty,Ch=Object.prototype.propertyIsEnumerable,Ri=(r,e,t)=>e in r?Sh(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Ti=(r,e)=>{for(var t in e||(e={}))xh.call(e,t)&&Ri(r,t,e[t]);if(Oi)for(var t of Oi(e))Ch.call(e,t)&&Ri(r,t,e[t]);return r};const Ai="eip155",Oh=["atomic","flow-control","paymasterService","sessionKeys","auxiliaryFunds"],Rh=r=>r&&r.startsWith("0x")?BigInt(r).toString(10):r,Yt=r=>r&&r.startsWith("0x")?r:`0x${BigInt(r).toString(16)}`,qi=r=>Object.keys(r).filter(e=>Oh.includes(e)).reduce((e,t)=>(e[t]=Th(r[t]),e),{}),Th=r=>typeof r=="string"&&Eh(r)?JSON.parse(r):r,Ah=(r,e,t)=>{const{sessionProperties:s={},scopedProperties:i={}}=r,o={};if(!(0,c.L5o)(i)&&!(0,c.L5o)(s))return;const a=qi(s);for(const h of t){const p=Rh(h);if(!p)continue;o[Yt(p)]=a;const d=i==null?void 0:i[`${Ai}:${p}`];if(d){const u=d==null?void 0:d[`${Ai}:${p}:${e}`];o[Yt(p)]=Ti(Ti({},o[Yt(p)]),qi(u||d))}}for(const[h,p]of Object.entries(o))Object.keys(p).length===0&&delete o[h];return Object.keys(o).length>0?o:void 0};var qh=Object.defineProperty,Nh=(r,e,t)=>e in r?qh(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Fh=(r,e,t)=>Nh(r,typeof e!="symbol"?e+"":e,t);let Zt;class Xt{constructor(e){Fh(this,"storage"),this.storage=e}async getItem(e){return await this.storage.getItem(e)}async setItem(e,t){return await this.storage.setItem(e,t)}async removeItem(e){return await this.storage.removeItem(e)}static getStorage(e){return Zt||(Zt=new Xt(e)),Zt}}var Dh=Object.defineProperty,jh=Object.defineProperties,kh=Object.getOwnPropertyDescriptors,Ni=Object.getOwnPropertySymbols,$h=Object.prototype.hasOwnProperty,Mh=Object.prototype.propertyIsEnumerable,Fi=(r,e,t)=>e in r?Dh(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Lh=(r,e)=>{for(var t in e||(e={}))$h.call(e,t)&&Fi(r,t,e[t]);if(Ni)for(var t of Ni(e))Mh.call(e,t)&&Fi(r,t,e[t]);return r},Hh=(r,e)=>jh(r,kh(e));async function zh(r,e){const t=(0,c.DQe)(r.result.capabilities.caip345.caip2),s=r.result.capabilities.caip345.transactionHashes,i=await Promise.allSettled(s.map(g=>Uh(t.reference,g,e))),o=i.filter(g=>g.status==="fulfilled").map(g=>g.value).filter(g=>g);i.filter(g=>g.status==="rejected").forEach(g=>console.warn("Failed to fetch transaction receipt:",g.reason));const a=!o.length||o.some(g=>!g),h=o.every(g=>(g==null?void 0:g.status)==="0x1"),p=o.every(g=>(g==null?void 0:g.status)==="0x0"),d=o.some(g=>(g==null?void 0:g.status)==="0x0");let u;return a?u=100:h?u=200:p?u=500:d&&(u=600),{id:r.result.id,version:r.request.version,atomic:r.request.atomicRequired,chainId:r.request.chainId,capabilities:r.result.capabilities,receipts:o,status:u}}async function Uh(r,e,t){return await t(parseInt(r)).request((0,P.formatJsonRpcRequest)("eth_getTransactionReceipt",[e]))}async function Kh({sendCalls:r,storage:e}){const t=await e.getItem($e);await e.setItem($e,Hh(Lh({},t),{[r.result.id]:{request:r.request,result:r.result,expiry:(0,c.gn4)(Uc)}}))}async function Vh({resultId:r,storage:e}){const t=await e.getItem($e);if(t){delete t[r],await e.setItem($e,t);for(const s in t)(0,c.BwD)(t[s].expiry)&&delete t[s];await e.setItem($e,t)}}async function Bh({resultId:r,storage:e}){const t=await e.getItem($e),s=t==null?void 0:t[r];if(s&&!(0,c.BwD)(s.expiry))return s;await Vh({resultId:r,storage:e})}var Jh=Object.defineProperty,Gh=(r,e,t)=>e in r?Jh(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Le=(r,e,t)=>Gh(r,typeof e!="symbol"?e+"":e,t);class Qh{constructor(e){Le(this,"name","polkadot"),Le(this,"client"),Le(this,"httpProviders"),Le(this,"events"),Le(this,"namespace"),Le(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const i=Oe(t);e[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||te(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new se.r(new le.Z(s,N("disableProviderPing")))}}var Wh=Object.defineProperty,Yh=Object.defineProperties,Zh=Object.getOwnPropertyDescriptors,Di=Object.getOwnPropertySymbols,Xh=Object.prototype.hasOwnProperty,el=Object.prototype.propertyIsEnumerable,es=(r,e,t)=>e in r?Wh(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,ts=(r,e)=>{for(var t in e||(e={}))Xh.call(e,t)&&es(r,t,e[t]);if(Di)for(var t of Di(e))el.call(e,t)&&es(r,t,e[t]);return r},ss=(r,e)=>Yh(r,Zh(e)),Te=(r,e,t)=>es(r,typeof e!="symbol"?e+"":e,t);class tl{constructor(e){Te(this,"name","eip155"),Te(this,"client"),Te(this,"chainId"),Te(this,"namespace"),Te(this,"httpProviders"),Te(this,"events"),Te(this,"storage"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain()),this.storage=Xt.getStorage(this.client.core.storage)}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e);case"wallet_sendCalls":return await this.sendCalls(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(parseInt(e),t),this.chainId=parseInt(e),this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,t){const s=t||te(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new se.r(new le.k(s,N("disableProviderPing")))}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const i=parseInt(Oe(t));e[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}getHttpProvider(e){const t=e||this.chainId;return this.httpProviders[t]||(this.httpProviders=ss(ts({},this.httpProviders),{[t]:this.createHttpProvider(t)}),this.httpProviders[t])}async handleSwitchChain(e){var t,s;let i=e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:"0x0";i=i.startsWith("0x")?i:`0x${i}`;const o=parseInt(i,16);if(this.isChainApproved(o))this.setDefaultChain(`${o}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:i}]},chainId:(s=this.namespace.chains)==null?void 0:s[0]}),this.setDefaultChain(`${o}`);else throw new Error(`Failed to switch to chain 'eip155:${o}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var t,s,i,o,a;const h=(s=(t=e.request)==null?void 0:t.params)==null?void 0:s[0],p=((o=(i=e.request)==null?void 0:i.params)==null?void 0:o[1])||[];if(!h)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const d=this.client.session.get(e.topic),u=((a=d==null?void 0:d.sessionProperties)==null?void 0:a.capabilities)||{},g=`${h}${p.join(",")}`,w=u==null?void 0:u[g];if(w)return w;let m;try{m=Ah(d,h,p)}catch(v){console.warn("Failed to extract capabilities from session",v)}if(m)return m;const f=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:ss(ts({},d.sessionProperties||{}),{capabilities:ss(ts({},u||{}),{[g]:f})})})}catch(v){console.warn("Failed to update session with capabilities",v)}return f}async getCallStatus(e){var t,s,i;const o=this.client.session.get(e.topic),a=(t=o.sessionProperties)==null?void 0:t.bundler_name;if(a){const d=this.getBundlerUrl(e.chainId,a);try{return await this.getUserOperationReceipt(d,e)}catch(u){console.warn("Failed to fetch call status from bundler",u,d)}}const h=(s=o.sessionProperties)==null?void 0:s.bundler_url;if(h)try{return await this.getUserOperationReceipt(h,e)}catch(d){console.warn("Failed to fetch call status from custom bundler",d,h)}const p=await Bh({resultId:(i=e.request.params)==null?void 0:i[0],storage:this.storage});if(p)try{return await zh(p,this.getHttpProvider.bind(this))}catch(d){console.warn("Failed to fetch call status from stored send calls",d,p)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,t){var s;const i=new URL(e),o=await fetch(i,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify((0,P.formatJsonRpcRequest)("eth_getUserOperationReceipt",[(s=t.request.params)==null?void 0:s[0]]))});if(!o.ok)throw new Error(`Failed to fetch user operation receipt - ${o.status}`);return await o.json()}getBundlerUrl(e,t){return`${zc}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`}async sendCalls(e){var t,s,i;const o=await this.client.request(e),a=(t=e.request.params)==null?void 0:t[0],h=o==null?void 0:o.id,p=(o==null?void 0:o.capabilities)||{},d=(s=p==null?void 0:p.caip345)==null?void 0:s.caip2,u=(i=p==null?void 0:p.caip345)==null?void 0:i.transactionHashes;return!h||!d||!(u!=null&&u.length)||await Kh({sendCalls:{request:a,result:o},storage:this.storage}),o}}var sl=Object.defineProperty,il=(r,e,t)=>e in r?sl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,He=(r,e,t)=>il(r,typeof e!="symbol"?e+"":e,t);class rl{constructor(e){He(this,"name","solana"),He(this,"client"),He(this,"httpProviders"),He(this,"events"),He(this,"namespace"),He(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const i=Oe(t);e[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||te(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new se.r(new le.Z(s,N("disableProviderPing")))}}var nl=Object.defineProperty,ol=(r,e,t)=>e in r?nl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,ze=(r,e,t)=>ol(r,typeof e!="symbol"?e+"":e,t);class al{constructor(e){ze(this,"name","cosmos"),ze(this,"client"),ze(this,"httpProviders"),ze(this,"events"),ze(this,"namespace"),ze(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const i=Oe(t);e[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||te(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new se.r(new le.Z(s,N("disableProviderPing")))}}var cl=Object.defineProperty,hl=(r,e,t)=>e in r?cl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Ue=(r,e,t)=>hl(r,typeof e!="symbol"?e+"":e,t);class ll{constructor(e){Ue(this,"name","algorand"),Ue(this,"client"),Ue(this,"httpProviders"),Ue(this,"events"),Ue(this,"namespace"),Ue(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(!this.httpProviders[e]){const s=t||te(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.chainId=e,this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;e[t]=this.createHttpProvider(t,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||te(e,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new se.r(new le.Z(s,N("disableProviderPing")))}}var pl=Object.defineProperty,dl=(r,e,t)=>e in r?pl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Ke=(r,e,t)=>dl(r,typeof e!="symbol"?e+"":e,t);class ul{constructor(e){Ke(this,"name","cip34"),Ke(this,"client"),Ke(this,"httpProviders"),Ke(this,"events"),Ke(this,"namespace"),Ke(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{const s=this.getCardanoRPCUrl(t),i=Oe(t);e[i]=this.createHttpProvider(i,s)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}getCardanoRPCUrl(e){const t=this.namespace.rpcMap;if(t)return t[e]}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||this.getCardanoRPCUrl(e);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new se.r(new le.Z(s,N("disableProviderPing")))}}var gl=Object.defineProperty,yl=(r,e,t)=>e in r?gl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Ve=(r,e,t)=>yl(r,typeof e!="symbol"?e+"":e,t);class ml{constructor(e){Ve(this,"name","elrond"),Ve(this,"client"),Ve(this,"httpProviders"),Ve(this,"events"),Ve(this,"namespace"),Ve(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const i=Oe(t);e[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||te(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new se.r(new le.Z(s,N("disableProviderPing")))}}var fl=Object.defineProperty,wl=(r,e,t)=>e in r?fl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Be=(r,e,t)=>wl(r,typeof e!="symbol"?e+"":e,t);class vl{constructor(e){Be(this,"name","multiversx"),Be(this,"client"),Be(this,"httpProviders"),Be(this,"events"),Be(this,"namespace"),Be(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const i=Oe(t);e[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||te(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new se.r(new le.Z(s,N("disableProviderPing")))}}var bl=Object.defineProperty,_l=(r,e,t)=>e in r?bl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Je=(r,e,t)=>_l(r,typeof e!="symbol"?e+"":e,t);class Il{constructor(e){Je(this,"name","near"),Je(this,"client"),Je(this,"httpProviders"),Je(this,"events"),Je(this,"namespace"),Je(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||te(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;e[t]=this.createHttpProvider(t,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||te(e,this.namespace);return typeof s>"u"?void 0:new se.r(new le.Z(s,N("disableProviderPing")))}}var Pl=Object.defineProperty,El=(r,e,t)=>e in r?Pl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Ge=(r,e,t)=>El(r,typeof e!="symbol"?e+"":e,t);class Sl{constructor(e){Ge(this,"name","tezos"),Ge(this,"client"),Ge(this,"httpProviders"),Ge(this,"events"),Ge(this,"namespace"),Ge(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||te(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||te(e,this.namespace);return typeof s>"u"?void 0:new se.r(new le.Z(s))}}var xl=Object.defineProperty,Cl=(r,e,t)=>e in r?xl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Qe=(r,e,t)=>Cl(r,typeof e!="symbol"?e+"":e,t);class Ol{constructor(e){Qe(this,"name",li),Qe(this,"client"),Qe(this,"httpProviders"),Qe(this,"events"),Qe(this,"namespace"),Qe(this,"chainId"),this.namespace=e.namespace,this.events=N("events"),this.client=N("client"),this.chainId=this.getDefaultChain(),this.name=this.getNamespaceName(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(ae.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getNamespaceName(){const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return(0,c.DQe)(e).namespace}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){var e,t;const s={};return(t=(e=this.namespace)==null?void 0:e.accounts)==null||t.forEach(i=>{const o=(0,c.DQe)(i);s[o.reference]=this.createHttpProvider(i)}),s}getHttpProvider(e){const t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||te(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new se.r(new le.Z(s,N("disableProviderPing")))}}var Rl=Object.defineProperty,Tl=Object.defineProperties,Al=Object.getOwnPropertyDescriptors,ji=Object.getOwnPropertySymbols,ql=Object.prototype.hasOwnProperty,Nl=Object.prototype.propertyIsEnumerable,is=(r,e,t)=>e in r?Rl(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,wt=(r,e)=>{for(var t in e||(e={}))ql.call(e,t)&&is(r,t,e[t]);if(ji)for(var t of ji(e))Nl.call(e,t)&&is(r,t,e[t]);return r},rs=(r,e)=>Tl(r,Al(e)),ce=(r,e,t)=>is(r,typeof e!="symbol"?e+"":e,t);class vt{constructor(e){ce(this,"client"),ce(this,"namespaces"),ce(this,"optionalNamespaces"),ce(this,"sessionProperties"),ce(this,"scopedProperties"),ce(this,"events",new(Pt())),ce(this,"rpcProviders",{}),ce(this,"session"),ce(this,"providerOpts"),ce(this,"logger"),ce(this,"uri"),ce(this,"disableProviderPing",!1),this.providerOpts=e,this.logger=typeof(e==null?void 0:e.logger)<"u"&&typeof(e==null?void 0:e.logger)!="string"?e.logger:(0,O.gw)((0,O.jI)({level:(e==null?void 0:e.logger)||ci})),this.disableProviderPing=(e==null?void 0:e.disableProviderPing)||!1}static async init(e){const t=new vt(e);return await t.initialize(),t}async request(e,t,s){const[i,o]=this.validateChain(t);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(i).request({request:wt({},e),chainId:`${i}:${o}`,topic:this.session.topic,expiry:s})}sendAsync(e,t,s,i){const o=new Date().getTime();this.request(e,s,i).then(a=>t(null,(0,P.formatJsonRpcResult)(o,a))).catch(a=>t(a,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:(0,c.D6H)("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(e),this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}async authenticate(e,t){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(e),await this.cleanupPendingPairings();const{uri:s,response:i}=await this.client.authenticate(e,t);s&&(this.uri=s,this.events.emit("display_uri",s));const o=await i();if(this.session=o.session,this.session){const a=xi(this.session.namespaces);this.namespaces=ft(this.namespaces,a),await this.persist("namespaces",this.namespaces),this.onConnect()}return o}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}removeListener(e,t){this.events.removeListener(e,t)}off(e,t){this.events.off(e,t)}get isWalletConnect(){return!0}async pair(e){const{uri:t,approval:s}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});t&&(this.uri=t,this.events.emit("display_uri",t));const i=await s();this.session=i;const o=xi(i.namespaces);return this.namespaces=ft(this.namespaces,o),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(e,t){try{if(!this.session)return;const[s,i]=this.validateChain(e);this.getProvider(s).setDefaultChain(i,t)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(e={}){try{this.logger.info("Cleaning up inactive pairings...");const t=this.client.pairing.getAll();if(!(0,c.qt8)(t))return;for(const s of t)e.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${t.length}`)}catch(t){this.logger.warn("Failed to cleanup pending pairings",t)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var e,t;if(this.client=this.providerOpts.client||await Vt.init({core:this.providerOpts.core,logger:this.providerOpts.logger||ci,relayUrl:this.providerOpts.relayUrl||Mc,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(s){throw this.logger.error("Failed to get session",s),new Error(`The provided session: ${(t=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:t.topic} doesn't exist in the Sign client`)}else{const s=this.client.session.getAll();this.session=s[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const e=[...new Set(Object.keys(this.session.namespaces).map(t=>(0,c.Maj)(t)))];Wt("client",this.client),Wt("events",this.events),Wt("disableProviderPing",this.disableProviderPing),e.forEach(t=>{if(!this.session)return;const s=Ph(t,this.session);if((s==null?void 0:s.length)===0)return;const i=Ii(s),o=ft(this.namespaces,this.optionalNamespaces),a=rs(wt({},o[t]),{accounts:s,chains:i});switch(t){case"eip155":this.rpcProviders[t]=new tl({namespace:a});break;case"algorand":this.rpcProviders[t]=new ll({namespace:a});break;case"solana":this.rpcProviders[t]=new rl({namespace:a});break;case"cosmos":this.rpcProviders[t]=new al({namespace:a});break;case"polkadot":this.rpcProviders[t]=new Qh({namespace:a});break;case"cip34":this.rpcProviders[t]=new ul({namespace:a});break;case"elrond":this.rpcProviders[t]=new ml({namespace:a});break;case"multiversx":this.rpcProviders[t]=new vl({namespace:a});break;case"near":this.rpcProviders[t]=new Il({namespace:a});break;case"tezos":this.rpcProviders[t]=new Sl({namespace:a});break;default:this.rpcProviders[t]=new Ol({namespace:a})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{var t;const{topic:s}=e;s===((t=this.session)==null?void 0:t.topic)&&this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{var t;const{params:s,topic:i}=e;if(i!==((t=this.session)==null?void 0:t.topic))return;const{event:o}=s;if(o.name==="accountsChanged"){const a=o.data;a&&(0,c.qt8)(a)&&this.events.emit("accountsChanged",a.map(Si))}else if(o.name==="chainChanged"){const a=s.chainId,h=s.event.data,p=(0,c.Maj)(a),d=Qt(a)!==Qt(h)?`${p}:${Qt(h)}`:a;this.onChainChanged(d)}else this.events.emit(o.name,o.data);this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:t})=>{var s,i;if(e!==((s=this.session)==null?void 0:s.topic))return;const{namespaces:o}=t,a=(i=this.client)==null?void 0:i.session.get(e);this.session=rs(wt({},a),{namespaces:o}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:t})}),this.client.on("session_delete",async e=>{var t;e.topic===((t=this.session)==null?void 0:t.topic)&&(await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",rs(wt({},(0,c.D6H)("USER_DISCONNECTED")),{data:e.topic})))}),this.on(ae.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(e,!0)})}getProvider(e){return this.rpcProviders[e]||this.rpcProviders[li]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var t;this.getProvider(e).updateNamespace((t=this.session)==null?void 0:t.namespaces[e])})}setNamespaces(e){const{namespaces:t={},optionalNamespaces:s={},sessionProperties:i,scopedProperties:o}=e;this.optionalNamespaces=ft(t,s),this.sessionProperties=i,this.scopedProperties=o}validateChain(e){const[t,s]=(e==null?void 0:e.split(":"))||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[t,s];if(t&&!Object.keys(this.namespaces||{}).map(a=>(0,c.Maj)(a)).includes(t))throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);if(t&&s)return[t,s];const i=(0,c.Maj)(Object.keys(this.namespaces)[0]),o=this.rpcProviders[i].getDefaultChain();return[i,o]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}async onChainChanged(e,t=!1){if(!this.namespaces)return;const[s,i]=this.validateChain(e);if(!i)return;this.updateNamespaceChain(s,i);const o=this.getProvider(s).getDefaultChain();t?(this.events.emit("chainChanged",i),this.emitAccountsChangedOnChainChange({namespace:s,previousChainId:o,newChainId:e})):this.getProvider(s).setDefaultChain(i),await this.persist("namespaces",this.namespaces)}emitAccountsChangedOnChainChange({namespace:e,previousChainId:t,newChainId:s}){var i,o;try{if(t===s)return;const a=(o=(i=this.session)==null?void 0:i.namespaces[e])==null?void 0:o.accounts;if(!a)return;const h=a.filter(p=>p.includes(`${s}:`)).map(Si);if(!(0,c.qt8)(h))return;this.events.emit("accountsChanged",h)}catch(a){this.logger.warn("Failed to emit accountsChanged on chain change",a)}}updateNamespaceChain(e,t){if(!this.namespaces)return;const s=this.namespaces[e]?e:`${e}:${t}`,i={chains:[],methods:[],events:[],defaultChain:t};this.namespaces[s]?this.namespaces[s]&&(this.namespaces[s].defaultChain=t):this.namespaces[s]=i}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(e,t){var s;const i=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.setItem(`${yt}/${e}${i}`,t)}async getFromStore(e){var t;const s=((t=this.session)==null?void 0:t.topic)||"";return await this.client.core.storage.getItem(`${yt}/${e}${s}`)}async deleteFromStore(e){var t;const s=((t=this.session)==null?void 0:t.topic)||"";await this.client.core.storage.removeItem(`${yt}/${e}${s}`)}async cleanupStorage(){var e;try{if(((e=this.client)==null?void 0:e.session.length)>0)return;const t=await this.client.core.storage.getKeys();for(const s of t)s.startsWith(yt)&&await this.client.core.storage.removeItem(s)}catch(t){this.logger.warn("Failed to cleanup storage",t)}}}const Fl=vt}}]);
