"use strict";(self.webpackChunk_ant_design_web3_docs=self.webpackChunk_ant_design_web3_docs||[]).push([[8452],{98452:function(hx,Id,q){q.d(Id,{EthereumProvider:function(){return tx}});var pt=q(72100),hn=q.n(pt),Pd=q(81365),D=q(46196),zt=q(73079),Sd=q(42669);const so="2.23.2";let ci={getDocsUrl:({docsBaseUrl:i,docsPath:e="",docsSlug:t})=>e?`${i??"https://viem.sh"}${e}${t?`#${t}`:""}`:void 0,version:`viem@${so}`};function dx(i){ci=i}class Ht extends Error{constructor(e,t={}){var c;const s=(()=>{var h;return t.cause instanceof Ht?t.cause.details:(h=t.cause)!=null&&h.message?t.cause.message:t.details})(),r=t.cause instanceof Ht&&t.cause.docsPath||t.docsPath,o=(c=ci.getDocsUrl)==null?void 0:c.call(ci,{...t,docsPath:r}),a=[e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...o?[`Docs: ${o}`]:[],...s?[`Details: ${s}`]:[],...ci.version?[`Version: ${ci.version}`]:[]].join(`
`);super(a,t.cause?{cause:t.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=s,this.docsPath=r,this.metaMessages=t.metaMessages,this.name=t.name??this.name,this.shortMessage=e,this.version=so}walk(e){return no(this,e)}}function no(i,e){return e!=null&&e(i)?i:i&&typeof i=="object"&&"cause"in i&&i.cause!==void 0?no(i.cause,e):e?null:i}function Wi(i,{strict:e=!0}={}){return!i||typeof i!="string"?!1:e?/^0x[0-9a-fA-F]*$/.test(i):i.startsWith("0x")}class lx extends null{constructor({offset:e,position:t,size:s}){super(`Slice ${t==="start"?"starting":"ending"} at offset "${e}" is out-of-bounds (size: ${s}).`,{name:"SliceOffsetOutOfBoundsError"})}}class ro extends Ht{constructor({size:e,targetSize:t,type:s}){super(`${s.charAt(0).toUpperCase()}${s.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`,{name:"SizeExceedsPaddingSizeError"})}}class ux extends null{constructor({size:e,targetSize:t,type:s}){super(`${s.charAt(0).toUpperCase()}${s.slice(1).toLowerCase()} is expected to be ${t} ${s} long, but is ${e} ${s} long.`,{name:"InvalidBytesLengthError"})}}function hi(i,{dir:e,size:t=32}={}){return typeof i=="string"?Od(i,{dir:e,size:t}):Ad(i,{dir:e,size:t})}function Od(i,{dir:e,size:t=32}={}){if(t===null)return i;const s=i.replace("0x","");if(s.length>t*2)throw new ro({size:Math.ceil(s.length/2),targetSize:t,type:"hex"});return`0x${s[e==="right"?"padEnd":"padStart"](t*2,"0")}`}function Ad(i,{dir:e,size:t=32}={}){if(t===null)return i;if(i.length>t)throw new ro({size:i.length,targetSize:t,type:"bytes"});const s=new Uint8Array(t);for(let r=0;r<t;r++){const o=e==="right";s[o?r:t-r-1]=i[o?r:i.length-r-1]}return s}class Cd extends Ht{constructor({max:e,min:t,signed:s,size:r,value:o}){super(`Number "${o}" is not in safe ${r?`${r*8}-bit ${s?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`,{name:"IntegerOutOfRangeError"})}}class px extends null{constructor(e){super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,{name:"InvalidBytesBooleanError"})}}class gx extends null{constructor(e){super(`Hex value "${e}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`,{name:"InvalidHexBooleanError"})}}class fx extends null{constructor(e){super(`Hex value "${e}" is an odd length (${e.length}). It must be an even length.`,{name:"InvalidHexValueError"})}}class Rd extends Ht{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`,{name:"SizeOverflowError"})}}function oo(i){return Wi(i,{strict:!1})?Math.ceil((i.length-2)/2):i.length}function Nt(i,{size:e}){if(oo(i)>e)throw new Rd({givenSize:oo(i),maxSize:e})}function yx(i,e){const t=typeof e=="string"?{to:e}:e,s=t.to;return s==="number"?ao(i,t):s==="bigint"?bs(i,t):s==="string"?Nd(i,t):s==="boolean"?Fd(i,t):hexToBytes(i,t)}function bs(i,e={}){const{signed:t}=e;e.size&&Nt(i,{size:e.size});const s=BigInt(i);if(!t)return s;const r=(i.length-2)/2,o=(1n<<BigInt(r)*8n-1n)-1n;return s<=o?s:s-BigInt(`0x${"f".padStart(r*2,"f")}`)-1n}function Fd(i,e={}){let t=i;if(e.size&&(Nt(t,{size:e.size}),t=trim(t)),trim(t)==="0x00")return!1;if(trim(t)==="0x01")return!0;throw new InvalidHexBooleanError(t)}function ao(i,e={}){return Number(bs(i,e))}function Nd(i,e={}){let t=hexToBytes(i);return e.size&&(Nt(t,{size:e.size}),t=trim(t,{dir:"right"})),new TextDecoder().decode(t)}const Td=Array.from({length:256},(i,e)=>e.toString(16).padStart(2,"0"));function dn(i,e={}){return typeof i=="number"||typeof i=="bigint"?ho(i,e):typeof i=="string"?$d(i,e):typeof i=="boolean"?Bd(i,e):co(i,e)}function Bd(i,e={}){const t=`0x${Number(i)}`;return typeof e.size=="number"?(Nt(t,{size:e.size}),hi(t,{size:e.size})):t}function co(i,e={}){let t="";for(let r=0;r<i.length;r++)t+=Td[i[r]];const s=`0x${t}`;return typeof e.size=="number"?(Nt(s,{size:e.size}),hi(s,{dir:"right",size:e.size})):s}function ho(i,e={}){const{signed:t,size:s}=e,r=BigInt(i);let o;s?t?o=(1n<<BigInt(s)*8n-1n)-1n:o=2n**(BigInt(s)*8n)-1n:typeof i=="number"&&(o=BigInt(Number.MAX_SAFE_INTEGER));const a=typeof o=="bigint"&&t?-o-1n:0;if(o&&r>o||r<a){const h=typeof i=="bigint"?"n":"";throw new Cd({max:o?`${o}${h}`:void 0,min:`${a}${h}`,signed:t,size:s,value:`${i}${h}`})}const c=`0x${(t&&r<0?(1n<<BigInt(s*8))+BigInt(r):r).toString(16)}`;return s?hi(c,{size:s}):c}const Dd=new TextEncoder;function $d(i,e={}){const t=Dd.encode(i);return co(t,e)}const jd=new TextEncoder;function qd(i,e={}){return typeof i=="number"||typeof i=="bigint"?Ld(i,e):typeof i=="boolean"?Ud(i,e):Wi(i)?uo(i,e):po(i,e)}function Ud(i,e={}){const t=new Uint8Array(1);return t[0]=Number(i),typeof e.size=="number"?(Nt(t,{size:e.size}),hi(t,{size:e.size})):t}const vt={zero:48,nine:57,A:65,F:70,a:97,f:102};function lo(i){if(i>=vt.zero&&i<=vt.nine)return i-vt.zero;if(i>=vt.A&&i<=vt.F)return i-(vt.A-10);if(i>=vt.a&&i<=vt.f)return i-(vt.a-10)}function uo(i,e={}){let t=i;e.size&&(Nt(t,{size:e.size}),t=hi(t,{dir:"right",size:e.size}));let s=t.slice(2);s.length%2&&(s=`0${s}`);const r=s.length/2,o=new Uint8Array(r);for(let a=0,c=0;a<r;a++){const h=lo(s.charCodeAt(c++)),d=lo(s.charCodeAt(c++));if(h===void 0||d===void 0)throw new Ht(`Invalid byte sequence ("${s[c-2]}${s[c-1]}" in "${s}").`);o[a]=h*16+d}return o}function Ld(i,e){const t=ho(i,e);return uo(t)}function po(i,e={}){const t=jd.encode(i);return typeof e.size=="number"?(Nt(t,{size:e.size}),hi(t,{dir:"right",size:e.size})):t}var kd=q(51433);function go(i,e){const t=e||"hex",s=(0,kd.fr)(Wi(i,{strict:!1})?qd(i):i);return t==="bytes"?s:dn(s)}class Md extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}get(e){const t=super.get(e);return super.has(e)&&t!==void 0&&(this.delete(e),super.set(e,t)),t}set(e,t){if(super.set(e,t),this.maxSize&&this.size>this.maxSize){const s=this.keys().next().value;s&&this.delete(s)}return this}}const ln=new Md(8192);function fo(i,e){if(ln.has(`${i}.${e}`))return ln.get(`${i}.${e}`);const t=e?`${e}${i.toLowerCase()}`:i.substring(2).toLowerCase(),s=go(po(t),"bytes"),r=(e?t.substring(`${e}0x`.length):t).split("");for(let a=0;a<40;a+=2)s[a>>1]>>4>=8&&r[a]&&(r[a]=r[a].toUpperCase()),(s[a>>1]&15)>=8&&r[a+1]&&(r[a+1]=r[a+1].toUpperCase());const o=`0x${r.join("")}`;return ln.set(`${i}.${e}`,o),o}function _x(i,e){if(!isAddress(i,{strict:!1}))throw new InvalidAddressError({address:i});return fo(i,e)}function zd(i){const e=go(`0x${i.substring(4)}`).substring(26);return fo(`0x${e}`)}async function Hd({hash:i,signature:e}){const t=Wi(i)?i:dn(i),{secp256k1:s}=await Promise.resolve().then(q.bind(q,85720));return`0x${(()=>{if(typeof e=="object"&&"r"in e&&"s"in e){const{r:d,s:u,v:p,yParity:g}=e,_=Number(g??p),f=yo(_);return new s.Signature(bs(d),bs(u)).addRecoveryBit(f)}const a=Wi(e)?e:dn(e),c=ao(`0x${a.slice(130)}`),h=yo(c);return s.Signature.fromCompact(a.substring(2,130)).addRecoveryBit(h)})().recoverPublicKey(t.substring(2)).toHex(!1)}`}function yo(i){if(i===0||i===1)return i;if(i===27)return 0;if(i===28)return 1;throw new Error("Invalid yParityOrV value")}async function Vd({hash:i,signature:e}){return zd(await Hd({hash:i,signature:e}))}var Kd=q(36095),st=q(41926);function Gd(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function _o(i,...e){if(!Gd(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function mo(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function Wd(i,e){_o(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const di=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;const un=i=>new DataView(i.buffer,i.byteOffset,i.byteLength);function Jd(i){if(typeof i!="string")throw new Error("utf8ToBytes expected string, got "+typeof i);return new Uint8Array(new TextEncoder().encode(i))}function wo(i){return typeof i=="string"&&(i=Jd(i)),_o(i),i}class Zd{clone(){return this._cloneInto()}}function Yd(i){const e=s=>i().update(wo(s)).digest(),t=i();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>i(),e}function bo(i=32){if(di&&typeof di.getRandomValues=="function")return di.getRandomValues(new Uint8Array(i));if(di&&typeof di.randomBytes=="function")return di.randomBytes(i);throw new Error("crypto.getRandomValues must be defined")}function Qd(i,e,t,s){if(typeof i.setBigUint64=="function")return i.setBigUint64(e,t,s);const r=BigInt(32),o=BigInt(4294967295),a=Number(t>>r&o),c=Number(t&o),h=s?4:0,d=s?0:4;i.setUint32(e+h,a,s),i.setUint32(e+d,c,s)}class Xd extends Zd{constructor(e,t,s,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=s,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=un(this.buffer)}update(e){mo(this);const{view:t,buffer:s,blockLen:r}=this;e=wo(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(r-this.pos,o-a);if(c===r){const h=un(e);for(;r<=o-a;a+=r)this.process(h,a);continue}s.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){mo(this),Wd(e,this),this.finished=!0;const{buffer:t,view:s,blockLen:r,isLE:o}=this;let{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>r-a&&(this.process(s,0),a=0);for(let p=a;p<r;p++)t[p]=0;Qd(s,r-8,BigInt(this.length*8),o),this.process(s,0);const c=un(e),h=this.outputLen;if(h%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=h/4,u=this.get();if(d>u.length)throw new Error("_sha2: outputLen bigger than state");for(let p=0;p<d;p++)c.setUint32(4*p,u[p],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:s,length:r,finished:o,destroyed:a,pos:c}=this;return e.length=r,e.pos=c,e.finished=o,e.destroyed=a,r%t&&e.buffer.set(s),e}}const vs=BigInt(2**32-1),pn=BigInt(32);function vo(i,e=!1){return e?{h:Number(i&vs),l:Number(i>>pn&vs)}:{h:Number(i>>pn&vs)|0,l:Number(i&vs)|0}}function el(i,e=!1){let t=new Uint32Array(i.length),s=new Uint32Array(i.length);for(let r=0;r<i.length;r++){const{h:o,l:a}=vo(i[r],e);[t[r],s[r]]=[o,a]}return[t,s]}const tl=(i,e)=>BigInt(i>>>0)<<pn|BigInt(e>>>0),il=(i,e,t)=>i>>>t,sl=(i,e,t)=>i<<32-t|e>>>t,nl=(i,e,t)=>i>>>t|e<<32-t,rl=(i,e,t)=>i<<32-t|e>>>t,ol=(i,e,t)=>i<<64-t|e>>>t-32,al=(i,e,t)=>i>>>t-32|e<<64-t,cl=(i,e)=>e,hl=(i,e)=>i,dl=(i,e,t)=>i<<t|e>>>32-t,ll=(i,e,t)=>e<<t|i>>>32-t,ul=(i,e,t)=>e<<t-32|i>>>64-t,pl=(i,e,t)=>i<<t-32|e>>>64-t;function gl(i,e,t,s){const r=(e>>>0)+(s>>>0);return{h:i+t+(r/2**32|0)|0,l:r|0}}const fl=(i,e,t)=>(i>>>0)+(e>>>0)+(t>>>0),yl=(i,e,t,s)=>e+t+s+(i/2**32|0)|0,_l=(i,e,t,s)=>(i>>>0)+(e>>>0)+(t>>>0)+(s>>>0),ml=(i,e,t,s,r)=>e+t+s+r+(i/2**32|0)|0,wl=(i,e,t,s,r)=>(i>>>0)+(e>>>0)+(t>>>0)+(s>>>0)+(r>>>0),bl=(i,e,t,s,r,o)=>e+t+s+r+o+(i/2**32|0)|0,W={fromBig:vo,split:el,toBig:tl,shrSH:il,shrSL:sl,rotrSH:nl,rotrSL:rl,rotrBH:ol,rotrBL:al,rotr32H:cl,rotr32L:hl,rotlSH:dl,rotlSL:ll,rotlBH:ul,rotlBL:pl,add:gl,add3L:fl,add3H:yl,add4L:_l,add4H:ml,add5H:bl,add5L:wl},[vl,xl]=W.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(i=>BigInt(i))),Tt=new Uint32Array(80),Bt=new Uint32Array(80);class El extends Xd{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:s,Bl:r,Ch:o,Cl:a,Dh:c,Dl:h,Eh:d,El:u,Fh:p,Fl:g,Gh:_,Gl:f,Hh:y,Hl:m}=this;return[e,t,s,r,o,a,c,h,d,u,p,g,_,f,y,m]}set(e,t,s,r,o,a,c,h,d,u,p,g,_,f,y,m){this.Ah=e|0,this.Al=t|0,this.Bh=s|0,this.Bl=r|0,this.Ch=o|0,this.Cl=a|0,this.Dh=c|0,this.Dl=h|0,this.Eh=d|0,this.El=u|0,this.Fh=p|0,this.Fl=g|0,this.Gh=_|0,this.Gl=f|0,this.Hh=y|0,this.Hl=m|0}process(e,t){for(let x=0;x<16;x++,t+=4)Tt[x]=e.getUint32(t),Bt[x]=e.getUint32(t+=4);for(let x=16;x<80;x++){const P=Tt[x-15]|0,R=Bt[x-15]|0,A=W.rotrSH(P,R,1)^W.rotrSH(P,R,8)^W.shrSH(P,R,7),C=W.rotrSL(P,R,1)^W.rotrSL(P,R,8)^W.shrSL(P,R,7),B=Tt[x-2]|0,S=Bt[x-2]|0,H=W.rotrSH(B,S,19)^W.rotrBH(B,S,61)^W.shrSH(B,S,6),U=W.rotrSL(B,S,19)^W.rotrBL(B,S,61)^W.shrSL(B,S,6),k=W.add4L(C,U,Bt[x-7],Bt[x-16]),V=W.add4H(k,A,H,Tt[x-7],Tt[x-16]);Tt[x]=V|0,Bt[x]=k|0}let{Ah:s,Al:r,Bh:o,Bl:a,Ch:c,Cl:h,Dh:d,Dl:u,Eh:p,El:g,Fh:_,Fl:f,Gh:y,Gl:m,Hh:v,Hl:w}=this;for(let x=0;x<80;x++){const P=W.rotrSH(p,g,14)^W.rotrSH(p,g,18)^W.rotrBH(p,g,41),R=W.rotrSL(p,g,14)^W.rotrSL(p,g,18)^W.rotrBL(p,g,41),A=p&_^~p&y,C=g&f^~g&m,B=W.add5L(w,R,C,xl[x],Bt[x]),S=W.add5H(B,v,P,A,vl[x],Tt[x]),H=B|0,U=W.rotrSH(s,r,28)^W.rotrBH(s,r,34)^W.rotrBH(s,r,39),k=W.rotrSL(s,r,28)^W.rotrBL(s,r,34)^W.rotrBL(s,r,39),V=s&o^s&c^o&c,N=r&a^r&h^a&h;v=y|0,w=m|0,y=_|0,m=f|0,_=p|0,f=g|0,{h:p,l:g}=W.add(d|0,u|0,S|0,H|0),d=c|0,u=h|0,c=o|0,h=a|0,o=s|0,a=r|0;const E=W.add3L(H,k,N);s=W.add3H(E,S,U,V),r=E|0}({h:s,l:r}=W.add(this.Ah|0,this.Al|0,s|0,r|0)),{h:o,l:a}=W.add(this.Bh|0,this.Bl|0,o|0,a|0),{h:c,l:h}=W.add(this.Ch|0,this.Cl|0,c|0,h|0),{h:d,l:u}=W.add(this.Dh|0,this.Dl|0,d|0,u|0),{h:p,l:g}=W.add(this.Eh|0,this.El|0,p|0,g|0),{h:_,l:f}=W.add(this.Fh|0,this.Fl|0,_|0,f|0),{h:y,l:m}=W.add(this.Gh|0,this.Gl|0,y|0,m|0),{h:v,l:w}=W.add(this.Hh|0,this.Hl|0,v|0,w|0),this.set(s,r,o,a,c,h,d,u,p,g,_,f,y,m,v,w)}roundClean(){Tt.fill(0),Bt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Il=Yd(()=>new El);const gn=BigInt(0),xo=BigInt(1),Pl=BigInt(2);function fn(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function yn(i){if(!fn(i))throw new Error("Uint8Array expected")}function _n(i,e){if(typeof e!="boolean")throw new Error(i+" boolean expected, got "+e)}const Sl=Array.from({length:256},(i,e)=>e.toString(16).padStart(2,"0"));function mn(i){yn(i);let e="";for(let t=0;t<i.length;t++)e+=Sl[i[t]];return e}function Eo(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);return i===""?gn:BigInt("0x"+i)}const xt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Io(i){if(i>=xt._0&&i<=xt._9)return i-xt._0;if(i>=xt.A&&i<=xt.F)return i-(xt.A-10);if(i>=xt.a&&i<=xt.f)return i-(xt.a-10)}function Po(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);const e=i.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const s=new Uint8Array(t);for(let r=0,o=0;r<t;r++,o+=2){const a=Io(i.charCodeAt(o)),c=Io(i.charCodeAt(o+1));if(a===void 0||c===void 0){const h=i[o]+i[o+1];throw new Error('hex string expected, got non-hex character "'+h+'" at index '+o)}s[r]=a*16+c}return s}function Ol(i){return Eo(mn(i))}function xs(i){return yn(i),Eo(mn(Uint8Array.from(i).reverse()))}function So(i,e){return Po(i.toString(16).padStart(e*2,"0"))}function wn(i,e){return So(i,e).reverse()}function Et(i,e,t){let s;if(typeof e=="string")try{s=Po(e)}catch(o){throw new Error(i+" must be hex string or Uint8Array, cause: "+o)}else if(fn(e))s=Uint8Array.from(e);else throw new Error(i+" must be hex string or Uint8Array");const r=s.length;if(typeof t=="number"&&r!==t)throw new Error(i+" of length "+t+" expected, got "+r);return s}function Oo(...i){let e=0;for(let s=0;s<i.length;s++){const r=i[s];yn(r),e+=r.length}const t=new Uint8Array(e);for(let s=0,r=0;s<i.length;s++){const o=i[s];t.set(o,r),r+=o.length}return t}const bn=i=>typeof i=="bigint"&&gn<=i;function Al(i,e,t){return bn(i)&&bn(e)&&bn(t)&&e<=i&&i<t}function Ji(i,e,t,s){if(!Al(e,t,s))throw new Error("expected valid "+i+": "+t+" <= n < "+s+", got "+e)}function Cl(i){let e;for(e=0;i>gn;i>>=xo,e+=1);return e}const Rl=i=>(Pl<<BigInt(i-1))-xo,Fl={bigint:i=>typeof i=="bigint",function:i=>typeof i=="function",boolean:i=>typeof i=="boolean",string:i=>typeof i=="string",stringOrUint8Array:i=>typeof i=="string"||fn(i),isSafeInteger:i=>Number.isSafeInteger(i),array:i=>Array.isArray(i),field:(i,e)=>e.Fp.isValid(i),hash:i=>typeof i=="function"&&Number.isSafeInteger(i.outputLen)};function vn(i,e,t={}){const s=(r,o,a)=>{const c=Fl[o];if(typeof c!="function")throw new Error("invalid validator function");const h=i[r];if(!(a&&h===void 0)&&!c(h,i))throw new Error("param "+String(r)+" is invalid. Expected "+o+", got "+h)};for(const[r,o]of Object.entries(e))s(r,o,!1);for(const[r,o]of Object.entries(t))s(r,o,!0);return i}function Ao(i){const e=new WeakMap;return(t,...s)=>{const r=e.get(t);if(r!==void 0)return r;const o=i(t,...s);return e.set(t,o),o}}const be=BigInt(0),ge=BigInt(1),Vt=BigInt(2),Nl=BigInt(3),xn=BigInt(4),Co=BigInt(5),Ro=BigInt(8);function me(i,e){const t=i%e;return t>=be?t:e+t}function Tl(i,e,t){if(e<be)throw new Error("invalid exponent, negatives unsupported");if(t<=be)throw new Error("invalid modulus");if(t===ge)return be;let s=ge;for(;e>be;)e&ge&&(s=s*i%t),i=i*i%t,e>>=ge;return s}function gt(i,e,t){let s=i;for(;e-- >be;)s*=s,s%=t;return s}function Fo(i,e){if(i===be)throw new Error("invert: expected non-zero number");if(e<=be)throw new Error("invert: expected positive modulus, got "+e);let t=me(i,e),s=e,r=be,o=ge;for(;t!==be;){const a=s/t,c=s%t,h=r-o*a;s=t,t=c,r=o,o=h}if(s!==ge)throw new Error("invert: does not exist");return me(r,e)}function Bl(i){const e=(i-ge)/Vt;let t,s,r;for(t=i-ge,s=0;t%Vt===be;t/=Vt,s++);for(r=Vt;r<i&&Tl(r,e,i)!==i-ge;r++)if(r>1e3)throw new Error("Cannot find square root: likely non-prime P");if(s===1){const a=(i+ge)/xn;return function(c,h){const d=c.pow(h,a);if(!c.eql(c.sqr(d),h))throw new Error("Cannot find square root");return d}}const o=(t+ge)/Vt;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let h=s,d=a.pow(a.mul(a.ONE,r),t),u=a.pow(c,o),p=a.pow(c,t);for(;!a.eql(p,a.ONE);){if(a.eql(p,a.ZERO))return a.ZERO;let g=1;for(let f=a.sqr(p);g<h&&!a.eql(f,a.ONE);g++)f=a.sqr(f);const _=a.pow(d,ge<<BigInt(h-g-1));d=a.sqr(_),u=a.mul(u,_),p=a.mul(p,d),h=g}return u}}function Dl(i){if(i%xn===Nl){const e=(i+ge)/xn;return function(t,s){const r=t.pow(s,e);if(!t.eql(t.sqr(r),s))throw new Error("Cannot find square root");return r}}if(i%Ro===Co){const e=(i-Co)/Ro;return function(t,s){const r=t.mul(s,Vt),o=t.pow(r,e),a=t.mul(s,o),c=t.mul(t.mul(a,Vt),o),h=t.mul(a,t.sub(c,t.ONE));if(!t.eql(t.sqr(h),s))throw new Error("Cannot find square root");return h}}return Bl(i)}const $l=(i,e)=>(me(i,e)&ge)===ge,jl=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ql(i){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=jl.reduce((s,r)=>(s[r]="function",s),e);return vn(i,t)}function Ul(i,e,t){if(t<be)throw new Error("invalid exponent, negatives unsupported");if(t===be)return i.ONE;if(t===ge)return e;let s=i.ONE,r=e;for(;t>be;)t&ge&&(s=i.mul(s,r)),r=i.sqr(r),t>>=ge;return s}function Ll(i,e){const t=new Array(e.length),s=e.reduce((o,a,c)=>i.is0(a)?o:(t[c]=o,i.mul(o,a)),i.ONE),r=i.inv(s);return e.reduceRight((o,a,c)=>i.is0(a)?o:(t[c]=i.mul(o,t[c]),i.mul(o,a)),r),t}function No(i,e){const t=e!==void 0?e:i.toString(2).length,s=Math.ceil(t/8);return{nBitLength:t,nByteLength:s}}function To(i,e,t=!1,s={}){if(i<=be)throw new Error("invalid field: expected ORDER > 0, got "+i);const{nBitLength:r,nByteLength:o}=No(i,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const c=Object.freeze({ORDER:i,isLE:t,BITS:r,BYTES:o,MASK:Rl(r),ZERO:be,ONE:ge,create:h=>me(h,i),isValid:h=>{if(typeof h!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof h);return be<=h&&h<i},is0:h=>h===be,isOdd:h=>(h&ge)===ge,neg:h=>me(-h,i),eql:(h,d)=>h===d,sqr:h=>me(h*h,i),add:(h,d)=>me(h+d,i),sub:(h,d)=>me(h-d,i),mul:(h,d)=>me(h*d,i),pow:(h,d)=>Ul(c,h,d),div:(h,d)=>me(h*Fo(d,i),i),sqrN:h=>h*h,addN:(h,d)=>h+d,subN:(h,d)=>h-d,mulN:(h,d)=>h*d,inv:h=>Fo(h,i),sqrt:s.sqrt||(h=>(a||(a=Dl(i)),a(c,h))),invertBatch:h=>Ll(c,h),cmov:(h,d,u)=>u?d:h,toBytes:h=>t?wn(h,o):So(h,o),fromBytes:h=>{if(h.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+h.length);return t?xs(h):Ol(h)}});return Object.freeze(c)}const Bo=BigInt(0),Es=BigInt(1);function En(i,e){const t=e.negate();return i?t:e}function Do(i,e){if(!Number.isSafeInteger(i)||i<=0||i>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+i)}function In(i,e){Do(i,e);const t=Math.ceil(e/i)+1,s=2**(i-1);return{windows:t,windowSize:s}}function kl(i,e){if(!Array.isArray(i))throw new Error("array expected");i.forEach((t,s)=>{if(!(t instanceof e))throw new Error("invalid point at index "+s)})}function Ml(i,e){if(!Array.isArray(i))throw new Error("array of scalars expected");i.forEach((t,s)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+s)})}const Pn=new WeakMap,$o=new WeakMap;function Sn(i){return $o.get(i)||1}function zl(i,e){return{constTimeNegate:En,hasPrecomputes(t){return Sn(t)!==1},unsafeLadder(t,s,r=i.ZERO){let o=t;for(;s>Bo;)s&Es&&(r=r.add(o)),o=o.double(),s>>=Es;return r},precomputeWindow(t,s){const{windows:r,windowSize:o}=In(s,e),a=[];let c=t,h=c;for(let d=0;d<r;d++){h=c,a.push(h);for(let u=1;u<o;u++)h=h.add(c),a.push(h);c=h.double()}return a},wNAF(t,s,r){const{windows:o,windowSize:a}=In(t,e);let c=i.ZERO,h=i.BASE;const d=BigInt(2**t-1),u=2**t,p=BigInt(t);for(let g=0;g<o;g++){const _=g*a;let f=Number(r&d);r>>=p,f>a&&(f-=u,r+=Es);const y=_,m=_+Math.abs(f)-1,v=g%2!==0,w=f<0;f===0?h=h.add(En(v,s[y])):c=c.add(En(w,s[m]))}return{p:c,f:h}},wNAFUnsafe(t,s,r,o=i.ZERO){const{windows:a,windowSize:c}=In(t,e),h=BigInt(2**t-1),d=2**t,u=BigInt(t);for(let p=0;p<a;p++){const g=p*c;if(r===Bo)break;let _=Number(r&h);if(r>>=u,_>c&&(_-=d,r+=Es),_===0)continue;let f=s[g+Math.abs(_)-1];_<0&&(f=f.negate()),o=o.add(f)}return o},getPrecomputes(t,s,r){let o=Pn.get(s);return o||(o=this.precomputeWindow(s,t),t!==1&&Pn.set(s,r(o))),o},wNAFCached(t,s,r){const o=Sn(t);return this.wNAF(o,this.getPrecomputes(o,t,r),s)},wNAFCachedUnsafe(t,s,r,o){const a=Sn(t);return a===1?this.unsafeLadder(t,s,o):this.wNAFUnsafe(a,this.getPrecomputes(a,t,r),s,o)},setWindowSize(t,s){Do(s,e),$o.set(t,s),Pn.delete(t)}}}function Hl(i,e,t,s){if(kl(t,i),Ml(s,e),t.length!==s.length)throw new Error("arrays of points and scalars must have equal length");const r=i.ZERO,o=Cl(BigInt(t.length)),a=o>12?o-3:o>4?o-2:o?2:1,c=(1<<a)-1,h=new Array(c+1).fill(r),d=Math.floor((e.BITS-1)/a)*a;let u=r;for(let p=d;p>=0;p-=a){h.fill(r);for(let _=0;_<s.length;_++){const f=s[_],y=Number(f>>BigInt(p)&BigInt(c));h[y]=h[y].add(t[_])}let g=r;for(let _=h.length-1,f=r;_>0;_--)f=f.add(h[_]),g=g.add(f);if(u=u.add(g),p!==0)for(let _=0;_<a;_++)u=u.double()}return u}function Vl(i){return ql(i.Fp),vn(i,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...No(i.n,i.nBitLength),...i,p:i.Fp.ORDER})}const nt=BigInt(0),Ue=BigInt(1),Is=BigInt(2),Kl=BigInt(8),Gl={zip215:!0};function Wl(i){const e=Vl(i);return vn(i,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Jl(i){const e=Wl(i),{Fp:t,n:s,prehash:r,hash:o,randomBytes:a,nByteLength:c,h}=e,d=Is<<BigInt(c*8)-Ue,u=t.create,p=To(e.n,e.nBitLength),g=e.uvRatio||((E,b)=>{try{return{isValid:!0,value:t.sqrt(E*t.inv(b))}}catch{return{isValid:!1,value:nt}}}),_=e.adjustScalarBytes||(E=>E),f=e.domain||((E,b,O)=>{if(_n("phflag",O),b.length||O)throw new Error("Contexts/pre-hash are not supported");return E});function y(E,b){Ji("coordinate "+E,b,nt,d)}function m(E){if(!(E instanceof x))throw new Error("ExtendedPoint expected")}const v=Ao((E,b)=>{const{ex:O,ey:F,ez:I}=E,j=E.is0();b==null&&(b=j?Kl:t.inv(I));const L=u(O*b),M=u(F*b),K=u(I*b);if(j)return{x:nt,y:Ue};if(K!==Ue)throw new Error("invZ was invalid");return{x:L,y:M}}),w=Ao(E=>{const{a:b,d:O}=e;if(E.is0())throw new Error("bad point: ZERO");const{ex:F,ey:I,ez:j,et:L}=E,M=u(F*F),K=u(I*I),G=u(j*j),J=u(G*G),X=u(M*b),ue=u(G*u(X+K)),ce=u(J+u(O*u(M*K)));if(ue!==ce)throw new Error("bad point: equation left != right (1)");const ne=u(F*I),De=u(j*L);if(ne!==De)throw new Error("bad point: equation left != right (2)");return!0});class x{constructor(b,O,F,I){this.ex=b,this.ey=O,this.ez=F,this.et=I,y("x",b),y("y",O),y("z",F),y("t",I),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(b){if(b instanceof x)throw new Error("extended point not allowed");const{x:O,y:F}=b||{};return y("x",O),y("y",F),new x(O,F,Ue,u(O*F))}static normalizeZ(b){const O=t.invertBatch(b.map(F=>F.ez));return b.map((F,I)=>F.toAffine(O[I])).map(x.fromAffine)}static msm(b,O){return Hl(x,p,b,O)}_setWindowSize(b){A.setWindowSize(this,b)}assertValidity(){w(this)}equals(b){m(b);const{ex:O,ey:F,ez:I}=this,{ex:j,ey:L,ez:M}=b,K=u(O*M),G=u(j*I),J=u(F*M),X=u(L*I);return K===G&&J===X}is0(){return this.equals(x.ZERO)}negate(){return new x(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:b}=e,{ex:O,ey:F,ez:I}=this,j=u(O*O),L=u(F*F),M=u(Is*u(I*I)),K=u(b*j),G=O+F,J=u(u(G*G)-j-L),X=K+L,ue=X-M,ce=K-L,ne=u(J*ue),De=u(X*ce),Te=u(J*ce),qe=u(ue*X);return new x(ne,De,qe,Te)}add(b){m(b);const{a:O,d:F}=e,{ex:I,ey:j,ez:L,et:M}=this,{ex:K,ey:G,ez:J,et:X}=b;if(O===BigInt(-1)){const _d=u((j-I)*(G+K)),md=u((j+I)*(G-K)),io=u(md-_d);if(io===nt)return this.double();const wd=u(L*Is*X),bd=u(M*Is*J),vd=bd+wd,xd=md+_d,Ed=bd-wd,rx=u(vd*io),ox=u(xd*Ed),ax=u(vd*Ed),cx=u(io*xd);return new x(rx,ox,cx,ax)}const ue=u(I*K),ce=u(j*G),ne=u(M*F*X),De=u(L*J),Te=u((I+j)*(K+G)-ue-ce),qe=De-ne,tt=De+ne,it=u(ce-O*ue),Gi=u(Te*qe),ix=u(tt*it),sx=u(Te*it),nx=u(qe*tt);return new x(Gi,ix,nx,sx)}subtract(b){return this.add(b.negate())}wNAF(b){return A.wNAFCached(this,b,x.normalizeZ)}multiply(b){const O=b;Ji("scalar",O,Ue,s);const{p:F,f:I}=this.wNAF(O);return x.normalizeZ([F,I])[0]}multiplyUnsafe(b,O=x.ZERO){const F=b;return Ji("scalar",F,nt,s),F===nt?R:this.is0()||F===Ue?this:A.wNAFCachedUnsafe(this,F,x.normalizeZ,O)}isSmallOrder(){return this.multiplyUnsafe(h).is0()}isTorsionFree(){return A.unsafeLadder(this,s).is0()}toAffine(b){return v(this,b)}clearCofactor(){const{h:b}=e;return b===Ue?this:this.multiplyUnsafe(b)}static fromHex(b,O=!1){const{d:F,a:I}=e,j=t.BYTES;b=Et("pointHex",b,j),_n("zip215",O);const L=b.slice(),M=b[j-1];L[j-1]=M&-129;const K=xs(L),G=O?d:t.ORDER;Ji("pointHex.y",K,nt,G);const J=u(K*K),X=u(J-Ue),ue=u(F*J-I);let{isValid:ce,value:ne}=g(X,ue);if(!ce)throw new Error("Point.fromHex: invalid y coordinate");const De=(ne&Ue)===Ue,Te=(M&128)!==0;if(!O&&ne===nt&&Te)throw new Error("Point.fromHex: x=0 and x_0=1");return Te!==De&&(ne=u(-ne)),x.fromAffine({x:ne,y:K})}static fromPrivateKey(b){return S(b).point}toRawBytes(){const{x:b,y:O}=this.toAffine(),F=wn(O,t.BYTES);return F[F.length-1]|=b&Ue?128:0,F}toHex(){return mn(this.toRawBytes())}}x.BASE=new x(e.Gx,e.Gy,Ue,u(e.Gx*e.Gy)),x.ZERO=new x(nt,Ue,Ue,nt);const{BASE:P,ZERO:R}=x,A=zl(x,c*8);function C(E){return me(E,s)}function B(E){return C(xs(E))}function S(E){const b=t.BYTES;E=Et("private key",E,b);const O=Et("hashed private key",o(E),2*b),F=_(O.slice(0,b)),I=O.slice(b,2*b),j=B(F),L=P.multiply(j),M=L.toRawBytes();return{head:F,prefix:I,scalar:j,point:L,pointBytes:M}}function H(E){return S(E).pointBytes}function U(E=new Uint8Array,...b){const O=Oo(...b);return B(o(f(O,Et("context",E),!!r)))}function k(E,b,O={}){E=Et("message",E),r&&(E=r(E));const{prefix:F,scalar:I,pointBytes:j}=S(b),L=U(O.context,F,E),M=P.multiply(L).toRawBytes(),K=U(O.context,M,j,E),G=C(L+K*I);Ji("signature.s",G,nt,s);const J=Oo(M,wn(G,t.BYTES));return Et("result",J,t.BYTES*2)}const V=Gl;function N(E,b,O,F=V){const{context:I,zip215:j}=F,L=t.BYTES;E=Et("signature",E,2*L),b=Et("message",b),O=Et("publicKey",O,L),j!==void 0&&_n("zip215",j),r&&(b=r(b));const M=xs(E.slice(L,2*L));let K,G,J;try{K=x.fromHex(O,j),G=x.fromHex(E.slice(0,L),j),J=P.multiplyUnsafe(M)}catch{return!1}if(!j&&K.isSmallOrder())return!1;const X=U(I,G.toRawBytes(),K.toRawBytes(),b);return G.add(K.multiplyUnsafe(X)).subtract(J).clearCofactor().equals(x.ZERO)}return P._setWindowSize(8),{CURVE:e,getPublicKey:H,sign:k,verify:N,ExtendedPoint:x,utils:{getExtendedPublicKey:S,randomPrivateKey:()=>a(t.BYTES),precompute(E=8,b=x.BASE){return b._setWindowSize(E),b.multiply(BigInt(3)),b}}}}BigInt(0),BigInt(1);const An=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),jo=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Zl=BigInt(1),qo=BigInt(2);BigInt(3);const Yl=BigInt(5),Ql=BigInt(8);function Xl(i){const e=BigInt(10),t=BigInt(20),s=BigInt(40),r=BigInt(80),o=An,a=i*i%o*i%o,c=gt(a,qo,o)*a%o,h=gt(c,Zl,o)*i%o,d=gt(h,Yl,o)*h%o,u=gt(d,e,o)*d%o,p=gt(u,t,o)*u%o,g=gt(p,s,o)*p%o,_=gt(g,r,o)*g%o,f=gt(_,r,o)*g%o,y=gt(f,e,o)*d%o;return{pow_p_5_8:gt(y,qo,o)*i%o,b2:a}}function eu(i){return i[0]&=248,i[31]&=127,i[31]|=64,i}function tu(i,e){const t=An,s=me(e*e*e,t),r=me(s*s*e,t),o=Xl(i*r).pow_p_5_8;let a=me(i*s*o,t);const c=me(e*a*a,t),h=a,d=me(a*jo,t),u=c===i,p=c===me(-i,t),g=c===me(-i*jo,t);return u&&(a=h),(p||g)&&(a=d),$l(a,t)&&(a=me(-a,t)),{isValid:u||p,value:a}}const iu=To(An,void 0,!0),su={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:iu,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Ql,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Il,randomBytes:bo,adjustScalarBytes:eu,uvRatio:tu},Cn=Jl(su),Uo="EdDSA",Lo="JWT",Zi=".",Ps="base64url",ko="utf8",Rn="utf8",Mo=":",zo="did",Ho="key",Ss="base58btc",Vo="z",Ko="K36",nu=32,ru=32;function Fn(i){return globalThis.Buffer!=null?new Uint8Array(i.buffer,i.byteOffset,i.byteLength):i}function Go(i=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?Fn(globalThis.Buffer.allocUnsafe(i)):new Uint8Array(i)}function Wo(i,e){e||(e=i.reduce((r,o)=>r+o.length,0));const t=Go(e);let s=0;for(const r of i)t.set(r,s),s+=r.length;return Fn(t)}function ou(i,e){if(i.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),s=0;s<t.length;s++)t[s]=255;for(var r=0;r<i.length;r++){var o=i.charAt(r),a=o.charCodeAt(0);if(t[a]!==255)throw new TypeError(o+" is ambiguous");t[a]=r}var c=i.length,h=i.charAt(0),d=Math.log(c)/Math.log(256),u=Math.log(256)/Math.log(c);function p(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var y=0,m=0,v=0,w=f.length;v!==w&&f[v]===0;)v++,y++;for(var x=(w-v)*u+1>>>0,P=new Uint8Array(x);v!==w;){for(var R=f[v],A=0,C=x-1;(R!==0||A<m)&&C!==-1;C--,A++)R+=256*P[C]>>>0,P[C]=R%c>>>0,R=R/c>>>0;if(R!==0)throw new Error("Non-zero carry");m=A,v++}for(var B=x-m;B!==x&&P[B]===0;)B++;for(var S=h.repeat(y);B<x;++B)S+=i.charAt(P[B]);return S}function g(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;var y=0;if(f[y]!==" "){for(var m=0,v=0;f[y]===h;)m++,y++;for(var w=(f.length-y)*d+1>>>0,x=new Uint8Array(w);f[y];){var P=t[f.charCodeAt(y)];if(P===255)return;for(var R=0,A=w-1;(P!==0||R<v)&&A!==-1;A--,R++)P+=c*x[A]>>>0,x[A]=P%256>>>0,P=P/256>>>0;if(P!==0)throw new Error("Non-zero carry");v=R,y++}if(f[y]!==" "){for(var C=w-v;C!==w&&x[C]===0;)C++;for(var B=new Uint8Array(m+(w-C)),S=m;C!==w;)B[S++]=x[C++];return B}}}function _(f){var y=g(f);if(y)return y;throw new Error(`Non-${e} character`)}return{encode:p,decodeUnsafe:g,decode:_}}var au=ou,cu=au;const Jo=i=>{if(i instanceof Uint8Array&&i.constructor.name==="Uint8Array")return i;if(i instanceof ArrayBuffer)return new Uint8Array(i);if(ArrayBuffer.isView(i))return new Uint8Array(i.buffer,i.byteOffset,i.byteLength);throw new Error("Unknown type, must be binary type")},hu=i=>new TextEncoder().encode(i),du=i=>new TextDecoder().decode(i);class lu{constructor(e,t,s){this.name=e,this.prefix=t,this.baseEncode=s}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class uu{constructor(e,t,s){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=s}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Zo(this,e)}}class pu{constructor(e){this.decoders=e}or(e){return Zo(this,e)}decode(e){const t=e[0],s=this.decoders[t];if(s)return s.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Zo=(i,e)=>new pu({...i.decoders||{[i.prefix]:i},...e.decoders||{[e.prefix]:e}});class gu{constructor(e,t,s,r){this.name=e,this.prefix=t,this.baseEncode=s,this.baseDecode=r,this.encoder=new lu(e,t,s),this.decoder=new uu(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const Os=({name:i,prefix:e,encode:t,decode:s})=>new gu(i,e,t,s),Yi=({prefix:i,name:e,alphabet:t})=>{const{encode:s,decode:r}=cu(t,e);return Os({prefix:i,name:e,encode:s,decode:o=>Jo(r(o))})},fu=(i,e,t,s)=>{const r={};for(let u=0;u<e.length;++u)r[e[u]]=u;let o=i.length;for(;i[o-1]==="=";)--o;const a=new Uint8Array(o*t/8|0);let c=0,h=0,d=0;for(let u=0;u<o;++u){const p=r[i[u]];if(p===void 0)throw new SyntaxError(`Non-${s} character`);h=h<<t|p,c+=t,c>=8&&(c-=8,a[d++]=255&h>>c)}if(c>=t||255&h<<8-c)throw new SyntaxError("Unexpected end of data");return a},yu=(i,e,t)=>{const s=e[e.length-1]==="=",r=(1<<t)-1;let o="",a=0,c=0;for(let h=0;h<i.length;++h)for(c=c<<8|i[h],a+=8;a>t;)a-=t,o+=e[r&c>>a];if(a&&(o+=e[r&c<<t-a]),s)for(;o.length*t&7;)o+="=";return o},Se=({name:i,prefix:e,bitsPerChar:t,alphabet:s})=>Os({prefix:e,name:i,encode(r){return yu(r,s,t)},decode(r){return fu(r,s,t,i)}}),_u=Os({prefix:"\0",name:"identity",encode:i=>du(i),decode:i=>hu(i)});var mu=Object.freeze({__proto__:null,identity:_u});const wu=Se({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var bu=Object.freeze({__proto__:null,base2:wu});const vu=Se({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var xu=Object.freeze({__proto__:null,base8:vu});const Eu=Yi({prefix:"9",name:"base10",alphabet:"0123456789"});var Iu=Object.freeze({__proto__:null,base10:Eu});const Pu=Se({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Su=Se({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Ou=Object.freeze({__proto__:null,base16:Pu,base16upper:Su});const Au=Se({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Cu=Se({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ru=Se({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Fu=Se({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Nu=Se({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Tu=Se({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Bu=Se({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Du=Se({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),$u=Se({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var ju=Object.freeze({__proto__:null,base32:Au,base32upper:Cu,base32pad:Ru,base32padupper:Fu,base32hex:Nu,base32hexupper:Tu,base32hexpad:Bu,base32hexpadupper:Du,base32z:$u});const qu=Yi({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Uu=Yi({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Lu=Object.freeze({__proto__:null,base36:qu,base36upper:Uu});const ku=Yi({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Mu=Yi({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var zu=Object.freeze({__proto__:null,base58btc:ku,base58flickr:Mu});const Hu=Se({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Vu=Se({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Ku=Se({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Gu=Se({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Wu=Object.freeze({__proto__:null,base64:Hu,base64pad:Vu,base64url:Ku,base64urlpad:Gu});const Yo=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Ju=Yo.reduce((i,e,t)=>(i[t]=e,i),[]),Zu=Yo.reduce((i,e,t)=>(i[e.codePointAt(0)]=t,i),[]);function Yu(i){return i.reduce((e,t)=>(e+=Ju[t],e),"")}function Qu(i){const e=[];for(const t of i){const s=Zu[t.codePointAt(0)];if(s===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const Xu=Os({prefix:"\u{1F680}",name:"base256emoji",encode:Yu,decode:Qu});var ep=Object.freeze({__proto__:null,base256emoji:Xu}),tp=Xo,Qo=128,ip=127,sp=~ip,np=Math.pow(2,31);function Xo(i,e,t){e=e||[],t=t||0;for(var s=t;i>=np;)e[t++]=i&255|Qo,i/=128;for(;i&sp;)e[t++]=i&255|Qo,i>>>=7;return e[t]=i|0,Xo.bytes=t-s+1,e}var rp=Nn,op=128,ea=127;function Nn(i,s){var t=0,s=s||0,r=0,o=s,a,c=i.length;do{if(o>=c)throw Nn.bytes=0,new RangeError("Could not decode varint");a=i[o++],t+=r<28?(a&ea)<<r:(a&ea)*Math.pow(2,r),r+=7}while(a>=op);return Nn.bytes=o-s,t}var ap=Math.pow(2,7),cp=Math.pow(2,14),hp=Math.pow(2,21),dp=Math.pow(2,28),lp=Math.pow(2,35),up=Math.pow(2,42),pp=Math.pow(2,49),gp=Math.pow(2,56),fp=Math.pow(2,63),yp=function(i){return i<ap?1:i<cp?2:i<hp?3:i<dp?4:i<lp?5:i<up?6:i<pp?7:i<gp?8:i<fp?9:10},_p={encode:tp,decode:rp,encodingLength:yp},ta=_p;const ia=(i,e,t=0)=>(ta.encode(i,e,t),e),sa=i=>ta.encodingLength(i),Tn=(i,e)=>{const t=e.byteLength,s=sa(i),r=s+sa(t),o=new Uint8Array(r+t);return ia(i,o,0),ia(t,o,s),o.set(e,r),new mp(i,t,e,o)};class mp{constructor(e,t,s,r){this.code=e,this.size=t,this.digest=s,this.bytes=r}}const na=({name:i,code:e,encode:t})=>new wp(i,e,t);class wp{constructor(e,t,s){this.name=e,this.code=t,this.encode=s}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?Tn(this.code,t):t.then(s=>Tn(this.code,s))}else throw Error("Unknown type, must be binary type")}}const ra=i=>async e=>new Uint8Array(await crypto.subtle.digest(i,e)),bp=na({name:"sha2-256",code:18,encode:ra("SHA-256")}),vp=na({name:"sha2-512",code:19,encode:ra("SHA-512")});var xp=Object.freeze({__proto__:null,sha256:bp,sha512:vp});const oa=0,Ep="identity",aa=Jo;var Ip=Object.freeze({__proto__:null,identity:{code:oa,name:Ep,encode:aa,digest:i=>Tn(oa,aa(i))}});new TextEncoder,new TextDecoder;const ca={...mu,...bu,...xu,...Iu,...Ou,...ju,...Lu,...zu,...Wu,...ep};({...xp,...Ip});function ha(i,e,t,s){return{name:i,prefix:e,encoder:{name:i,prefix:e,encode:t},decoder:{decode:s}}}const da=ha("utf8","u",i=>"u"+new TextDecoder("utf8").decode(i),i=>new TextEncoder().encode(i.substring(1))),Bn=ha("ascii","a",i=>{let e="a";for(let t=0;t<i.length;t++)e+=String.fromCharCode(i[t]);return e},i=>{i=i.substring(1);const e=Go(i.length);for(let t=0;t<i.length;t++)e[t]=i.charCodeAt(t);return e}),la={utf8:da,"utf-8":da,hex:ca.base16,latin1:Bn,ascii:Bn,binary:Bn,...ca};function li(i,e="utf8"){const t=la[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(i.buffer,i.byteOffset,i.byteLength).toString("utf8"):t.encoder.encode(i).substring(1)}function Kt(i,e="utf8"){const t=la[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?Fn(globalThis.Buffer.from(i,"utf-8")):t.decoder.decode(`${t.prefix}${i}`)}function As(i){return(0,st.D)(li(Kt(i,Ps),ko))}function Cs(i){return li(Kt((0,st.u)(i),ko),Ps)}function ua(i){const e=Kt(Ko,Ss),t=Vo+li(Wo([e,i]),Ss);return[zo,Ho,t].join(Mo)}function Pp(i){const[e,t,s]=i.split(Mo);if(e!==zo||t!==Ho)throw new Error('Issuer must be a DID with method "key"');if(s.slice(0,1)!==Vo)throw new Error("Issuer must be a key in mulicodec format");const r=Kt(s.slice(1),Ss);if(li(r.slice(0,2),Ss)!==Ko)throw new Error('Issuer must be a public key with type "Ed25519"');const o=r.slice(2);if(o.length!==nu)throw new Error("Issuer must be a public key with length 32 bytes");return o}function Sp(i){return li(i,Ps)}function Op(i){return Kt(i,Ps)}function Ap(i){return Kt([Cs(i.header),Cs(i.payload)].join(Zi),Rn)}function bx(i){const e=li(i,Rn).split(Zi),t=As(e[0]),s=As(e[1]);return{header:t,payload:s}}function Cp(i){return[Cs(i.header),Cs(i.payload),Sp(i.signature)].join(Zi)}function Rs(i){const e=i.split(Zi),t=As(e[0]),s=As(e[1]),r=Op(e[2]),o=Kt(e.slice(0,2).join(Zi),Rn);return{header:t,payload:s,signature:r,data:o}}function pa(i=bo(ru)){const e=Cn.getPublicKey(i);return{secretKey:Wo([i,e]),publicKey:e}}async function Rp(i,e,t,s,r=(0,D.fromMiliseconds)(Date.now())){const o={alg:Uo,typ:Lo},a=ua(s.publicKey),c=r+t,h={iss:a,sub:i,aud:e,iat:r,exp:c},d=Ap({header:o,payload:h}),u=Cn.sign(d,s.secretKey.slice(0,32));return Cp({header:o,payload:h,signature:u})}async function vx(i){const{header:e,payload:t,data:s,signature:r}=Rs(i);if(e.alg!==Uo||e.typ!==Lo)throw new Error("JWT must use EdDSA algorithm");const o=Pp(t.iss);return Cn.verify(r,s,o)}var re=q(90032),Fp=q(24242),Fs=q(14224),It=q(55872).Buffer;const Ns=":";function Gt(i){const[e,t]=i.split(Ns);return{namespace:e,reference:t}}function Np(i){const{namespace:e,reference:t}=i;return[e,t].join(Ns)}function ga(i){const[e,t,s]=i.split(Ns);return{namespace:e,reference:t,address:s}}function Tp(i){const{namespace:e,reference:t,address:s}=i;return[e,t,s].join(Ns)}function fa(i,e){const t=[];return i.forEach(s=>{const r=e(s);t.includes(r)||t.push(r)}),t}function Bp(i){const{address:e}=ga(i);return e}function Dp(i){const{namespace:e,reference:t}=ga(i);return Np({namespace:e,reference:t})}function xx(i,e){const{namespace:t,reference:s}=Gt(e);return Tp({namespace:t,reference:s,address:i})}function Ex(i){return fa(i,Bp)}function $p(i){return fa(i,Dp)}function ya(i,e=[]){const t=[];return Object.keys(i).forEach(s=>{if(e.length&&!e.includes(s))return;const r=i[s];t.push(...r.accounts)}),t}function Ix(i,e=[]){const t=[];return Object.keys(i).forEach(s=>{if(e.length&&!e.includes(s))return;const r=i[s];t.push(...$p(r.accounts))}),t}function Px(i,e=[]){const t=[];return Object.keys(i).forEach(s=>{if(e.length&&!e.includes(s))return;const r=i[s];t.push(...Dn(s,r))}),t}function Dn(i,e){return i.includes(":")?[i]:e.chains||[]}var jp=Object.defineProperty,qp=Object.defineProperties,Up=Object.getOwnPropertyDescriptors,_a=Object.getOwnPropertySymbols,Lp=Object.prototype.hasOwnProperty,kp=Object.prototype.propertyIsEnumerable,ma=(i,e,t)=>e in i?jp(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,wa=(i,e)=>{for(var t in e||(e={}))Lp.call(e,t)&&ma(i,t,e[t]);if(_a)for(var t of _a(e))kp.call(e,t)&&ma(i,t,e[t]);return i},Mp=(i,e)=>qp(i,Up(e));const zp="ReactNative",Le={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"},$n=" ",Sx=":",Hp="/",ba=2,Ox=1e3,Vp="js";function Ts(){return typeof Fs<"u"&&typeof Fs.versions<"u"&&typeof Fs.versions.node<"u"}function Dt(){return!(0,zt.getDocument)()&&!!(0,zt.getNavigator)()&&navigator.product===zp}function Kp(){return Dt()&&typeof q.g<"u"&&typeof(q.g==null?void 0:q.g.Platform)<"u"&&(q.g==null?void 0:q.g.Platform.OS)==="android"}function Gp(){return Dt()&&typeof q.g<"u"&&typeof(q.g==null?void 0:q.g.Platform)<"u"&&(q.g==null?void 0:q.g.Platform.OS)==="ios"}function Qi(){return!Ts()&&!!(0,zt.getNavigator)()&&!!(0,zt.getDocument)()}function ui(){return Dt()?Le.reactNative:Ts()?Le.node:Qi()?Le.browser:Le.unknown}function va(){var i;try{return Dt()&&typeof q.g<"u"&&typeof(q.g==null?void 0:q.g.Application)<"u"?(i=q.g.Application)==null?void 0:i.applicationId:void 0}catch{return}}function Wp(i,e){const t=new URLSearchParams(i);for(const s of Object.keys(e).sort())if(e.hasOwnProperty(s)){const r=e[s];r!==void 0&&t.set(s,r)}return t.toString()}function Jp(i){var e,t;const s=xa();try{return i!=null&&i.url&&s.url&&i.url!==s.url&&(console.warn(`The configured WalletConnect 'metadata.url':${i.url} differs from the actual page url:${s.url}. This is probably unintended and can lead to issues.`),i.url=s.url),(e=i==null?void 0:i.icons)!=null&&e.length&&i.icons.length>0&&(i.icons=i.icons.filter(r=>r!=="")),Mp(wa(wa({},s),i),{url:(i==null?void 0:i.url)||s.url,name:(i==null?void 0:i.name)||s.name,description:(i==null?void 0:i.description)||s.description,icons:(t=i==null?void 0:i.icons)!=null&&t.length&&i.icons.length>0?i.icons:s.icons})}catch(r){return console.warn("Error populating app metadata",r),i||s}}function xa(){return(0,Sd.D)()||{name:"",description:"",url:"",icons:[""]}}function Ax(i,e){var t;const s=ui(),r={protocol:i,version:e,env:s};return s==="browser"&&(r.host=((t=On())==null?void 0:t.host)||"unknown"),r}function Zp(){if(ui()===Le.reactNative&&typeof q.g<"u"&&typeof(q.g==null?void 0:q.g.Platform)<"u"){const{OS:t,Version:s}=q.g.Platform;return[t,s].join("-")}const i=(0,Pd.qY)();if(i===null)return"unknown";const e=i.os?i.os.replace(" ","").toLowerCase():"unknown";return i.type==="browser"?[e,i.name,i.version].join("-"):[e,i.version].join("-")}function Yp(){var i;const e=ui();return e===Le.browser?[e,((i=(0,zt.getLocation)())==null?void 0:i.host)||"unknown"].join(":"):e}function Ea(i,e,t){const s=Zp(),r=Yp();return[[i,e].join("-"),[Vp,t].join("-"),s,r].join("/")}function Qp({protocol:i,version:e,relayUrl:t,sdkVersion:s,auth:r,projectId:o,useOnCloseEvent:a,bundleId:c,packageName:h}){const d=t.split("?"),u=Ea(i,e,s),p={auth:r,ua:u,projectId:o,useOnCloseEvent:a||void 0,packageName:h||void 0,bundleId:c||void 0},g=Wp(d[1]||"",p);return d[0]+"?"+g}function Cx(i){let e=(i.match(/^[^:]+(?=:\/\/)/gi)||[])[0];const t=typeof e<"u"?i.split("://")[1]:i;return e=e==="wss"?"https":"http",[e,t].join("://")}function Rx(i,e,t){if(!i[e]||typeof i[e]!==t)throw new Error(`Missing or invalid "${e}" param`)}function Xp(i,e=ba){return eg(i.split(Hp),e)}function Fx(i){return Xp(i).join($n)}function Wt(i,e){return i.filter(t=>e.includes(t)).length===i.length}function eg(i,e=ba){return i.slice(Math.max(i.length-e,0))}function jn(i){return Object.fromEntries(i.entries())}function qn(i){return new Map(Object.entries(i))}function Nx(i,e){const t={};return Object.keys(i).forEach(s=>{t[s]=e(i[s])}),t}const Tx=i=>i;function tg(i){return i.trim().replace(/^\w/,e=>e.toUpperCase())}function Bx(i){return i.split($n).map(e=>tg(e)).join($n)}function Jt(i=D.FIVE_MINUTES,e){const t=(0,D.toMiliseconds)(i||D.FIVE_MINUTES);let s,r,o,a;return{resolve:c=>{o&&s&&(clearTimeout(o),s(c),a=Promise.resolve(c))},reject:c=>{o&&r&&(clearTimeout(o),r(c))},done:()=>new Promise((c,h)=>{if(a)return c(a);o=setTimeout(()=>{const d=new Error(e);a=Promise.reject(d),h(d)},t),s=c,r=h})}}function $t(i,e,t){return new Promise(async(s,r)=>{const o=setTimeout(()=>r(new Error(t)),e);try{const a=await i;s(a)}catch(a){r(a)}clearTimeout(o)})}function Ia(i,e){if(typeof e=="string"&&e.startsWith(`${i}:`))return e;if(i.toLowerCase()==="topic"){if(typeof e!="string")throw new Error('Value must be "string" for expirer target type: topic');return`topic:${e}`}else if(i.toLowerCase()==="id"){if(typeof e!="number")throw new Error('Value must be "number" for expirer target type: id');return`id:${e}`}throw new Error(`Unknown expirer target type: ${i}`)}function ig(i){return Ia("topic",i)}function sg(i){return Ia("id",i)}function Pa(i){const[e,t]=i.split(":"),s={id:void 0,topic:void 0};if(e==="topic"&&typeof t=="string")s.topic=t;else if(e==="id"&&Number.isInteger(Number(t)))s.id=Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);return s}function we(i,e){return(0,D.fromMiliseconds)((e||Date.now())+(0,D.toMiliseconds)(i))}function jt(i){return Date.now()>=(0,D.toMiliseconds)(i)}function oe(i,e){return`${i}${e?`:${e}`:""}`}function rt(i=[],e=[]){return[...new Set([...i,...e])]}async function ng({id:i,topic:e,wcDeepLink:t}){var s;try{if(!t)return;const r=typeof t=="string"?JSON.parse(t):t,o=r==null?void 0:r.href;if(typeof o!="string")return;const a=rg(o,i,e),c=ui();if(c===Le.browser){if(!((s=(0,zt.getDocument)())!=null&&s.hasFocus())){console.warn("Document does not have focus, skipping deeplink.");return}og(a)}else c===Le.reactNative&&typeof(q.g==null?void 0:q.g.Linking)<"u"&&await q.g.Linking.openURL(a)}catch(r){console.error(r)}}function rg(i,e,t){const s=`requestId=${e}&sessionTopic=${t}`;i.endsWith("/")&&(i=i.slice(0,-1));let r=`${i}`;if(i.startsWith("https://t.me")){const o=i.includes("?")?"&startapp=":"?startapp=";r=`${r}${o}${dg(s,!0)}`}else r=`${r}/wc?${s}`;return r}function og(i){let e="_self";hg()?e="_top":(cg()||i.startsWith("https://")||i.startsWith("http://"))&&(e="_blank"),window.open(i,e,"noreferrer noopener")}async function ag(i,e){let t="";try{if(Qi()&&(t=localStorage.getItem(e),t))return t;t=await i.getItem(e)}catch(s){console.error(s)}return t}function Sa(i,e){return i.filter(t=>e.includes(t))}function Oa(i,e){if(!i.includes(e))return null;const t=i.split(/([&,?,=])/),s=t.indexOf(e);return t[s+2]}function Aa(){return typeof crypto<"u"&&crypto!=null&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu,i=>{const e=Math.random()*16|0;return(i==="x"?e:e&3|8).toString(16)})}function Un(){return typeof Fs<"u"&&{NODE_ENV:"production",PUBLIC_PATH:"/"}.IS_VITEST==="true"}function cg(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)}function hg(){try{return window.self!==window.top}catch{return!1}}function dg(i,e=!1){const t=It.from(i).toString("base64");return e?t.replace(/[=]/g,""):t}function Ca(i){return It.from(i,"base64").toString("utf-8")}function lg(i){return new Promise(e=>setTimeout(e,i))}function Xi(i){if(!Number.isSafeInteger(i)||i<0)throw new Error("positive integer expected, got "+i)}function ug(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function es(i,...e){if(!ug(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function Ln(i){if(typeof i!="function"||typeof i.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Xi(i.outputLen),Xi(i.blockLen)}function pi(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function Ra(i,e){es(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const Bs=BigInt(2**32-1),Fa=BigInt(32);function pg(i,e=!1){return e?{h:Number(i&Bs),l:Number(i>>Fa&Bs)}:{h:Number(i>>Fa&Bs)|0,l:Number(i&Bs)|0}}function gg(i,e=!1){let t=new Uint32Array(i.length),s=new Uint32Array(i.length);for(let r=0;r<i.length;r++){const{h:o,l:a}=pg(i[r],e);[t[r],s[r]]=[o,a]}return[t,s]}const fg=(i,e,t)=>i<<t|e>>>32-t,yg=(i,e,t)=>e<<t|i>>>32-t,_g=(i,e,t)=>e<<t-32|i>>>64-t,mg=(i,e,t)=>i<<t-32|e>>>64-t,gi=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function wg(i){return new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4))}function kn(i){return new DataView(i.buffer,i.byteOffset,i.byteLength)}function ft(i,e){return i<<32-e|i>>>e}const Na=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function bg(i){return i<<24&4278190080|i<<8&16711680|i>>>8&65280|i>>>24&255}function Ta(i){for(let e=0;e<i.length;e++)i[e]=bg(i[e])}function vg(i){if(typeof i!="string")throw new Error("utf8ToBytes expected string, got "+typeof i);return new Uint8Array(new TextEncoder().encode(i))}function fi(i){return typeof i=="string"&&(i=vg(i)),es(i),i}function xg(...i){let e=0;for(let s=0;s<i.length;s++){const r=i[s];es(r),e+=r.length}const t=new Uint8Array(e);for(let s=0,r=0;s<i.length;s++){const o=i[s];t.set(o,r),r+=o.length}return t}class Mn{clone(){return this._cloneInto()}}function Ba(i){const e=s=>i().update(fi(s)).digest(),t=i();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>i(),e}function yi(i=32){if(gi&&typeof gi.getRandomValues=="function")return gi.getRandomValues(new Uint8Array(i));if(gi&&typeof gi.randomBytes=="function")return gi.randomBytes(i);throw new Error("crypto.getRandomValues must be defined")}const Da=[],$a=[],ja=[],Eg=BigInt(0),ts=BigInt(1),Ig=BigInt(2),Pg=BigInt(7),Sg=BigInt(256),Og=BigInt(113);for(let i=0,e=ts,t=1,s=0;i<24;i++){[t,s]=[s,(2*t+3*s)%5],Da.push(2*(5*s+t)),$a.push((i+1)*(i+2)/2%64);let r=Eg;for(let o=0;o<7;o++)e=(e<<ts^(e>>Pg)*Og)%Sg,e&Ig&&(r^=ts<<(ts<<BigInt(o))-ts);ja.push(r)}const[Ag,Cg]=gg(ja,!0),qa=(i,e,t)=>t>32?_g(i,e,t):fg(i,e,t),Ua=(i,e,t)=>t>32?mg(i,e,t):yg(i,e,t);function Rg(i,e=24){const t=new Uint32Array(10);for(let s=24-e;s<24;s++){for(let a=0;a<10;a++)t[a]=i[a]^i[a+10]^i[a+20]^i[a+30]^i[a+40];for(let a=0;a<10;a+=2){const c=(a+8)%10,h=(a+2)%10,d=t[h],u=t[h+1],p=qa(d,u,1)^t[c],g=Ua(d,u,1)^t[c+1];for(let _=0;_<50;_+=10)i[a+_]^=p,i[a+_+1]^=g}let r=i[2],o=i[3];for(let a=0;a<24;a++){const c=$a[a],h=qa(r,o,c),d=Ua(r,o,c),u=Da[a];r=i[u],o=i[u+1],i[u]=h,i[u+1]=d}for(let a=0;a<50;a+=10){for(let c=0;c<10;c++)t[c]=i[a+c];for(let c=0;c<10;c++)i[a+c]^=~t[(c+2)%10]&t[(c+4)%10]}i[0]^=Ag[s],i[1]^=Cg[s]}t.fill(0)}class zn extends Mn{constructor(e,t,s,r=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=s,this.enableXOF=r,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Xi(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=wg(this.state)}keccak(){Na||Ta(this.state32),Rg(this.state32,this.rounds),Na||Ta(this.state32),this.posOut=0,this.pos=0}update(e){pi(this);const{blockLen:t,state:s}=this;e=fi(e);const r=e.length;for(let o=0;o<r;){const a=Math.min(t-this.pos,r-o);for(let c=0;c<a;c++)s[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:s,blockLen:r}=this;e[s]^=t,t&128&&s===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){pi(this,!1),es(e),this.finish();const t=this.state,{blockLen:s}=this;for(let r=0,o=e.length;r<o;){this.posOut>=s&&this.keccak();const a=Math.min(s-this.posOut,o-r);e.set(t.subarray(this.posOut,this.posOut+a),r),this.posOut+=a,r+=a}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Xi(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Ra(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:s,outputLen:r,rounds:o,enableXOF:a}=this;return e||(e=new zn(t,s,r,a,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=s,e.outputLen=r,e.enableXOF=a,e.destroyed=this.destroyed,e}}const Fg=(i,e,t)=>Ba(()=>new zn(e,i,t)),Ng=Fg(1,136,256/8),Tg="https://rpc.walletconnect.org/v1";function La(i){const e=`Ethereum Signed Message:
${i.length}`,t=new TextEncoder().encode(e+i);return"0x"+It.from(Ng(t)).toString("hex")}async function Bg(i,e,t,s,r,o){switch(t.t){case"eip191":return await Dg(i,e,t.s);case"eip1271":return await $g(i,e,t.s,s,r,o);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`)}}async function Dg(i,e,t){return(await Vd({hash:La(e),signature:t})).toLowerCase()===i.toLowerCase()}async function $g(i,e,t,s,r,o){const a=Gt(s);if(!a.namespace||!a.reference)throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${s}`);try{const c="0x1626ba7e",h="0000000000000000000000000000000000000000000000000000000000000040",d="0000000000000000000000000000000000000000000000000000000000000041",u=t.substring(2),p=La(e).substring(2),g=c+p+h+d+u,_=await fetch(`${o||Tg}/?chainId=${s}&projectId=${r}`,{method:"POST",body:JSON.stringify({id:jg(),jsonrpc:"2.0",method:"eth_call",params:[{to:i,data:g},"latest"]})}),{result:f}=await _.json();return f?f.slice(0,c.length).toLowerCase()===c.toLowerCase():!1}catch(c){return console.error("isValidEip1271Signature: ",c),!1}}function jg(){return Date.now()+Math.floor(Math.random()*1e3)}function qg(i){const e=atob(i),t=new Uint8Array(e.length);for(let a=0;a<e.length;a++)t[a]=e.charCodeAt(a);const s=t[0];if(s===0)throw new Error("No signatures found");const r=1+s*64;if(t.length<r)throw new Error("Transaction data too short for claimed signature count");if(t.length<100)throw new Error("Transaction too short");const o=It.from(i,"base64").slice(1,65);return Kd.default.encode(o)}var Ug=Object.defineProperty,Lg=Object.defineProperties,kg=Object.getOwnPropertyDescriptors,ka=Object.getOwnPropertySymbols,Mg=Object.prototype.hasOwnProperty,zg=Object.prototype.propertyIsEnumerable,Ma=(i,e,t)=>e in i?Ug(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Hn=(i,e)=>{for(var t in e||(e={}))Mg.call(e,t)&&Ma(i,t,e[t]);if(ka)for(var t of ka(e))zg.call(e,t)&&Ma(i,t,e[t]);return i},za=(i,e)=>Lg(i,kg(e));const Hg="did:pkh:",Vn=i=>i==null?void 0:i.split(":"),Vg=i=>{const e=i&&Vn(i);if(e)return i.includes(Hg)?e[3]:e[1]},Kn=i=>{const e=i&&Vn(i);if(e)return e[2]+":"+e[3]},Ds=i=>{const e=i&&Vn(i);if(e)return e.pop()};async function Ha(i){const{cacao:e,projectId:t}=i,{s,p:r}=e,o=Va(r,r.iss),a=Ds(r.iss);return await Bg(a,o,s,Kn(r.iss),t)}const Va=(i,e)=>{const t=`${i.domain} wants you to sign in with your Ethereum account:`,s=Ds(e);if(!i.aud&&!i.uri)throw new Error("Either `aud` or `uri` is required to construct the message");let r=i.statement||void 0;const o=`URI: ${i.aud||i.uri}`,a=`Version: ${i.version}`,c=`Chain ID: ${Vg(e)}`,h=`Nonce: ${i.nonce}`,d=`Issued At: ${i.iat}`,u=i.exp?`Expiration Time: ${i.exp}`:void 0,p=i.nbf?`Not Before: ${i.nbf}`:void 0,g=i.requestId?`Request ID: ${i.requestId}`:void 0,_=i.resources?`Resources:${i.resources.map(y=>`
- ${y}`).join("")}`:void 0,f=_i(i.resources);if(f){const y=Zt(f);r=Wa(r,y)}return[t,s,"",r,"",o,a,c,h,d,u,p,g,_].filter(y=>y!=null).join(`
`)};function Dx(i,e,t){return t.includes("did:pkh:")||(t=`did:pkh:${t}`),{h:{t:"caip122"},p:{iss:t,domain:i.domain,aud:i.aud,version:i.version,nonce:i.nonce,iat:i.iat,statement:i.statement,requestId:i.requestId,resources:i.resources,nbf:i.nbf,exp:i.exp},s:e}}function $x(i){var e;const{authPayload:t,chains:s,methods:r}=i,o=t.statement||"";if(!(s!=null&&s.length))return t;const a=t.chains,c=Sa(a,s);if(!(c!=null&&c.length))throw new Error("No supported chains");const h=Kg(t.resources);if(!h)return t;Pt(h);const d=Gg(h,"eip155");let u=(t==null?void 0:t.resources)||[];if(d!=null&&d.length){const p=Wg(d),g=Sa(p,r);if(!(g!=null&&g.length))throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(p)}, supported: ${JSON.stringify(r)}`);const _=Ka("request",g,{chains:c}),f=Qg(h,"eip155",_);u=((e=t==null?void 0:t.resources)==null?void 0:e.slice(0,-1))||[],u.push(Gn(f))}return za(Hn({},t),{statement:sf(o,_i(u)),chains:c,resources:t!=null&&t.resources||u.length>0?u:void 0})}function Kg(i){const e=_i(i);if(e&&Ga(e))return Zt(e)}function jx(i,e){var t;return(t=i==null?void 0:i.att)==null?void 0:t.hasOwnProperty(e)}function Gg(i,e){var t,s;return(t=i==null?void 0:i.att)!=null&&t[e]?Object.keys((s=i==null?void 0:i.att)==null?void 0:s[e]):[]}function qx(i){return(i==null?void 0:i.map(e=>Object.keys(e)))||[]}function Wg(i){return(i==null?void 0:i.map(e=>{var t;return(t=e.split("/"))==null?void 0:t[1]}))||[]}function Jg(i){return It.from(JSON.stringify(i)).toString("base64")}function Zg(i){return JSON.parse(It.from(i,"base64").toString("utf-8"))}function Pt(i){if(!i)throw new Error("No recap provided, value is undefined");if(!i.att)throw new Error("No `att` property found");const e=Object.keys(i.att);if(!(e!=null&&e.length))throw new Error("No resources found in `att` property");e.forEach(t=>{const s=i.att[t];if(Array.isArray(s))throw new Error(`Resource must be an object: ${t}`);if(typeof s!="object")throw new Error(`Resource must be an object: ${t}`);if(!Object.keys(s).length)throw new Error(`Resource object is empty: ${t}`);Object.keys(s).forEach(r=>{const o=s[r];if(!Array.isArray(o))throw new Error(`Ability limits ${r} must be an array of objects, found: ${o}`);if(!o.length)throw new Error(`Value of ${r} is empty array, must be an array with objects`);o.forEach(a=>{if(typeof a!="object")throw new Error(`Ability limits (${r}) must be an array of objects, found: ${a}`)})})})}function Yg(i,e,t,s={}){return t==null||t.sort((r,o)=>r.localeCompare(o)),{att:{[i]:Ka(e,t,s)}}}function Qg(i,e,t){var s;i.att[e]=Hn({},t);const r=(s=Object.keys(i.att))==null?void 0:s.sort((a,c)=>a.localeCompare(c)),o={att:{}};return r.reduce((a,c)=>(a.att[c]=i.att[c],a),o)}function Ka(i,e,t={}){e=e==null?void 0:e.sort((r,o)=>r.localeCompare(o));const s=e.map(r=>({[`${i}/${r}`]:[t]}));return Object.assign({},...s)}function Gn(i){return Pt(i),`urn:recap:${Jg(i).replace(/=/g,"")}`}function Zt(i){const e=Zg(i.replace("urn:recap:",""));return Pt(e),e}function Xg(i,e,t){const s=Yg(i,e,t);return Gn(s)}function Ga(i){return i&&i.includes("urn:recap:")}function ef(i,e){const t=Zt(i),s=Zt(e),r=tf(t,s);return Gn(r)}function tf(i,e){Pt(i),Pt(e);const t=Object.keys(i.att).concat(Object.keys(e.att)).sort((r,o)=>r.localeCompare(o)),s={att:{}};return t.forEach(r=>{var o,a;Object.keys(((o=i.att)==null?void 0:o[r])||{}).concat(Object.keys(((a=e.att)==null?void 0:a[r])||{})).sort((c,h)=>c.localeCompare(h)).forEach(c=>{var h,d;s.att[r]=za(Hn({},s.att[r]),{[c]:((h=i.att[r])==null?void 0:h[c])||((d=e.att[r])==null?void 0:d[c])})})}),s}function Wa(i="",e){Pt(e);const t="I further authorize the stated URI to perform the following actions on my behalf: ";if(i.includes(t))return i;const s=[];let r=0;Object.keys(e.att).forEach(c=>{const h=Object.keys(e.att[c]).map(p=>({ability:p.split("/")[0],action:p.split("/")[1]}));h.sort((p,g)=>p.action.localeCompare(g.action));const d={};h.forEach(p=>{d[p.ability]||(d[p.ability]=[]),d[p.ability].push(p.action)});const u=Object.keys(d).map(p=>(r++,`(${r}) '${p}': '${d[p].join("', '")}' for '${c}'.`));s.push(u.join(", ").replace(".,","."))});const o=s.join(" "),a=`${t}${o}`;return`${i?i+" ":""}${a}`}function Ja(i){var e;const t=Zt(i);Pt(t);const s=(e=t.att)==null?void 0:e.eip155;return s?Object.keys(s).map(r=>r.split("/")[1]):[]}function Za(i){const e=Zt(i);Pt(e);const t=[];return Object.values(e.att).forEach(s=>{Object.values(s).forEach(r=>{var o;(o=r==null?void 0:r[0])!=null&&o.chains&&t.push(r[0].chains)})}),[...new Set(t.flat())]}function sf(i,e){if(!e)return i;const t=Zt(e);return Pt(t),Wa(i,t)}function _i(i){if(!i)return;const e=i==null?void 0:i[i.length-1];return Ga(e)?e:void 0}function Wn(i){if(!Number.isSafeInteger(i)||i<0)throw new Error("positive integer expected, got "+i)}function Ya(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function He(i,...e){if(!Ya(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function Qa(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function nf(i,e){He(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Xa(i){if(typeof i!="boolean")throw new Error(`boolean expected, not ${i}`)}const qt=i=>new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4)),rf=i=>new DataView(i.buffer,i.byteOffset,i.byteLength);if(!(new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68))throw new Error("Non little-endian hardware is not supported");function of(i){if(typeof i!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(i))}function Jn(i){if(typeof i=="string")i=of(i);else if(Ya(i))i=Zn(i);else throw new Error("Uint8Array expected, got "+typeof i);return i}function af(i,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(i,e)}function cf(i,e){if(i.length!==e.length)return!1;let t=0;for(let s=0;s<i.length;s++)t|=i[s]^e[s];return t===0}const hf=(i,e)=>{function t(s,...r){if(He(s),i.nonceLength!==void 0){const d=r[0];if(!d)throw new Error("nonce / iv required");i.varSizeNonce?He(d):He(d,i.nonceLength)}const o=i.tagLength;o&&r[1]!==void 0&&He(r[1]);const a=e(s,...r),c=(d,u)=>{if(u!==void 0){if(d!==2)throw new Error("cipher output not supported");He(u)}};let h=!1;return{encrypt(d,u){if(h)throw new Error("cannot encrypt() twice with same key + nonce");return h=!0,He(d),c(a.encrypt.length,u),a.encrypt(d,u)},decrypt(d,u){if(He(d),o&&d.length<o)throw new Error("invalid ciphertext length: smaller than tagLength="+o);return c(a.decrypt.length,u),a.decrypt(d,u)}}}return Object.assign(t,i),t};function ec(i,e,t=!0){if(e===void 0)return new Uint8Array(i);if(e.length!==i)throw new Error("invalid output length, expected "+i+", got: "+e.length);if(t&&!df(e))throw new Error("invalid output, must be aligned");return e}function tc(i,e,t,s){if(typeof i.setBigUint64=="function")return i.setBigUint64(e,t,s);const r=BigInt(32),o=BigInt(4294967295),a=Number(t>>r&o),c=Number(t&o),h=s?4:0,d=s?0:4;i.setUint32(e+h,a,s),i.setUint32(e+d,c,s)}function df(i){return i.byteOffset%4===0}function Zn(i){return Uint8Array.from(i)}function mi(...i){for(let e=0;e<i.length;e++)i[e].fill(0)}const ic=i=>Uint8Array.from(i.split("").map(e=>e.charCodeAt(0))),lf=ic("expand 16-byte k"),uf=ic("expand 32-byte k"),pf=qt(lf),gf=qt(uf);function ee(i,e){return i<<e|i>>>32-e}function Yn(i){return i.byteOffset%4===0}const $s=64,ff=16,sc=2**32-1,nc=new Uint32Array;function yf(i,e,t,s,r,o,a,c){const h=r.length,d=new Uint8Array($s),u=qt(d),p=Yn(r)&&Yn(o),g=p?qt(r):nc,_=p?qt(o):nc;for(let f=0;f<h;a++){if(i(e,t,s,u,a,c),a>=sc)throw new Error("arx: counter overflow");const y=Math.min($s,h-f);if(p&&y===$s){const m=f/4;if(f%4!==0)throw new Error("arx: invalid block position");for(let v=0,w;v<ff;v++)w=m+v,_[w]=g[w]^u[v];f+=$s;continue}for(let m=0,v;m<y;m++)v=f+m,o[v]=r[v]^d[m];f+=y}}function _f(i,e){const{allowShortKeys:t,extendNonceFn:s,counterLength:r,counterRight:o,rounds:a}=af({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof i!="function")throw new Error("core must be a function");return Wn(r),Wn(a),Xa(o),Xa(t),(c,h,d,u,p=0)=>{He(c),He(h),He(d);const g=d.length;if(u===void 0&&(u=new Uint8Array(g)),He(u),Wn(p),p<0||p>=sc)throw new Error("arx: counter overflow");if(u.length<g)throw new Error(`arx: output (${u.length}) is shorter than data (${g})`);const _=[];let f=c.length,y,m;if(f===32)_.push(y=Zn(c)),m=gf;else if(f===16&&t)y=new Uint8Array(32),y.set(c),y.set(c,16),m=pf,_.push(y);else throw new Error(`arx: invalid 32-byte key, got length=${f}`);Yn(h)||_.push(h=Zn(h));const v=qt(y);if(s){if(h.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(m,v,qt(h.subarray(0,16)),v),h=h.subarray(16)}const w=16-r;if(w!==h.length)throw new Error(`arx: nonce must be ${w} or 16 bytes`);if(w!==12){const P=new Uint8Array(12);P.set(h,o?0:12-h.length),h=P,_.push(h)}const x=qt(h);return yf(i,m,v,x,d,u,p,a),mi(..._),u}}const Oe=(i,e)=>i[e++]&255|(i[e++]&255)<<8;class mf{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=Jn(e),He(e,32);const t=Oe(e,0),s=Oe(e,2),r=Oe(e,4),o=Oe(e,6),a=Oe(e,8),c=Oe(e,10),h=Oe(e,12),d=Oe(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|s<<3)&8191,this.r[2]=(s>>>10|r<<6)&7939,this.r[3]=(r>>>7|o<<9)&8191,this.r[4]=(o>>>4|a<<12)&255,this.r[5]=a>>>1&8190,this.r[6]=(a>>>14|c<<2)&8191,this.r[7]=(c>>>11|h<<5)&8065,this.r[8]=(h>>>8|d<<8)&8191,this.r[9]=d>>>5&127;for(let u=0;u<8;u++)this.pad[u]=Oe(e,16+2*u)}process(e,t,s=!1){const r=s?0:2048,{h:o,r:a}=this,c=a[0],h=a[1],d=a[2],u=a[3],p=a[4],g=a[5],_=a[6],f=a[7],y=a[8],m=a[9],v=Oe(e,t+0),w=Oe(e,t+2),x=Oe(e,t+4),P=Oe(e,t+6),R=Oe(e,t+8),A=Oe(e,t+10),C=Oe(e,t+12),B=Oe(e,t+14);let S=o[0]+(v&8191),H=o[1]+((v>>>13|w<<3)&8191),U=o[2]+((w>>>10|x<<6)&8191),k=o[3]+((x>>>7|P<<9)&8191),V=o[4]+((P>>>4|R<<12)&8191),N=o[5]+(R>>>1&8191),E=o[6]+((R>>>14|A<<2)&8191),b=o[7]+((A>>>11|C<<5)&8191),O=o[8]+((C>>>8|B<<8)&8191),F=o[9]+(B>>>5|r),I=0,j=I+S*c+H*(5*m)+U*(5*y)+k*(5*f)+V*(5*_);I=j>>>13,j&=8191,j+=N*(5*g)+E*(5*p)+b*(5*u)+O*(5*d)+F*(5*h),I+=j>>>13,j&=8191;let L=I+S*h+H*c+U*(5*m)+k*(5*y)+V*(5*f);I=L>>>13,L&=8191,L+=N*(5*_)+E*(5*g)+b*(5*p)+O*(5*u)+F*(5*d),I+=L>>>13,L&=8191;let M=I+S*d+H*h+U*c+k*(5*m)+V*(5*y);I=M>>>13,M&=8191,M+=N*(5*f)+E*(5*_)+b*(5*g)+O*(5*p)+F*(5*u),I+=M>>>13,M&=8191;let K=I+S*u+H*d+U*h+k*c+V*(5*m);I=K>>>13,K&=8191,K+=N*(5*y)+E*(5*f)+b*(5*_)+O*(5*g)+F*(5*p),I+=K>>>13,K&=8191;let G=I+S*p+H*u+U*d+k*h+V*c;I=G>>>13,G&=8191,G+=N*(5*m)+E*(5*y)+b*(5*f)+O*(5*_)+F*(5*g),I+=G>>>13,G&=8191;let J=I+S*g+H*p+U*u+k*d+V*h;I=J>>>13,J&=8191,J+=N*c+E*(5*m)+b*(5*y)+O*(5*f)+F*(5*_),I+=J>>>13,J&=8191;let X=I+S*_+H*g+U*p+k*u+V*d;I=X>>>13,X&=8191,X+=N*h+E*c+b*(5*m)+O*(5*y)+F*(5*f),I+=X>>>13,X&=8191;let ue=I+S*f+H*_+U*g+k*p+V*u;I=ue>>>13,ue&=8191,ue+=N*d+E*h+b*c+O*(5*m)+F*(5*y),I+=ue>>>13,ue&=8191;let ce=I+S*y+H*f+U*_+k*g+V*p;I=ce>>>13,ce&=8191,ce+=N*u+E*d+b*h+O*c+F*(5*m),I+=ce>>>13,ce&=8191;let ne=I+S*m+H*y+U*f+k*_+V*g;I=ne>>>13,ne&=8191,ne+=N*p+E*u+b*d+O*h+F*c,I+=ne>>>13,ne&=8191,I=(I<<2)+I|0,I=I+j|0,j=I&8191,I=I>>>13,L+=I,o[0]=j,o[1]=L,o[2]=M,o[3]=K,o[4]=G,o[5]=J,o[6]=X,o[7]=ue,o[8]=ce,o[9]=ne}finalize(){const{h:e,pad:t}=this,s=new Uint16Array(10);let r=e[1]>>>13;e[1]&=8191;for(let c=2;c<10;c++)e[c]+=r,r=e[c]>>>13,e[c]&=8191;e[0]+=r*5,r=e[0]>>>13,e[0]&=8191,e[1]+=r,r=e[1]>>>13,e[1]&=8191,e[2]+=r,s[0]=e[0]+5,r=s[0]>>>13,s[0]&=8191;for(let c=1;c<10;c++)s[c]=e[c]+r,r=s[c]>>>13,s[c]&=8191;s[9]-=8192;let o=(r^1)-1;for(let c=0;c<10;c++)s[c]&=o;o=~o;for(let c=0;c<10;c++)e[c]=e[c]&o|s[c];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let a=e[0]+t[0];e[0]=a&65535;for(let c=1;c<8;c++)a=(e[c]+t[c]|0)+(a>>>16)|0,e[c]=a&65535;mi(s)}update(e){Qa(this);const{buffer:t,blockLen:s}=this;e=Jn(e);const r=e.length;for(let o=0;o<r;){const a=Math.min(s-this.pos,r-o);if(a===s){for(;s<=r-o;o+=s)this.process(e,o);continue}t.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){mi(this.h,this.r,this.buffer,this.pad)}digestInto(e){Qa(this),nf(e,this),this.finished=!0;const{buffer:t,h:s}=this;let{pos:r}=this;if(r){for(t[r++]=1;r<16;r++)t[r]=0;this.process(t,0,!0)}this.finalize();let o=0;for(let a=0;a<8;a++)e[o++]=s[a]>>>0,e[o++]=s[a]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}}function wf(i){const e=(s,r)=>i(r).update(Jn(s)).digest(),t=i(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=s=>i(s),e}const bf=wf(i=>new mf(i));function vf(i,e,t,s,r,o=20){let a=i[0],c=i[1],h=i[2],d=i[3],u=e[0],p=e[1],g=e[2],_=e[3],f=e[4],y=e[5],m=e[6],v=e[7],w=r,x=t[0],P=t[1],R=t[2],A=a,C=c,B=h,S=d,H=u,U=p,k=g,V=_,N=f,E=y,b=m,O=v,F=w,I=x,j=P,L=R;for(let K=0;K<o;K+=2)A=A+H|0,F=ee(F^A,16),N=N+F|0,H=ee(H^N,12),A=A+H|0,F=ee(F^A,8),N=N+F|0,H=ee(H^N,7),C=C+U|0,I=ee(I^C,16),E=E+I|0,U=ee(U^E,12),C=C+U|0,I=ee(I^C,8),E=E+I|0,U=ee(U^E,7),B=B+k|0,j=ee(j^B,16),b=b+j|0,k=ee(k^b,12),B=B+k|0,j=ee(j^B,8),b=b+j|0,k=ee(k^b,7),S=S+V|0,L=ee(L^S,16),O=O+L|0,V=ee(V^O,12),S=S+V|0,L=ee(L^S,8),O=O+L|0,V=ee(V^O,7),A=A+U|0,L=ee(L^A,16),b=b+L|0,U=ee(U^b,12),A=A+U|0,L=ee(L^A,8),b=b+L|0,U=ee(U^b,7),C=C+k|0,F=ee(F^C,16),O=O+F|0,k=ee(k^O,12),C=C+k|0,F=ee(F^C,8),O=O+F|0,k=ee(k^O,7),B=B+V|0,I=ee(I^B,16),N=N+I|0,V=ee(V^N,12),B=B+V|0,I=ee(I^B,8),N=N+I|0,V=ee(V^N,7),S=S+H|0,j=ee(j^S,16),E=E+j|0,H=ee(H^E,12),S=S+H|0,j=ee(j^S,8),E=E+j|0,H=ee(H^E,7);let M=0;s[M++]=a+A|0,s[M++]=c+C|0,s[M++]=h+B|0,s[M++]=d+S|0,s[M++]=u+H|0,s[M++]=p+U|0,s[M++]=g+k|0,s[M++]=_+V|0,s[M++]=f+N|0,s[M++]=y+E|0,s[M++]=m+b|0,s[M++]=v+O|0,s[M++]=w+F|0,s[M++]=x+I|0,s[M++]=P+j|0,s[M++]=R+L|0}const xf=_f(vf,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Ef=new Uint8Array(16),rc=(i,e)=>{i.update(e);const t=e.length%16;t&&i.update(Ef.subarray(t))},If=new Uint8Array(32);function oc(i,e,t,s,r){const o=i(e,t,If),a=bf.create(o);r&&rc(a,r),rc(a,s);const c=new Uint8Array(16),h=rf(c);tc(h,0,BigInt(r?r.length:0),!0),tc(h,8,BigInt(s.length),!0),a.update(c);const d=a.digest();return mi(o,c),d}const Pf=i=>(e,t,s)=>({encrypt(r,o){const a=r.length;o=ec(a+16,o,!1),o.set(r);const c=o.subarray(0,-16);i(e,t,c,c,1);const h=oc(i,e,t,c,s);return o.set(h,a),mi(h),o},decrypt(r,o){o=ec(r.length-16,o,!1);const a=r.subarray(0,-16),c=r.subarray(-16),h=oc(i,e,t,a,s);if(!cf(c,h))throw new Error("invalid tag");return o.set(r.subarray(0,-16)),i(e,t,o,o,1),mi(h),o}}),ac=hf({blockSize:64,nonceLength:12,tagLength:16},Pf(xf));class cc extends Mn{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Ln(e);const s=fi(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,o=new Uint8Array(r);o.set(s.length>r?e.create().update(s).digest():s);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return pi(this),this.iHash.update(e),this}digestInto(e){pi(this),es(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:s,finished:r,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=r,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=s._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const js=(i,e,t)=>new cc(i,e).update(t).digest();js.create=(i,e)=>new cc(i,e);function Sf(i,e,t){return Ln(i),t===void 0&&(t=new Uint8Array(i.outputLen)),js(i,fi(t),fi(e))}const Qn=new Uint8Array([0]),hc=new Uint8Array;function Of(i,e,t,s=32){if(Ln(i),Xi(s),s>255*i.outputLen)throw new Error("Length should be <= 255*HashLen");const r=Math.ceil(s/i.outputLen);t===void 0&&(t=hc);const o=new Uint8Array(r*i.outputLen),a=js.create(i,e),c=a._cloneInto(),h=new Uint8Array(a.outputLen);for(let d=0;d<r;d++)Qn[0]=d+1,c.update(d===0?hc:h).update(t).update(Qn).digestInto(h),o.set(h,i.outputLen*d),a._cloneInto(c);return a.destroy(),c.destroy(),h.fill(0),Qn.fill(0),o.slice(0,s)}const Af=(i,e,t,s,r)=>Of(i,Sf(i,e,t),s,r);function Cf(i,e,t,s){if(typeof i.setBigUint64=="function")return i.setBigUint64(e,t,s);const r=BigInt(32),o=BigInt(4294967295),a=Number(t>>r&o),c=Number(t&o),h=s?4:0,d=s?0:4;i.setUint32(e+h,a,s),i.setUint32(e+d,c,s)}function Rf(i,e,t){return i&e^~i&t}function Ff(i,e,t){return i&e^i&t^e&t}class Nf extends Mn{constructor(e,t,s,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=s,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=kn(this.buffer)}update(e){pi(this);const{view:t,buffer:s,blockLen:r}=this;e=fi(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(r-this.pos,o-a);if(c===r){const h=kn(e);for(;r<=o-a;a+=r)this.process(h,a);continue}s.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){pi(this),Ra(e,this),this.finished=!0;const{buffer:t,view:s,blockLen:r,isLE:o}=this;let{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>r-a&&(this.process(s,0),a=0);for(let p=a;p<r;p++)t[p]=0;Cf(s,r-8,BigInt(this.length*8),o),this.process(s,0);const c=kn(e),h=this.outputLen;if(h%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=h/4,u=this.get();if(d>u.length)throw new Error("_sha2: outputLen bigger than state");for(let p=0;p<d;p++)c.setUint32(4*p,u[p],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:s,length:r,finished:o,destroyed:a,pos:c}=this;return e.length=r,e.pos=c,e.finished=o,e.destroyed=a,r%t&&e.buffer.set(s),e}}const Tf=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ut=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Lt=new Uint32Array(64);class Bf extends Nf{constructor(){super(64,32,8,!1),this.A=Ut[0]|0,this.B=Ut[1]|0,this.C=Ut[2]|0,this.D=Ut[3]|0,this.E=Ut[4]|0,this.F=Ut[5]|0,this.G=Ut[6]|0,this.H=Ut[7]|0}get(){const{A:e,B:t,C:s,D:r,E:o,F:a,G:c,H:h}=this;return[e,t,s,r,o,a,c,h]}set(e,t,s,r,o,a,c,h){this.A=e|0,this.B=t|0,this.C=s|0,this.D=r|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=h|0}process(e,t){for(let p=0;p<16;p++,t+=4)Lt[p]=e.getUint32(t,!1);for(let p=16;p<64;p++){const g=Lt[p-15],_=Lt[p-2],f=ft(g,7)^ft(g,18)^g>>>3,y=ft(_,17)^ft(_,19)^_>>>10;Lt[p]=y+Lt[p-7]+f+Lt[p-16]|0}let{A:s,B:r,C:o,D:a,E:c,F:h,G:d,H:u}=this;for(let p=0;p<64;p++){const g=ft(c,6)^ft(c,11)^ft(c,25),_=u+g+Rf(c,h,d)+Tf[p]+Lt[p]|0,f=(ft(s,2)^ft(s,13)^ft(s,22))+Ff(s,r,o)|0;u=d,d=h,h=c,c=a+_|0,a=o,o=r,r=s,s=_+f|0}s=s+this.A|0,r=r+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,h=h+this.F|0,d=d+this.G|0,u=u+this.H|0,this.set(s,r,o,a,c,h,d,u)}roundClean(){Lt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const is=Ba(()=>new Bf);const qs=BigInt(0),Us=BigInt(1),Df=BigInt(2);function Yt(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function ss(i){if(!Yt(i))throw new Error("Uint8Array expected")}function wi(i,e){if(typeof e!="boolean")throw new Error(i+" boolean expected, got "+e)}const $f=Array.from({length:256},(i,e)=>e.toString(16).padStart(2,"0"));function bi(i){ss(i);let e="";for(let t=0;t<i.length;t++)e+=$f[i[t]];return e}function vi(i){const e=i.toString(16);return e.length&1?"0"+e:e}function Xn(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);return i===""?qs:BigInt("0x"+i)}const St={_0:48,_9:57,A:65,F:70,a:97,f:102};function dc(i){if(i>=St._0&&i<=St._9)return i-St._0;if(i>=St.A&&i<=St.F)return i-(St.A-10);if(i>=St.a&&i<=St.f)return i-(St.a-10)}function xi(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);const e=i.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const s=new Uint8Array(t);for(let r=0,o=0;r<t;r++,o+=2){const a=dc(i.charCodeAt(o)),c=dc(i.charCodeAt(o+1));if(a===void 0||c===void 0){const h=i[o]+i[o+1];throw new Error('hex string expected, got non-hex character "'+h+'" at index '+o)}s[r]=a*16+c}return s}function Qt(i){return Xn(bi(i))}function ns(i){return ss(i),Xn(bi(Uint8Array.from(i).reverse()))}function Ei(i,e){return xi(i.toString(16).padStart(e*2,"0"))}function Ls(i,e){return Ei(i,e).reverse()}function jf(i){return xi(vi(i))}function Ve(i,e,t){let s;if(typeof e=="string")try{s=xi(e)}catch(o){throw new Error(i+" must be hex string or Uint8Array, cause: "+o)}else if(Yt(e))s=Uint8Array.from(e);else throw new Error(i+" must be hex string or Uint8Array");const r=s.length;if(typeof t=="number"&&r!==t)throw new Error(i+" of length "+t+" expected, got "+r);return s}function rs(...i){let e=0;for(let s=0;s<i.length;s++){const r=i[s];ss(r),e+=r.length}const t=new Uint8Array(e);for(let s=0,r=0;s<i.length;s++){const o=i[s];t.set(o,r),r+=o.length}return t}function qf(i,e){if(i.length!==e.length)return!1;let t=0;for(let s=0;s<i.length;s++)t|=i[s]^e[s];return t===0}function Uf(i){if(typeof i!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(i))}const er=i=>typeof i=="bigint"&&qs<=i;function ks(i,e,t){return er(i)&&er(e)&&er(t)&&e<=i&&i<t}function Ot(i,e,t,s){if(!ks(e,t,s))throw new Error("expected valid "+i+": "+t+" <= n < "+s+", got "+e)}function lc(i){let e;for(e=0;i>qs;i>>=Us,e+=1);return e}function Lf(i,e){return i>>BigInt(e)&Us}function kf(i,e,t){return i|(t?Us:qs)<<BigInt(e)}const tr=i=>(Df<<BigInt(i-1))-Us,ir=i=>new Uint8Array(i),uc=i=>Uint8Array.from(i);function pc(i,e,t){if(typeof i!="number"||i<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let s=ir(i),r=ir(i),o=0;const a=()=>{s.fill(1),r.fill(0),o=0},c=(...u)=>t(r,s,...u),h=(u=ir())=>{r=c(uc([0]),u),s=c(),u.length!==0&&(r=c(uc([1]),u),s=c())},d=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const p=[];for(;u<e;){s=c();const g=s.slice();p.push(g),u+=s.length}return rs(...p)};return(u,p)=>{a(),h(u);let g;for(;!(g=p(d()));)h();return a(),g}}const Mf={bigint:i=>typeof i=="bigint",function:i=>typeof i=="function",boolean:i=>typeof i=="boolean",string:i=>typeof i=="string",stringOrUint8Array:i=>typeof i=="string"||Yt(i),isSafeInteger:i=>Number.isSafeInteger(i),array:i=>Array.isArray(i),field:(i,e)=>e.Fp.isValid(i),hash:i=>typeof i=="function"&&Number.isSafeInteger(i.outputLen)};function Ii(i,e,t={}){const s=(r,o,a)=>{const c=Mf[o];if(typeof c!="function")throw new Error("invalid validator function");const h=i[r];if(!(a&&h===void 0)&&!c(h,i))throw new Error("param "+String(r)+" is invalid. Expected "+o+", got "+h)};for(const[r,o]of Object.entries(e))s(r,o,!1);for(const[r,o]of Object.entries(t))s(r,o,!0);return i}const zf=()=>{throw new Error("not implemented")};function sr(i){const e=new WeakMap;return(t,...s)=>{const r=e.get(t);if(r!==void 0)return r;const o=i(t,...s);return e.set(t,o),o}}var Hf=Object.freeze({__proto__:null,isBytes:Yt,abytes:ss,abool:wi,bytesToHex:bi,numberToHexUnpadded:vi,hexToNumber:Xn,hexToBytes:xi,bytesToNumberBE:Qt,bytesToNumberLE:ns,numberToBytesBE:Ei,numberToBytesLE:Ls,numberToVarBytesBE:jf,ensureBytes:Ve,concatBytes:rs,equalBytes:qf,utf8ToBytes:Uf,inRange:ks,aInRange:Ot,bitLen:lc,bitGet:Lf,bitSet:kf,bitMask:tr,createHmacDrbg:pc,validateObject:Ii,notImplemented:zf,memoized:sr});const ve=BigInt(0),fe=BigInt(1),Xt=BigInt(2),Vf=BigInt(3),nr=BigInt(4),gc=BigInt(5),fc=BigInt(8);function ke(i,e){const t=i%e;return t>=ve?t:e+t}function yc(i,e,t){if(e<ve)throw new Error("invalid exponent, negatives unsupported");if(t<=ve)throw new Error("invalid modulus");if(t===fe)return ve;let s=fe;for(;e>ve;)e&fe&&(s=s*i%t),i=i*i%t,e>>=fe;return s}function ot(i,e,t){let s=i;for(;e-- >ve;)s*=s,s%=t;return s}function rr(i,e){if(i===ve)throw new Error("invert: expected non-zero number");if(e<=ve)throw new Error("invert: expected positive modulus, got "+e);let t=ke(i,e),s=e,r=ve,o=fe;for(;t!==ve;){const a=s/t,c=s%t,h=r-o*a;s=t,t=c,r=o,o=h}if(s!==fe)throw new Error("invert: does not exist");return ke(r,e)}function Kf(i){const e=(i-fe)/Xt;let t,s,r;for(t=i-fe,s=0;t%Xt===ve;t/=Xt,s++);for(r=Xt;r<i&&yc(r,e,i)!==i-fe;r++)if(r>1e3)throw new Error("Cannot find square root: likely non-prime P");if(s===1){const a=(i+fe)/nr;return function(c,h){const d=c.pow(h,a);if(!c.eql(c.sqr(d),h))throw new Error("Cannot find square root");return d}}const o=(t+fe)/Xt;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let h=s,d=a.pow(a.mul(a.ONE,r),t),u=a.pow(c,o),p=a.pow(c,t);for(;!a.eql(p,a.ONE);){if(a.eql(p,a.ZERO))return a.ZERO;let g=1;for(let f=a.sqr(p);g<h&&!a.eql(f,a.ONE);g++)f=a.sqr(f);const _=a.pow(d,fe<<BigInt(h-g-1));d=a.sqr(_),u=a.mul(u,_),p=a.mul(p,d),h=g}return u}}function Gf(i){if(i%nr===Vf){const e=(i+fe)/nr;return function(t,s){const r=t.pow(s,e);if(!t.eql(t.sqr(r),s))throw new Error("Cannot find square root");return r}}if(i%fc===gc){const e=(i-gc)/fc;return function(t,s){const r=t.mul(s,Xt),o=t.pow(r,e),a=t.mul(s,o),c=t.mul(t.mul(a,Xt),o),h=t.mul(a,t.sub(c,t.ONE));if(!t.eql(t.sqr(h),s))throw new Error("Cannot find square root");return h}}return Kf(i)}const Wf=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Jf(i){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Wf.reduce((s,r)=>(s[r]="function",s),e);return Ii(i,t)}function Zf(i,e,t){if(t<ve)throw new Error("invalid exponent, negatives unsupported");if(t===ve)return i.ONE;if(t===fe)return e;let s=i.ONE,r=e;for(;t>ve;)t&fe&&(s=i.mul(s,r)),r=i.sqr(r),t>>=fe;return s}function Yf(i,e){const t=new Array(e.length),s=e.reduce((o,a,c)=>i.is0(a)?o:(t[c]=o,i.mul(o,a)),i.ONE),r=i.inv(s);return e.reduceRight((o,a,c)=>i.is0(a)?o:(t[c]=i.mul(o,t[c]),i.mul(o,a)),r),t}function _c(i,e){const t=e!==void 0?e:i.toString(2).length,s=Math.ceil(t/8);return{nBitLength:t,nByteLength:s}}function mc(i,e,t=!1,s={}){if(i<=ve)throw new Error("invalid field: expected ORDER > 0, got "+i);const{nBitLength:r,nByteLength:o}=_c(i,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const c=Object.freeze({ORDER:i,isLE:t,BITS:r,BYTES:o,MASK:tr(r),ZERO:ve,ONE:fe,create:h=>ke(h,i),isValid:h=>{if(typeof h!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof h);return ve<=h&&h<i},is0:h=>h===ve,isOdd:h=>(h&fe)===fe,neg:h=>ke(-h,i),eql:(h,d)=>h===d,sqr:h=>ke(h*h,i),add:(h,d)=>ke(h+d,i),sub:(h,d)=>ke(h-d,i),mul:(h,d)=>ke(h*d,i),pow:(h,d)=>Zf(c,h,d),div:(h,d)=>ke(h*rr(d,i),i),sqrN:h=>h*h,addN:(h,d)=>h+d,subN:(h,d)=>h-d,mulN:(h,d)=>h*d,inv:h=>rr(h,i),sqrt:s.sqrt||(h=>(a||(a=Gf(i)),a(c,h))),invertBatch:h=>Yf(c,h),cmov:(h,d,u)=>u?d:h,toBytes:h=>t?Ls(h,o):Ei(h,o),fromBytes:h=>{if(h.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+h.length);return t?ns(h):Qt(h)}});return Object.freeze(c)}function wc(i){if(typeof i!="bigint")throw new Error("field order must be bigint");const e=i.toString(2).length;return Math.ceil(e/8)}function bc(i){const e=wc(i);return e+Math.ceil(e/2)}function Qf(i,e,t=!1){const s=i.length,r=wc(e),o=bc(e);if(s<16||s<o||s>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+s);const a=t?ns(i):Qt(i),c=ke(a,e-fe)+fe;return t?Ls(c,r):Ei(c,r)}const vc=BigInt(0),Ms=BigInt(1);function or(i,e){const t=e.negate();return i?t:e}function xc(i,e){if(!Number.isSafeInteger(i)||i<=0||i>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+i)}function ar(i,e){xc(i,e);const t=Math.ceil(e/i)+1,s=2**(i-1);return{windows:t,windowSize:s}}function Xf(i,e){if(!Array.isArray(i))throw new Error("array expected");i.forEach((t,s)=>{if(!(t instanceof e))throw new Error("invalid point at index "+s)})}function ey(i,e){if(!Array.isArray(i))throw new Error("array of scalars expected");i.forEach((t,s)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+s)})}const cr=new WeakMap,Ec=new WeakMap;function hr(i){return Ec.get(i)||1}function ty(i,e){return{constTimeNegate:or,hasPrecomputes(t){return hr(t)!==1},unsafeLadder(t,s,r=i.ZERO){let o=t;for(;s>vc;)s&Ms&&(r=r.add(o)),o=o.double(),s>>=Ms;return r},precomputeWindow(t,s){const{windows:r,windowSize:o}=ar(s,e),a=[];let c=t,h=c;for(let d=0;d<r;d++){h=c,a.push(h);for(let u=1;u<o;u++)h=h.add(c),a.push(h);c=h.double()}return a},wNAF(t,s,r){const{windows:o,windowSize:a}=ar(t,e);let c=i.ZERO,h=i.BASE;const d=BigInt(2**t-1),u=2**t,p=BigInt(t);for(let g=0;g<o;g++){const _=g*a;let f=Number(r&d);r>>=p,f>a&&(f-=u,r+=Ms);const y=_,m=_+Math.abs(f)-1,v=g%2!==0,w=f<0;f===0?h=h.add(or(v,s[y])):c=c.add(or(w,s[m]))}return{p:c,f:h}},wNAFUnsafe(t,s,r,o=i.ZERO){const{windows:a,windowSize:c}=ar(t,e),h=BigInt(2**t-1),d=2**t,u=BigInt(t);for(let p=0;p<a;p++){const g=p*c;if(r===vc)break;let _=Number(r&h);if(r>>=u,_>c&&(_-=d,r+=Ms),_===0)continue;let f=s[g+Math.abs(_)-1];_<0&&(f=f.negate()),o=o.add(f)}return o},getPrecomputes(t,s,r){let o=cr.get(s);return o||(o=this.precomputeWindow(s,t),t!==1&&cr.set(s,r(o))),o},wNAFCached(t,s,r){const o=hr(t);return this.wNAF(o,this.getPrecomputes(o,t,r),s)},wNAFCachedUnsafe(t,s,r,o){const a=hr(t);return a===1?this.unsafeLadder(t,s,o):this.wNAFUnsafe(a,this.getPrecomputes(a,t,r),s,o)},setWindowSize(t,s){xc(s,e),Ec.set(t,s),cr.delete(t)}}}function iy(i,e,t,s){if(Xf(t,i),ey(s,e),t.length!==s.length)throw new Error("arrays of points and scalars must have equal length");const r=i.ZERO,o=lc(BigInt(t.length)),a=o>12?o-3:o>4?o-2:o?2:1,c=(1<<a)-1,h=new Array(c+1).fill(r),d=Math.floor((e.BITS-1)/a)*a;let u=r;for(let p=d;p>=0;p-=a){h.fill(r);for(let _=0;_<s.length;_++){const f=s[_],y=Number(f>>BigInt(p)&BigInt(c));h[y]=h[y].add(t[_])}let g=r;for(let _=h.length-1,f=r;_>0;_--)f=f.add(h[_]),g=g.add(f);if(u=u.add(g),p!==0)for(let _=0;_<a;_++)u=u.double()}return u}function Ic(i){return Jf(i.Fp),Ii(i,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({..._c(i.n,i.nBitLength),...i,p:i.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const Pi=BigInt(0),dr=BigInt(1);function sy(i){return Ii(i,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...i})}function ny(i){const e=sy(i),{P:t}=e,s=w=>ke(w,t),r=e.montgomeryBits,o=Math.ceil(r/8),a=e.nByteLength,c=e.adjustScalarBytes||(w=>w),h=e.powPminus2||(w=>yc(w,t-BigInt(2),t));function d(w,x,P){const R=s(w*(x-P));return x=s(x-R),P=s(P+R),[x,P]}const u=(e.a-BigInt(2))/BigInt(4);function p(w,x){Ot("u",w,Pi,t),Ot("scalar",x,Pi,t);const P=x,R=w;let A=dr,C=Pi,B=w,S=dr,H=Pi,U;for(let V=BigInt(r-1);V>=Pi;V--){const N=P>>V&dr;H^=N,U=d(H,A,B),A=U[0],B=U[1],U=d(H,C,S),C=U[0],S=U[1],H=N;const E=A+C,b=s(E*E),O=A-C,F=s(O*O),I=b-F,j=B+S,L=B-S,M=s(L*E),K=s(j*O),G=M+K,J=M-K;B=s(G*G),S=s(R*s(J*J)),A=s(b*F),C=s(I*(b+s(u*I)))}U=d(H,A,B),A=U[0],B=U[1],U=d(H,C,S),C=U[0],S=U[1];const k=h(C);return s(A*k)}function g(w){return Ls(s(w),o)}function _(w){const x=Ve("u coordinate",w,o);return a===32&&(x[31]&=127),ns(x)}function f(w){const x=Ve("scalar",w),P=x.length;if(P!==o&&P!==a){let R=""+o+" or "+a;throw new Error("invalid scalar, expected "+R+" bytes, got "+P)}return ns(c(x))}function y(w,x){const P=_(x),R=f(w),A=p(P,R);if(A===Pi)throw new Error("invalid private or public key received");return g(A)}const m=g(e.Gu);function v(w){return y(w,m)}return{scalarMult:y,scalarMultBase:v,getSharedSecret:(w,x)=>y(w,x),getPublicKey:w=>v(w),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:m}}const lr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const ry=BigInt(1),Pc=BigInt(2),oy=BigInt(3),ay=BigInt(5);BigInt(8);function cy(i){const e=BigInt(10),t=BigInt(20),s=BigInt(40),r=BigInt(80),o=lr,a=i*i%o*i%o,c=ot(a,Pc,o)*a%o,h=ot(c,ry,o)*i%o,d=ot(h,ay,o)*h%o,u=ot(d,e,o)*d%o,p=ot(u,t,o)*u%o,g=ot(p,s,o)*p%o,_=ot(g,r,o)*g%o,f=ot(_,r,o)*g%o,y=ot(f,e,o)*d%o;return{pow_p_5_8:ot(y,Pc,o)*i%o,b2:a}}function hy(i){return i[0]&=248,i[31]&=127,i[31]|=64,i}const ur=ny({P:lr,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:i=>{const e=lr,{pow_p_5_8:t,b2:s}=cy(i);return ke(ot(t,oy,e)*s,e)},adjustScalarBytes:hy,randomBytes:yi});function Sc(i){i.lowS!==void 0&&wi("lowS",i.lowS),i.prehash!==void 0&&wi("prehash",i.prehash)}function dy(i){const e=Ic(i);Ii(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:s,a:r}=e;if(t){if(!s.eql(r,s.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:ly,hexToBytes:uy}=Hf;class py extends Error{constructor(e=""){super(e)}}const At={Err:py,_tlv:{encode:(i,e)=>{const{Err:t}=At;if(i<0||i>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const s=e.length/2,r=vi(s);if(r.length/2&128)throw new t("tlv.encode: long form length too big");const o=s>127?vi(r.length/2|128):"";return vi(i)+o+r+e},decode(i,e){const{Err:t}=At;let s=0;if(i<0||i>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[s++]!==i)throw new t("tlv.decode: wrong tlv");const r=e[s++],o=!!(r&128);let a=0;if(!o)a=r;else{const h=r&127;if(!h)throw new t("tlv.decode(long): indefinite length not supported");if(h>4)throw new t("tlv.decode(long): byte length is too big");const d=e.subarray(s,s+h);if(d.length!==h)throw new t("tlv.decode: length bytes not complete");if(d[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of d)a=a<<8|u;if(s+=h,a<128)throw new t("tlv.decode(long): not minimal encoding")}const c=e.subarray(s,s+a);if(c.length!==a)throw new t("tlv.decode: wrong value length");return{v:c,l:e.subarray(s+a)}}},_int:{encode(i){const{Err:e}=At;if(i<Ct)throw new e("integer: negative integers are not allowed");let t=vi(i);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(i){const{Err:e}=At;if(i[0]&128)throw new e("invalid signature integer: negative");if(i[0]===0&&!(i[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return ly(i)}},toSig(i){const{Err:e,_int:t,_tlv:s}=At,r=typeof i=="string"?uy(i):i;ss(r);const{v:o,l:a}=s.decode(48,r);if(a.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:h}=s.decode(2,o),{v:d,l:u}=s.decode(2,h);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(d)}},hexFromSig(i){const{_tlv:e,_int:t}=At,s=e.encode(2,t.encode(i.r)),r=e.encode(2,t.encode(i.s)),o=s+r;return e.encode(48,o)}},Ct=BigInt(0),xe=BigInt(1);BigInt(2);const Oc=BigInt(3);BigInt(4);function gy(i){const e=dy(i),{Fp:t}=e,s=mc(e.n,e.nBitLength),r=e.toBytes||((y,m,v)=>{const w=m.toAffine();return rs(Uint8Array.from([4]),t.toBytes(w.x),t.toBytes(w.y))}),o=e.fromBytes||(y=>{const m=y.subarray(1),v=t.fromBytes(m.subarray(0,t.BYTES)),w=t.fromBytes(m.subarray(t.BYTES,2*t.BYTES));return{x:v,y:w}});function a(y){const{a:m,b:v}=e,w=t.sqr(y),x=t.mul(w,y);return t.add(t.add(x,t.mul(y,m)),v)}if(!t.eql(t.sqr(e.Gy),a(e.Gx)))throw new Error("bad generator point: equation left != right");function c(y){return ks(y,xe,e.n)}function h(y){const{allowedPrivateKeyLengths:m,nByteLength:v,wrapPrivateKey:w,n:x}=e;if(m&&typeof y!="bigint"){if(Yt(y)&&(y=bi(y)),typeof y!="string"||!m.includes(y.length))throw new Error("invalid private key");y=y.padStart(v*2,"0")}let P;try{P=typeof y=="bigint"?y:Qt(Ve("private key",y,v))}catch{throw new Error("invalid private key, expected hex or "+v+" bytes, got "+typeof y)}return w&&(P=ke(P,x)),Ot("private key",P,xe,x),P}function d(y){if(!(y instanceof g))throw new Error("ProjectivePoint expected")}const u=sr((y,m)=>{const{px:v,py:w,pz:x}=y;if(t.eql(x,t.ONE))return{x:v,y:w};const P=y.is0();m==null&&(m=P?t.ONE:t.inv(x));const R=t.mul(v,m),A=t.mul(w,m),C=t.mul(x,m);if(P)return{x:t.ZERO,y:t.ZERO};if(!t.eql(C,t.ONE))throw new Error("invZ was invalid");return{x:R,y:A}}),p=sr(y=>{if(y.is0()){if(e.allowInfinityPoint&&!t.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:m,y:v}=y.toAffine();if(!t.isValid(m)||!t.isValid(v))throw new Error("bad point: x or y not FE");const w=t.sqr(v),x=a(m);if(!t.eql(w,x))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(m,v,w){if(this.px=m,this.py=v,this.pz=w,m==null||!t.isValid(m))throw new Error("x required");if(v==null||!t.isValid(v))throw new Error("y required");if(w==null||!t.isValid(w))throw new Error("z required");Object.freeze(this)}static fromAffine(m){const{x:v,y:w}=m||{};if(!m||!t.isValid(v)||!t.isValid(w))throw new Error("invalid affine point");if(m instanceof g)throw new Error("projective point not allowed");const x=P=>t.eql(P,t.ZERO);return x(v)&&x(w)?g.ZERO:new g(v,w,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(m){const v=t.invertBatch(m.map(w=>w.pz));return m.map((w,x)=>w.toAffine(v[x])).map(g.fromAffine)}static fromHex(m){const v=g.fromAffine(o(Ve("pointHex",m)));return v.assertValidity(),v}static fromPrivateKey(m){return g.BASE.multiply(h(m))}static msm(m,v){return iy(g,s,m,v)}_setWindowSize(m){f.setWindowSize(this,m)}assertValidity(){p(this)}hasEvenY(){const{y:m}=this.toAffine();if(t.isOdd)return!t.isOdd(m);throw new Error("Field doesn't support isOdd")}equals(m){d(m);const{px:v,py:w,pz:x}=this,{px:P,py:R,pz:A}=m,C=t.eql(t.mul(v,A),t.mul(P,x)),B=t.eql(t.mul(w,A),t.mul(R,x));return C&&B}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a:m,b:v}=e,w=t.mul(v,Oc),{px:x,py:P,pz:R}=this;let A=t.ZERO,C=t.ZERO,B=t.ZERO,S=t.mul(x,x),H=t.mul(P,P),U=t.mul(R,R),k=t.mul(x,P);return k=t.add(k,k),B=t.mul(x,R),B=t.add(B,B),A=t.mul(m,B),C=t.mul(w,U),C=t.add(A,C),A=t.sub(H,C),C=t.add(H,C),C=t.mul(A,C),A=t.mul(k,A),B=t.mul(w,B),U=t.mul(m,U),k=t.sub(S,U),k=t.mul(m,k),k=t.add(k,B),B=t.add(S,S),S=t.add(B,S),S=t.add(S,U),S=t.mul(S,k),C=t.add(C,S),U=t.mul(P,R),U=t.add(U,U),S=t.mul(U,k),A=t.sub(A,S),B=t.mul(U,H),B=t.add(B,B),B=t.add(B,B),new g(A,C,B)}add(m){d(m);const{px:v,py:w,pz:x}=this,{px:P,py:R,pz:A}=m;let C=t.ZERO,B=t.ZERO,S=t.ZERO;const H=e.a,U=t.mul(e.b,Oc);let k=t.mul(v,P),V=t.mul(w,R),N=t.mul(x,A),E=t.add(v,w),b=t.add(P,R);E=t.mul(E,b),b=t.add(k,V),E=t.sub(E,b),b=t.add(v,x);let O=t.add(P,A);return b=t.mul(b,O),O=t.add(k,N),b=t.sub(b,O),O=t.add(w,x),C=t.add(R,A),O=t.mul(O,C),C=t.add(V,N),O=t.sub(O,C),S=t.mul(H,b),C=t.mul(U,N),S=t.add(C,S),C=t.sub(V,S),S=t.add(V,S),B=t.mul(C,S),V=t.add(k,k),V=t.add(V,k),N=t.mul(H,N),b=t.mul(U,b),V=t.add(V,N),N=t.sub(k,N),N=t.mul(H,N),b=t.add(b,N),k=t.mul(V,b),B=t.add(B,k),k=t.mul(O,b),C=t.mul(E,C),C=t.sub(C,k),k=t.mul(E,V),S=t.mul(O,S),S=t.add(S,k),new g(C,B,S)}subtract(m){return this.add(m.negate())}is0(){return this.equals(g.ZERO)}wNAF(m){return f.wNAFCached(this,m,g.normalizeZ)}multiplyUnsafe(m){const{endo:v,n:w}=e;Ot("scalar",m,Ct,w);const x=g.ZERO;if(m===Ct)return x;if(this.is0()||m===xe)return this;if(!v||f.hasPrecomputes(this))return f.wNAFCachedUnsafe(this,m,g.normalizeZ);let{k1neg:P,k1:R,k2neg:A,k2:C}=v.splitScalar(m),B=x,S=x,H=this;for(;R>Ct||C>Ct;)R&xe&&(B=B.add(H)),C&xe&&(S=S.add(H)),H=H.double(),R>>=xe,C>>=xe;return P&&(B=B.negate()),A&&(S=S.negate()),S=new g(t.mul(S.px,v.beta),S.py,S.pz),B.add(S)}multiply(m){const{endo:v,n:w}=e;Ot("scalar",m,xe,w);let x,P;if(v){const{k1neg:R,k1:A,k2neg:C,k2:B}=v.splitScalar(m);let{p:S,f:H}=this.wNAF(A),{p:U,f:k}=this.wNAF(B);S=f.constTimeNegate(R,S),U=f.constTimeNegate(C,U),U=new g(t.mul(U.px,v.beta),U.py,U.pz),x=S.add(U),P=H.add(k)}else{const{p:R,f:A}=this.wNAF(m);x=R,P=A}return g.normalizeZ([x,P])[0]}multiplyAndAddUnsafe(m,v,w){const x=g.BASE,P=(A,C)=>C===Ct||C===xe||!A.equals(x)?A.multiplyUnsafe(C):A.multiply(C),R=P(this,v).add(P(m,w));return R.is0()?void 0:R}toAffine(m){return u(this,m)}isTorsionFree(){const{h:m,isTorsionFree:v}=e;if(m===xe)return!0;if(v)return v(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:m,clearCofactor:v}=e;return m===xe?this:v?v(g,this):this.multiplyUnsafe(e.h)}toRawBytes(m=!0){return wi("isCompressed",m),this.assertValidity(),r(g,this,m)}toHex(m=!0){return wi("isCompressed",m),bi(this.toRawBytes(m))}}g.BASE=new g(e.Gx,e.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const _=e.nBitLength,f=ty(g,e.endo?Math.ceil(_/2):_);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:h,weierstrassEquation:a,isWithinCurveOrder:c}}function fy(i){const e=Ic(i);return Ii(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function yy(i){const e=fy(i),{Fp:t,n:s}=e,r=t.BYTES+1,o=2*t.BYTES+1;function a(N){return ke(N,s)}function c(N){return rr(N,s)}const{ProjectivePoint:h,normPrivateKeyToScalar:d,weierstrassEquation:u,isWithinCurveOrder:p}=gy({...e,toBytes(N,E,b){const O=E.toAffine(),F=t.toBytes(O.x),I=rs;return wi("isCompressed",b),b?I(Uint8Array.from([E.hasEvenY()?2:3]),F):I(Uint8Array.from([4]),F,t.toBytes(O.y))},fromBytes(N){const E=N.length,b=N[0],O=N.subarray(1);if(E===r&&(b===2||b===3)){const F=Qt(O);if(!ks(F,xe,t.ORDER))throw new Error("Point is not on curve");const I=u(F);let j;try{j=t.sqrt(I)}catch(M){const K=M instanceof Error?": "+M.message:"";throw new Error("Point is not on curve"+K)}const L=(j&xe)===xe;return(b&1)===1!==L&&(j=t.neg(j)),{x:F,y:j}}else if(E===o&&b===4){const F=t.fromBytes(O.subarray(0,t.BYTES)),I=t.fromBytes(O.subarray(t.BYTES,2*t.BYTES));return{x:F,y:I}}else{const F=r,I=o;throw new Error("invalid Point, expected length of "+F+", or uncompressed "+I+", got "+E)}}}),g=N=>bi(Ei(N,e.nByteLength));function _(N){const E=s>>xe;return N>E}function f(N){return _(N)?a(-N):N}const y=(N,E,b)=>Qt(N.slice(E,b));class m{constructor(E,b,O){this.r=E,this.s=b,this.recovery=O,this.assertValidity()}static fromCompact(E){const b=e.nByteLength;return E=Ve("compactSignature",E,b*2),new m(y(E,0,b),y(E,b,2*b))}static fromDER(E){const{r:b,s:O}=At.toSig(Ve("DER",E));return new m(b,O)}assertValidity(){Ot("r",this.r,xe,s),Ot("s",this.s,xe,s)}addRecoveryBit(E){return new m(this.r,this.s,E)}recoverPublicKey(E){const{r:b,s:O,recovery:F}=this,I=A(Ve("msgHash",E));if(F==null||![0,1,2,3].includes(F))throw new Error("recovery id invalid");const j=F===2||F===3?b+e.n:b;if(j>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const L=F&1?"03":"02",M=h.fromHex(L+g(j)),K=c(j),G=a(-I*K),J=a(O*K),X=h.BASE.multiplyAndAddUnsafe(M,G,J);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return _(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return xi(this.toDERHex())}toDERHex(){return At.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return xi(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const v={isValidPrivateKey(N){try{return d(N),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const N=bc(e.n);return Qf(e.randomBytes(N),e.n)},precompute(N=8,E=h.BASE){return E._setWindowSize(N),E.multiply(BigInt(3)),E}};function w(N,E=!0){return h.fromPrivateKey(N).toRawBytes(E)}function x(N){const E=Yt(N),b=typeof N=="string",O=(E||b)&&N.length;return E?O===r||O===o:b?O===2*r||O===2*o:N instanceof h}function P(N,E,b=!0){if(x(N))throw new Error("first arg must be private key");if(!x(E))throw new Error("second arg must be public key");return h.fromHex(E).multiply(d(N)).toRawBytes(b)}const R=e.bits2int||function(N){if(N.length>8192)throw new Error("input is too large");const E=Qt(N),b=N.length*8-e.nBitLength;return b>0?E>>BigInt(b):E},A=e.bits2int_modN||function(N){return a(R(N))},C=tr(e.nBitLength);function B(N){return Ot("num < 2^"+e.nBitLength,N,Ct,C),Ei(N,e.nByteLength)}function S(N,E,b=H){if(["recovered","canonical"].some(ce=>ce in b))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:F}=e;let{lowS:I,prehash:j,extraEntropy:L}=b;I==null&&(I=!0),N=Ve("msgHash",N),Sc(b),j&&(N=Ve("prehashed msgHash",O(N)));const M=A(N),K=d(E),G=[B(K),B(M)];if(L!=null&&L!==!1){const ce=L===!0?F(t.BYTES):L;G.push(Ve("extraEntropy",ce))}const J=rs(...G),X=M;function ue(ce){const ne=R(ce);if(!p(ne))return;const De=c(ne),Te=h.BASE.multiply(ne).toAffine(),qe=a(Te.x);if(qe===Ct)return;const tt=a(De*a(X+qe*K));if(tt===Ct)return;let it=(Te.x===qe?0:2)|Number(Te.y&xe),Gi=tt;return I&&_(tt)&&(Gi=f(tt),it^=1),new m(qe,Gi,it)}return{seed:J,k2sig:ue}}const H={lowS:e.lowS,prehash:!1},U={lowS:e.lowS,prehash:!1};function k(N,E,b=H){const{seed:O,k2sig:F}=S(N,E,b),I=e;return pc(I.hash.outputLen,I.nByteLength,I.hmac)(O,F)}h.BASE._setWindowSize(8);function V(N,E,b,O=U){var tt;const F=N;E=Ve("msgHash",E),b=Ve("publicKey",b);const{lowS:I,prehash:j,format:L}=O;if(Sc(O),"strict"in O)throw new Error("options.strict was renamed to lowS");if(L!==void 0&&L!=="compact"&&L!=="der")throw new Error("format must be compact or der");const M=typeof F=="string"||Yt(F),K=!M&&!L&&typeof F=="object"&&F!==null&&typeof F.r=="bigint"&&typeof F.s=="bigint";if(!M&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let G,J;try{if(K&&(G=new m(F.r,F.s)),M){try{L!=="compact"&&(G=m.fromDER(F))}catch(it){if(!(it instanceof At.Err))throw it}!G&&L!=="der"&&(G=m.fromCompact(F))}J=h.fromHex(b)}catch{return!1}if(!G||I&&G.hasHighS())return!1;j&&(E=e.hash(E));const{r:X,s:ue}=G,ce=A(E),ne=c(ue),De=a(ce*ne),Te=a(X*ne),qe=(tt=h.BASE.multiplyAndAddUnsafe(J,De,Te))==null?void 0:tt.toAffine();return qe?a(qe.x)===X:!1}return{CURVE:e,getPublicKey:w,getSharedSecret:P,sign:k,verify:V,ProjectivePoint:h,Signature:m,utils:v}}function _y(i){return{hash:i,hmac:(e,...t)=>js(i,e,xg(...t)),randomBytes:yi}}function my(i,e){const t=s=>yy({...i,..._y(s)});return{...t(e),create:t}}const Ac=mc(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),wy=Ac.create(BigInt("-3")),by=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),vy=my({a:wy,b:by,Fp:Ac,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},is),Cc="base10",$e="base16",at="base64pad",Mt="base64url",os="utf8",Rc=0,Rt=1,as=2,xy=0,Fc=1,cs=12,pr=32;function Ey(){const i=ur.utils.randomPrivateKey(),e=ur.getPublicKey(i);return{privateKey:(0,re.BB)(i,$e),publicKey:(0,re.BB)(e,$e)}}function gr(){const i=yi(pr);return(0,re.BB)(i,$e)}function Iy(i,e){const t=ur.getSharedSecret((0,re.mL)(i,$e),(0,re.mL)(e,$e)),s=Af(is,t,void 0,void 0,pr);return(0,re.BB)(s,$e)}function zs(i){const e=is((0,re.mL)(i,$e));return(0,re.BB)(e,$e)}function yt(i){const e=is((0,re.mL)(i,os));return(0,re.BB)(e,$e)}function Nc(i){return(0,re.mL)(`${i}`,Cc)}function ei(i){return Number((0,re.BB)(i,Cc))}function Tc(i){return i.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function Bc(i){const e=i.replace(/-/g,"+").replace(/_/g,"/"),t=(4-e.length%4)%4;return e+"=".repeat(t)}function Py(i){const e=Nc(typeof i.type<"u"?i.type:Rc);if(ei(e)===Rt&&typeof i.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");const t=typeof i.senderPublicKey<"u"?(0,re.mL)(i.senderPublicKey,$e):void 0,s=typeof i.iv<"u"?(0,re.mL)(i.iv,$e):yi(cs),r=(0,re.mL)(i.symKey,$e),o=ac(r,s).encrypt((0,re.mL)(i.message,os)),a=Dc({type:e,sealed:o,iv:s,senderPublicKey:t});return i.encoding===Mt?Tc(a):a}function Sy(i){const e=(0,re.mL)(i.symKey,$e),{sealed:t,iv:s}=hs({encoded:i.encoded,encoding:i.encoding}),r=ac(e,s).decrypt(t);if(r===null)throw new Error("Failed to decrypt");return(0,re.BB)(r,os)}function Oy(i,e){const t=Nc(as),s=yi(cs),r=(0,re.mL)(i,os),o=Dc({type:t,sealed:r,iv:s});return e===Mt?Tc(o):o}function Ay(i,e){const{sealed:t}=hs({encoded:i,encoding:e});return(0,re.BB)(t,os)}function Dc(i){if(ei(i.type)===as)return(0,re.BB)((0,re.zo)([i.type,i.sealed]),at);if(ei(i.type)===Rt){if(typeof i.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");return(0,re.BB)((0,re.zo)([i.type,i.senderPublicKey,i.iv,i.sealed]),at)}return(0,re.BB)((0,re.zo)([i.type,i.iv,i.sealed]),at)}function hs(i){const e=(i.encoding||at)===Mt?Bc(i.encoded):i.encoded,t=(0,re.mL)(e,at),s=t.slice(xy,Fc),r=Fc;if(ei(s)===Rt){const h=r+pr,d=h+cs,u=t.slice(r,h),p=t.slice(h,d),g=t.slice(d);return{type:s,sealed:g,iv:p,senderPublicKey:u}}if(ei(s)===as){const h=t.slice(r),d=yi(cs);return{type:s,sealed:h,iv:d}}const o=r+cs,a=t.slice(r,o),c=t.slice(o);return{type:s,sealed:c,iv:a}}function Cy(i,e){const t=hs({encoded:i,encoding:e==null?void 0:e.encoding});return $c({type:ei(t.type),senderPublicKey:typeof t.senderPublicKey<"u"?(0,re.BB)(t.senderPublicKey,$e):void 0,receiverPublicKey:e==null?void 0:e.receiverPublicKey})}function $c(i){const e=(i==null?void 0:i.type)||Rc;if(e===Rt){if(typeof(i==null?void 0:i.senderPublicKey)>"u")throw new Error("missing sender public key");if(typeof(i==null?void 0:i.receiverPublicKey)>"u")throw new Error("missing receiver public key")}return{type:e,senderPublicKey:i==null?void 0:i.senderPublicKey,receiverPublicKey:i==null?void 0:i.receiverPublicKey}}function jc(i){return i.type===Rt&&typeof i.senderPublicKey=="string"&&typeof i.receiverPublicKey=="string"}function qc(i){return i.type===as}function Ry(i){const e=It.from(i.x,"base64"),t=It.from(i.y,"base64");return(0,re.zo)([new Uint8Array([4]),e,t])}function Fy(i,e){const[t,s,r]=i.split("."),o=It.from(Bc(r),"base64");if(o.length!==64)throw new Error("Invalid signature length");const a=o.slice(0,32),c=o.slice(32,64),h=`${t}.${s}`,d=is(h),u=Ry(e);if(!vy.verify((0,re.zo)([a,c]),d,u))throw new Error("Invalid signature");return Rs(i).payload}const Ny="irn";function Hs(i){return(i==null?void 0:i.relay)||{protocol:Ny}}function ds(i){const e=Fp.iO[i];if(typeof e>"u")throw new Error(`Relay Protocol not supported: ${i}`);return e}function Ty(i,e="-"){const t={},s="relay"+e;return Object.keys(i).forEach(r=>{if(r.startsWith(s)){const o=r.replace(s,""),a=i[r];t[o]=a}}),t}function Uc(i){if(!i.includes("wc:")){const d=Ca(i);d!=null&&d.includes("wc:")&&(i=d)}i=i.includes("wc://")?i.replace("wc://",""):i,i=i.includes("wc:")?i.replace("wc:",""):i;const e=i.indexOf(":"),t=i.indexOf("?")!==-1?i.indexOf("?"):void 0,s=i.substring(0,e),r=i.substring(e+1,t).split("@"),o=typeof t<"u"?i.substring(t):"",a=new URLSearchParams(o),c={};a.forEach((d,u)=>{c[u]=d});const h=typeof c.methods=="string"?c.methods.split(","):void 0;return{protocol:s,topic:By(r[0]),version:parseInt(r[1],10),symKey:c.symKey,relay:Ty(c),methods:h,expiryTimestamp:c.expiryTimestamp?parseInt(c.expiryTimestamp,10):void 0}}function By(i){return i.startsWith("//")?i.substring(2):i}function Dy(i,e="-"){const t="relay",s={};return Object.keys(i).forEach(r=>{const o=r,a=t+e+o;i[o]&&(s[a]=i[o])}),s}function Lc(i){const e=new URLSearchParams,t=Dy(i.relay);Object.keys(t).sort().forEach(r=>{e.set(r,t[r])}),e.set("symKey",i.symKey),i.expiryTimestamp&&e.set("expiryTimestamp",i.expiryTimestamp.toString()),i.methods&&e.set("methods",i.methods.join(","));const s=e.toString();return`${i.protocol}:${i.topic}@${i.version}?${s}`}function Vs(i,e,t){return`${i}?wc_ev=${t}&topic=${e}`}var $y=Object.defineProperty,jy=Object.defineProperties,qy=Object.getOwnPropertyDescriptors,kc=Object.getOwnPropertySymbols,Uy=Object.prototype.hasOwnProperty,Ly=Object.prototype.propertyIsEnumerable,Mc=(i,e,t)=>e in i?$y(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ky=(i,e)=>{for(var t in e||(e={}))Uy.call(e,t)&&Mc(i,t,e[t]);if(kc)for(var t of kc(e))Ly.call(e,t)&&Mc(i,t,e[t]);return i},My=(i,e)=>jy(i,qy(e));function Si(i){const e=[];return i.forEach(t=>{const[s,r]=t.split(":");e.push(`${s}:${r}`)}),e}function zy(i){const e=[];return Object.values(i).forEach(t=>{e.push(...Si(t.accounts))}),e}function Hy(i,e){const t=[];return Object.values(i).forEach(s=>{Si(s.accounts).includes(e)&&t.push(...s.methods)}),t}function Vy(i,e){const t=[];return Object.values(i).forEach(s=>{Si(s.accounts).includes(e)&&t.push(...s.events)}),t}function Lx(i,e){const t=Ws(i,e);if(t)throw new Error(t.message);const s={};for(const[r,o]of Object.entries(i))s[r]={methods:o.methods,events:o.events,chains:o.accounts.map(a=>`${a.split(":")[0]}:${a.split(":")[1]}`)};return s}function kx(i){const{proposal:{requiredNamespaces:e,optionalNamespaces:t={}},supportedNamespaces:s}=i,r=zc(e),o=zc(t),a={};Object.keys(s).forEach(d=>{const u=s[d].chains,p=s[d].methods,g=s[d].events,_=s[d].accounts;u.forEach(f=>{if(!_.some(y=>y.includes(f)))throw new Error(`No accounts provided for chain ${f} in namespace ${d}`)}),a[d]={chains:u,methods:p,events:g,accounts:_}});const c=yr(e,a,"approve()");if(c)throw new Error(c.message);const h={};return!Object.keys(e).length&&!Object.keys(t).length?a:(Object.keys(r).forEach(d=>{const u=s[d].chains.filter(f=>{var y,m;return(m=(y=r[d])==null?void 0:y.chains)==null?void 0:m.includes(f)}),p=s[d].methods.filter(f=>{var y,m;return(m=(y=r[d])==null?void 0:y.methods)==null?void 0:m.includes(f)}),g=s[d].events.filter(f=>{var y,m;return(m=(y=r[d])==null?void 0:y.events)==null?void 0:m.includes(f)}),_=u.map(f=>s[d].accounts.filter(y=>y.includes(`${f}:`))).flat();h[d]={chains:u,methods:p,events:g,accounts:_}}),Object.keys(o).forEach(d=>{var u,p,g,_,f,y;if(!s[d])return;const m=(p=(u=o[d])==null?void 0:u.chains)==null?void 0:p.filter(P=>s[d].chains.includes(P)),v=s[d].methods.filter(P=>{var R,A;return(A=(R=o[d])==null?void 0:R.methods)==null?void 0:A.includes(P)}),w=s[d].events.filter(P=>{var R,A;return(A=(R=o[d])==null?void 0:R.events)==null?void 0:A.includes(P)}),x=m==null?void 0:m.map(P=>s[d].accounts.filter(R=>R.includes(`${P}:`))).flat();h[d]={chains:rt((g=h[d])==null?void 0:g.chains,m),methods:rt((_=h[d])==null?void 0:_.methods,v),events:rt((f=h[d])==null?void 0:f.events,w),accounts:rt((y=h[d])==null?void 0:y.accounts,x)}}),h)}function Ks(i){return i.includes(":")}function Oi(i){return Ks(i)?i.split(":")[0]:i}function zc(i){var e,t,s;const r={};if(!Ai(i))return r;for(const[o,a]of Object.entries(i)){const c=Ks(o)?[o]:a.chains,h=a.methods||[],d=a.events||[],u=Oi(o);r[u]=My(ky({},r[u]),{chains:rt(c,(e=r[u])==null?void 0:e.chains),methods:rt(h,(t=r[u])==null?void 0:t.methods),events:rt(d,(s=r[u])==null?void 0:s.events)})}return r}function Ky(i){const e={};return i==null||i.forEach(t=>{var s;const[r,o]=t.split(":");e[r]||(e[r]={accounts:[],chains:[],events:[],methods:[]}),e[r].accounts.push(t),(s=e[r].chains)==null||s.push(`${r}:${o}`)}),e}function Hc(i,e){e=e.map(s=>s.replace("did:pkh:",""));const t=Ky(e);for(const[s,r]of Object.entries(t))r.methods?r.methods=rt(r.methods,i):r.methods=i,r.events=["chainChanged","accountsChanged"];return t}const Gy={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},Wy={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function $(i,e){const{message:t,code:s}=Wy[i];return{message:e?`${t} ${e}`:t,code:s}}function ae(i,e){const{message:t,code:s}=Gy[i];return{message:e?`${t} ${e}`:t,code:s}}function ct(i,e){return Array.isArray(i)?typeof e<"u"&&i.length?i.every(e):!0:!1}function Ai(i){return Object.getPrototypeOf(i)===Object.prototype&&Object.keys(i).length}function Ae(i){return typeof i>"u"}function ye(i,e){return e&&Ae(i)?!0:typeof i=="string"&&!!i.trim().length}function fr(i,e){return e&&Ae(i)?!0:typeof i=="number"&&!isNaN(i)}function Jy(i,e){const{requiredNamespaces:t}=e,s=Object.keys(i.namespaces),r=Object.keys(t);let o=!0;return Wt(r,s)?(s.forEach(a=>{const{accounts:c,methods:h,events:d}=i.namespaces[a],u=Si(c),p=t[a];(!Wt(Dn(a,p),u)||!Wt(p.methods,h)||!Wt(p.events,d))&&(o=!1)}),o):!1}function Gs(i){return ye(i,!1)&&i.includes(":")?i.split(":").length===2:!1}function Zy(i){if(ye(i,!1)&&i.includes(":")){const e=i.split(":");if(e.length===3){const t=e[0]+":"+e[1];return!!e[2]&&Gs(t)}}return!1}function Yy(i){function e(t){try{return typeof new URL(t)<"u"}catch{return!1}}try{if(ye(i,!1)){if(e(i))return!0;const t=Ca(i);return e(t)}}catch{}return!1}function Qy(i){var e;return(e=i==null?void 0:i.proposer)==null?void 0:e.publicKey}function Xy(i){return i==null?void 0:i.topic}function e_(i,e){let t=null;return ye(i==null?void 0:i.publicKey,!1)||(t=$("MISSING_OR_INVALID",`${e} controller public key should be a string`)),t}function Vc(i){let e=!0;return ct(i)?i.length&&(e=i.every(t=>ye(t,!1))):e=!1,e}function t_(i,e,t){let s=null;return ct(e)&&e.length?e.forEach(r=>{s||Gs(r)||(s=ae("UNSUPPORTED_CHAINS",`${t}, chain ${r} should be a string and conform to "namespace:chainId" format`))}):Gs(i)||(s=ae("UNSUPPORTED_CHAINS",`${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),s}function i_(i,e,t){let s=null;return Object.entries(i).forEach(([r,o])=>{if(s)return;const a=t_(r,Dn(r,o),`${e} ${t}`);a&&(s=a)}),s}function s_(i,e){let t=null;return ct(i)?i.forEach(s=>{t||Zy(s)||(t=ae("UNSUPPORTED_ACCOUNTS",`${e}, account ${s} should be a string and conform to "namespace:chainId:address" format`))}):t=ae("UNSUPPORTED_ACCOUNTS",`${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),t}function n_(i,e){let t=null;return Object.values(i).forEach(s=>{if(t)return;const r=s_(s==null?void 0:s.accounts,`${e} namespace`);r&&(t=r)}),t}function r_(i,e){let t=null;return Vc(i==null?void 0:i.methods)?Vc(i==null?void 0:i.events)||(t=ae("UNSUPPORTED_EVENTS",`${e}, events should be an array of strings or empty array for no events`)):t=ae("UNSUPPORTED_METHODS",`${e}, methods should be an array of strings or empty array for no methods`),t}function Kc(i,e){let t=null;return Object.values(i).forEach(s=>{if(t)return;const r=r_(s,`${e}, namespace`);r&&(t=r)}),t}function o_(i,e,t){let s=null;if(i&&Ai(i)){const r=Kc(i,e);r&&(s=r);const o=i_(i,e,t);o&&(s=o)}else s=$("MISSING_OR_INVALID",`${e}, ${t} should be an object with data`);return s}function Ws(i,e){let t=null;if(i&&Ai(i)){const s=Kc(i,e);s&&(t=s);const r=n_(i,e);r&&(t=r)}else t=$("MISSING_OR_INVALID",`${e}, namespaces should be an object with data`);return t}function Gc(i){return ye(i.protocol,!0)}function a_(i,e){let t=!1;return e&&!i?t=!0:i&&ct(i)&&i.length&&i.forEach(s=>{t=Gc(s)}),t}function c_(i){return typeof i=="number"}function Me(i){return typeof i<"u"&&typeof i!==null}function h_(i){return!(!i||typeof i!="object"||!i.code||!fr(i.code,!1)||!i.message||!ye(i.message,!1))}function d_(i){return!(Ae(i)||!ye(i.method,!1))}function l_(i){return!(Ae(i)||Ae(i.result)&&Ae(i.error)||!fr(i.id,!1)||!ye(i.jsonrpc,!1))}function u_(i){return!(Ae(i)||!ye(i.name,!1))}function Wc(i,e){return!(!Gs(e)||!zy(i).includes(e))}function p_(i,e,t){return ye(t,!1)?Hy(i,e).includes(t):!1}function g_(i,e,t){return ye(t,!1)?Vy(i,e).includes(t):!1}function yr(i,e,t){let s=null;const r=f_(i),o=y_(e),a=Object.keys(r),c=Object.keys(o),h=Jc(Object.keys(i)),d=Jc(Object.keys(e)),u=h.filter(p=>!d.includes(p));return u.length&&(s=$("NON_CONFORMING_NAMESPACES",`${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(e).toString()}`)),Wt(a,c)||(s=$("NON_CONFORMING_NAMESPACES",`${t} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${c.toString()}`)),Object.keys(e).forEach(p=>{if(!p.includes(":")||s)return;const g=Si(e[p].accounts);g.includes(p)||(s=$("NON_CONFORMING_NAMESPACES",`${t} namespaces accounts don't satisfy namespace accounts for ${p}
        Required: ${p}
        Approved: ${g.toString()}`))}),a.forEach(p=>{s||(Wt(r[p].methods,o[p].methods)?Wt(r[p].events,o[p].events)||(s=$("NON_CONFORMING_NAMESPACES",`${t} namespaces events don't satisfy namespace events for ${p}`)):s=$("NON_CONFORMING_NAMESPACES",`${t} namespaces methods don't satisfy namespace methods for ${p}`))}),s}function f_(i){const e={};return Object.keys(i).forEach(t=>{var s;t.includes(":")?e[t]=i[t]:(s=i[t].chains)==null||s.forEach(r=>{e[r]={methods:i[t].methods,events:i[t].events}})}),e}function Jc(i){return[...new Set(i.map(e=>e.includes(":")?e.split(":")[0]:e))]}function y_(i){const e={};return Object.keys(i).forEach(t=>{if(t.includes(":"))e[t]=i[t];else{const s=Si(i[t].accounts);s==null||s.forEach(r=>{e[r]={accounts:i[t].accounts.filter(o=>o.includes(`${r}:`)),methods:i[t].methods,events:i[t].events}})}}),e}function __(i,e){return fr(i,!1)&&i<=e.max&&i>=e.min}function Zc(){const i=ui();return new Promise(e=>{switch(i){case Le.browser:e(m_());break;case Le.reactNative:e(w_());break;case Le.node:e(b_());break;default:e(!0)}})}function m_(){return Qi()&&(navigator==null?void 0:navigator.onLine)}async function w_(){if(Dt()&&typeof q.g<"u"&&q.g!=null&&q.g.NetInfo){const i=await(q.g==null?void 0:q.g.NetInfo.fetch());return i==null?void 0:i.isConnected}return!0}function b_(){return!0}function v_(i){switch(ui()){case Le.browser:x_(i);break;case Le.reactNative:E_(i);break;case Le.node:break}}function x_(i){!Dt()&&Qi()&&(window.addEventListener("online",()=>i(!0)),window.addEventListener("offline",()=>i(!1)))}function E_(i){var e;Dt()&&typeof q.g<"u"&&q.g!=null&&q.g.NetInfo&&((e=q.g)==null||e.NetInfo.addEventListener(t=>i(t==null?void 0:t.isConnected)))}const _r={};class ls{static get(e){return _r[e]}static set(e,t){_r[e]=t}static delete(e){delete _r[e]}}var Ci=q(19994),I_=q(16966),ti=q(51143);function Mx(i){return i}const P_="idb-keyval";var S_=(i={})=>{const e=i.base&&i.base.length>0?`${i.base}:`:"",t=r=>e+r;let s;return i.dbName&&i.storeName&&(s=(0,ti.MT)(i.dbName,i.storeName)),{name:P_,options:i,async hasItem(r){return!(typeof await(0,ti.U2)(t(r),s)>"u")},async getItem(r){return await(0,ti.U2)(t(r),s)??null},setItem(r,o){return(0,ti.t8)(t(r),o,s)},removeItem(r){return(0,ti.IV)(t(r),s)},getKeys(){return(0,ti.XP)(s)},clear(){return(0,ti.ZH)(s)}}};const O_="WALLET_CONNECT_V2_INDEXED_DB",A_="keyvaluestorage";class C_{constructor(){this.indexedDb=(0,I_.o6)({driver:S_({dbName:O_,storeName:A_})})}async getKeys(){return this.indexedDb.getKeys()}async getEntries(){return(await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(e=>[e.key,e.value])}async getItem(e){const t=await this.indexedDb.getItem(e);if(t!==null)return t}async setItem(e,t){await this.indexedDb.setItem(e,(0,st.u)(t))}async removeItem(e){await this.indexedDb.removeItem(e)}}var mr=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof q.g<"u"?q.g:typeof self<"u"?self:{},Js={exports:{}};(function(){let i;function e(){}i=e,i.prototype.getItem=function(t){return this.hasOwnProperty(t)?String(this[t]):null},i.prototype.setItem=function(t,s){this[t]=String(s)},i.prototype.removeItem=function(t){delete this[t]},i.prototype.clear=function(){const t=this;Object.keys(t).forEach(function(s){t[s]=void 0,delete t[s]})},i.prototype.key=function(t){return t=t||0,Object.keys(this)[t]},i.prototype.__defineGetter__("length",function(){return Object.keys(this).length}),typeof mr<"u"&&mr.localStorage?Js.exports=mr.localStorage:typeof window<"u"&&window.localStorage?Js.exports=window.localStorage:Js.exports=new e})();function R_(i){var e;return[i[0],(0,st.D)((e=i[1])!=null?e:"")]}class F_{constructor(){this.localStorage=Js.exports}async getKeys(){return Object.keys(this.localStorage)}async getEntries(){return Object.entries(this.localStorage).map(R_)}async getItem(e){const t=this.localStorage.getItem(e);if(t!==null)return(0,st.D)(t)}async setItem(e,t){this.localStorage.setItem(e,(0,st.u)(t))}async removeItem(e){this.localStorage.removeItem(e)}}const N_="wc_storage_version",Yc=1,T_=async(i,e,t)=>{const s=N_,r=await e.getItem(s);if(r&&r>=Yc){t(e);return}const o=await i.getKeys();if(!o.length){t(e);return}const a=[];for(;o.length;){const c=o.shift();if(!c)continue;const h=c.toLowerCase();if(h.includes("wc@")||h.includes("walletconnect")||h.includes("wc_")||h.includes("wallet_connect")){const d=await i.getItem(c);await e.setItem(c,d),a.push(c)}}await e.setItem(s,Yc),t(e),B_(i,a)},B_=async(i,e)=>{e.length&&e.forEach(async t=>{await i.removeItem(t)})};class D_{constructor(){this.initialized=!1,this.setInitialized=t=>{this.storage=t,this.initialized=!0};const e=new F_;this.storage=e;try{const t=new C_;T_(e,t,this.setInitialized)}catch{this.initialized=!0}}async getKeys(){return await this.initialize(),this.storage.getKeys()}async getEntries(){return await this.initialize(),this.storage.getEntries()}async getItem(e){return await this.initialize(),this.storage.getItem(e)}async setItem(e,t){return await this.initialize(),this.storage.setItem(e,t)}async removeItem(e){return await this.initialize(),this.storage.removeItem(e)}async initialize(){this.initialized||await new Promise(e=>{const t=setInterval(()=>{this.initialized&&(clearInterval(t),e())},20)})}}var Z=q(56526),Ri=q(36900),$_=Object.defineProperty,j_=(i,e,t)=>e in i?$_(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Qc=(i,e,t)=>j_(i,typeof e!="symbol"?e+"":e,t);class q_ extends Ri.q{constructor(e){super(),this.opts=e,Qc(this,"protocol","wc"),Qc(this,"version",2)}}class zx{constructor(e,t,s){this.core=e,this.logger=t}}var U_=Object.defineProperty,L_=(i,e,t)=>e in i?U_(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,k_=(i,e,t)=>L_(i,typeof e!="symbol"?e+"":e,t);class M_ extends Ri.q{constructor(e,t){super(),this.core=e,this.logger=t,k_(this,"records",new Map)}}class z_{constructor(e,t){this.logger=e,this.core=t}}class H_ extends Ri.q{constructor(e,t){super(),this.relayer=e,this.logger=t}}class V_ extends Ri.q{constructor(e){super()}}class K_{constructor(e,t,s,r){this.core=e,this.logger=t,this.name=s}}var G_=Object.defineProperty,W_=(i,e,t)=>e in i?G_(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,J_=(i,e,t)=>W_(i,typeof e!="symbol"?e+"":e,t);class Hx{constructor(){J_(this,"map",new Map)}}class Z_ extends Ri.q{constructor(e,t){super(),this.relayer=e,this.logger=t}}class Vx{constructor(e,t){this.core=e,this.logger=t}}class Y_ extends Ri.q{constructor(e,t){super(),this.core=e,this.logger=t}}class Kx{constructor(e,t){this.logger=e,this.core=t}}class Q_{constructor(e,t,s){this.core=e,this.logger=t,this.store=s}}class X_{constructor(e,t){this.projectId=e,this.logger=t}}class em{constructor(e,t,s){this.core=e,this.logger=t,this.telemetryEnabled=s}}var tm=Object.defineProperty,im=(i,e,t)=>e in i?tm(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Xc=(i,e,t)=>im(i,typeof e!="symbol"?e+"":e,t);class Gx extends null{constructor(){super()}}class sm{constructor(e){this.opts=e,Xc(this,"protocol","wc"),Xc(this,"version",2)}}class Wx extends null{constructor(){super()}}class nm{constructor(e){this.client=e}}var Ze=q(56390),z=q(23700);const rm=()=>typeof WebSocket<"u"?WebSocket:typeof q.g<"u"&&typeof q.g.WebSocket<"u"?q.g.WebSocket:typeof window<"u"&&typeof window.WebSocket<"u"?window.WebSocket:typeof self<"u"&&typeof self.WebSocket<"u"?self.WebSocket:q(75e3),om=()=>typeof WebSocket<"u"||typeof q.g<"u"&&typeof q.g.WebSocket<"u"||typeof window<"u"&&typeof window.WebSocket<"u"||typeof self<"u"&&typeof self.WebSocket<"u",eh=i=>i.split("?")[0],th=10,am=rm();class cm{constructor(e){if(this.url=e,this.events=new pt.EventEmitter,this.registering=!1,!(0,z.isWsUrl)(e))throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);this.url=e}get connected(){return typeof this.socket<"u"}get connecting(){return this.registering}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async open(e=this.url){await this.register(e)}async close(){return new Promise((e,t)=>{if(typeof this.socket>"u"){t(new Error("Connection already closed"));return}this.socket.onclose=s=>{this.onClose(s),e()},this.socket.close()})}async send(e){typeof this.socket>"u"&&(this.socket=await this.register());try{this.socket.send((0,st.u)(e))}catch(t){this.onError(e.id,t)}}register(e=this.url){if(!(0,z.isWsUrl)(e))throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);if(this.registering){const t=this.events.getMaxListeners();return(this.events.listenerCount("register_error")>=t||this.events.listenerCount("open")>=t)&&this.events.setMaxListeners(t+1),new Promise((s,r)=>{this.events.once("register_error",o=>{this.resetMaxListeners(),r(o)}),this.events.once("open",()=>{if(this.resetMaxListeners(),typeof this.socket>"u")return r(new Error("WebSocket connection is missing or invalid"));s(this.socket)})})}return this.url=e,this.registering=!0,new Promise((t,s)=>{const r=(0,z.isReactNative)()?void 0:{rejectUnauthorized:!(0,z.isLocalhostUrl)(e)},o=new am(e,[],r);om()?o.onerror=a=>{const c=a;s(this.emitError(c.error))}:o.on("error",a=>{s(this.emitError(a))}),o.onopen=()=>{this.onOpen(o),t(o)}})}onOpen(e){e.onmessage=t=>this.onPayload(t),e.onclose=t=>this.onClose(t),this.socket=e,this.registering=!1,this.events.emit("open")}onClose(e){this.socket=void 0,this.registering=!1,this.events.emit("close",e)}onPayload(e){if(typeof e.data>"u")return;const t=typeof e.data=="string"?(0,st.D)(e.data):e.data;this.events.emit("payload",t)}onError(e,t){const s=this.parseError(t),r=s.message||s.toString(),o=(0,z.formatJsonRpcError)(e,r);this.events.emit("payload",o)}parseError(e,t=this.url){return(0,z.parseConnectionError)(e,eh(t),"WS")}resetMaxListeners(){this.events.getMaxListeners()>th&&this.events.setMaxListeners(th)}emitError(e){const t=this.parseError(new Error((e==null?void 0:e.message)||`WebSocket connection failed for host: ${eh(this.url)}`));return this.events.emit("register_error",t),t}}var wr=q(55872).Buffer,hm=q(14224);const ih="wc",sh=2,Zs="core",_t=`${ih}@2:${Zs}:`,dm={name:Zs,logger:"error"},lm={database:":memory:"},um="crypto",nh="client_ed25519_seed",pm=D.ONE_DAY,gm="keychain",fm="0.3",ym="messages",_m="0.3",rh=D.SIX_HOURS,mm="publisher",oh="irn",wm="error",ah="wss://relay.walletconnect.org",bm="relayer",Ee={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},vm="_subscription",Ye={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},xm=.1,Jx={database:":memory:"},br="2.19.2",Zx=1e4,pe={link_mode:"link_mode",relay:"relay"},Ys={inbound:"inbound",outbound:"outbound"},Em="0.3",Im="WALLETCONNECT_CLIENT_ID",ch="WALLETCONNECT_LINK_MODE_APPS",Ke={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},Yx=null,Pm="subscription",Sm="0.3",Qx=D.FIVE_SECONDS*1e3,Om="pairing",Am="0.3",Xx=null,us={wc_pairingDelete:{req:{ttl:D.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:D.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:D.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:D.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:D.ONE_DAY,prompt:!1,tag:0},res:{ttl:D.ONE_DAY,prompt:!1,tag:0}}},ii={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},ht={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Cm="history",Rm="0.3",Fm="expirer",Qe={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},Nm="0.3",eE=null,Tm="verify-api",Bm="https://verify.walletconnect.com",hh="https://verify.walletconnect.org",ps=hh,Dm=`${ps}/v3`,$m=[Bm,hh],jm="echo",qm="https://echo.walletconnect.com",tE="event-client",mt={pairing_started:"pairing_started",pairing_uri_validation_success:"pairing_uri_validation_success",pairing_uri_not_expired:"pairing_uri_not_expired",store_new_pairing:"store_new_pairing",subscribing_pairing_topic:"subscribing_pairing_topic",subscribe_pairing_topic_success:"subscribe_pairing_topic_success",existing_pairing:"existing_pairing",pairing_not_expired:"pairing_not_expired",emit_inactive_pairing:"emit_inactive_pairing",emit_session_proposal:"emit_session_proposal",subscribing_to_pairing_topic:"subscribing_to_pairing_topic"},Ft={no_wss_connection:"no_wss_connection",no_internet_connection:"no_internet_connection",malformed_pairing_uri:"malformed_pairing_uri",active_pairing_already_exists:"active_pairing_already_exists",subscribe_pairing_topic_failure:"subscribe_pairing_topic_failure",pairing_expired:"pairing_expired",proposal_expired:"proposal_expired",proposal_listener_not_found:"proposal_listener_not_found"},dt={session_approve_started:"session_approve_started",proposal_not_expired:"proposal_not_expired",session_namespaces_validation_success:"session_namespaces_validation_success",create_session_topic:"create_session_topic",subscribing_session_topic:"subscribing_session_topic",subscribe_session_topic_success:"subscribe_session_topic_success",publishing_session_approve:"publishing_session_approve",session_approve_publish_success:"session_approve_publish_success",store_session:"store_session",publishing_session_settle:"publishing_session_settle",session_settle_publish_success:"session_settle_publish_success"},si={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",proposal_expired:"proposal_expired",subscribe_session_topic_failure:"subscribe_session_topic_failure",session_approve_publish_failure:"session_approve_publish_failure",session_settle_publish_failure:"session_settle_publish_failure",session_approve_namespace_validation_failure:"session_approve_namespace_validation_failure",proposal_not_found:"proposal_not_found"},ni={authenticated_session_approve_started:"authenticated_session_approve_started",authenticated_session_not_expired:"authenticated_session_not_expired",chains_caip2_compliant:"chains_caip2_compliant",chains_evm_compliant:"chains_evm_compliant",create_authenticated_session_topic:"create_authenticated_session_topic",cacaos_verified:"cacaos_verified",store_authenticated_session:"store_authenticated_session",subscribing_authenticated_session_topic:"subscribing_authenticated_session_topic",subscribe_authenticated_session_topic_success:"subscribe_authenticated_session_topic_success",publishing_authenticated_session_approve:"publishing_authenticated_session_approve",authenticated_session_approve_publish_success:"authenticated_session_approve_publish_success"},gs={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",missing_session_authenticate_request:"missing_session_authenticate_request",session_authenticate_request_expired:"session_authenticate_request_expired",chains_caip2_compliant_failure:"chains_caip2_compliant_failure",chains_evm_compliant_failure:"chains_evm_compliant_failure",invalid_cacao:"invalid_cacao",subscribe_authenticated_session_topic_failure:"subscribe_authenticated_session_topic_failure",authenticated_session_approve_publish_failure:"authenticated_session_approve_publish_failure",authenticated_session_pending_request_not_found:"authenticated_session_pending_request_not_found"},Um=.1,Lm="event-client",km=86400,Mm="https://pulse.walletconnect.org/batch";function zm(i,e){if(i.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),s=0;s<t.length;s++)t[s]=255;for(var r=0;r<i.length;r++){var o=i.charAt(r),a=o.charCodeAt(0);if(t[a]!==255)throw new TypeError(o+" is ambiguous");t[a]=r}var c=i.length,h=i.charAt(0),d=Math.log(c)/Math.log(256),u=Math.log(256)/Math.log(c);function p(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var y=0,m=0,v=0,w=f.length;v!==w&&f[v]===0;)v++,y++;for(var x=(w-v)*u+1>>>0,P=new Uint8Array(x);v!==w;){for(var R=f[v],A=0,C=x-1;(R!==0||A<m)&&C!==-1;C--,A++)R+=256*P[C]>>>0,P[C]=R%c>>>0,R=R/c>>>0;if(R!==0)throw new Error("Non-zero carry");m=A,v++}for(var B=x-m;B!==x&&P[B]===0;)B++;for(var S=h.repeat(y);B<x;++B)S+=i.charAt(P[B]);return S}function g(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;var y=0;if(f[y]!==" "){for(var m=0,v=0;f[y]===h;)m++,y++;for(var w=(f.length-y)*d+1>>>0,x=new Uint8Array(w);f[y];){var P=t[f.charCodeAt(y)];if(P===255)return;for(var R=0,A=w-1;(P!==0||R<v)&&A!==-1;A--,R++)P+=c*x[A]>>>0,x[A]=P%256>>>0,P=P/256>>>0;if(P!==0)throw new Error("Non-zero carry");v=R,y++}if(f[y]!==" "){for(var C=w-v;C!==w&&x[C]===0;)C++;for(var B=new Uint8Array(m+(w-C)),S=m;C!==w;)B[S++]=x[C++];return B}}}function _(f){var y=g(f);if(y)return y;throw new Error(`Non-${e} character`)}return{encode:p,decodeUnsafe:g,decode:_}}var Hm=zm,Vm=Hm;const dh=i=>{if(i instanceof Uint8Array&&i.constructor.name==="Uint8Array")return i;if(i instanceof ArrayBuffer)return new Uint8Array(i);if(ArrayBuffer.isView(i))return new Uint8Array(i.buffer,i.byteOffset,i.byteLength);throw new Error("Unknown type, must be binary type")},Km=i=>new TextEncoder().encode(i),Gm=i=>new TextDecoder().decode(i);class Wm{constructor(e,t,s){this.name=e,this.prefix=t,this.baseEncode=s}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Jm{constructor(e,t,s){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=s}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return lh(this,e)}}class Zm{constructor(e){this.decoders=e}or(e){return lh(this,e)}decode(e){const t=e[0],s=this.decoders[t];if(s)return s.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const lh=(i,e)=>new Zm({...i.decoders||{[i.prefix]:i},...e.decoders||{[e.prefix]:e}});class Ym{constructor(e,t,s,r){this.name=e,this.prefix=t,this.baseEncode=s,this.baseDecode=r,this.encoder=new Wm(e,t,s),this.decoder=new Jm(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const Qs=({name:i,prefix:e,encode:t,decode:s})=>new Ym(i,e,t,s),fs=({prefix:i,name:e,alphabet:t})=>{const{encode:s,decode:r}=Vm(t,e);return Qs({prefix:i,name:e,encode:s,decode:o=>dh(r(o))})},Qm=(i,e,t,s)=>{const r={};for(let u=0;u<e.length;++u)r[e[u]]=u;let o=i.length;for(;i[o-1]==="=";)--o;const a=new Uint8Array(o*t/8|0);let c=0,h=0,d=0;for(let u=0;u<o;++u){const p=r[i[u]];if(p===void 0)throw new SyntaxError(`Non-${s} character`);h=h<<t|p,c+=t,c>=8&&(c-=8,a[d++]=255&h>>c)}if(c>=t||255&h<<8-c)throw new SyntaxError("Unexpected end of data");return a},Xm=(i,e,t)=>{const s=e[e.length-1]==="=",r=(1<<t)-1;let o="",a=0,c=0;for(let h=0;h<i.length;++h)for(c=c<<8|i[h],a+=8;a>t;)a-=t,o+=e[r&c>>a];if(a&&(o+=e[r&c<<t-a]),s)for(;o.length*t&7;)o+="=";return o},Re=({name:i,prefix:e,bitsPerChar:t,alphabet:s})=>Qs({prefix:e,name:i,encode(r){return Xm(r,s,t)},decode(r){return Qm(r,s,t,i)}}),ew=Qs({prefix:"\0",name:"identity",encode:i=>Gm(i),decode:i=>Km(i)});var tw=Object.freeze({__proto__:null,identity:ew});const iw=Re({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var sw=Object.freeze({__proto__:null,base2:iw});const nw=Re({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var rw=Object.freeze({__proto__:null,base8:nw});const ow=fs({prefix:"9",name:"base10",alphabet:"0123456789"});var aw=Object.freeze({__proto__:null,base10:ow});const cw=Re({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),hw=Re({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var dw=Object.freeze({__proto__:null,base16:cw,base16upper:hw});const lw=Re({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),uw=Re({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),pw=Re({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),gw=Re({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),fw=Re({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),yw=Re({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),_w=Re({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),mw=Re({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ww=Re({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var bw=Object.freeze({__proto__:null,base32:lw,base32upper:uw,base32pad:pw,base32padupper:gw,base32hex:fw,base32hexupper:yw,base32hexpad:_w,base32hexpadupper:mw,base32z:ww});const vw=fs({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),xw=fs({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Ew=Object.freeze({__proto__:null,base36:vw,base36upper:xw});const Iw=fs({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Pw=fs({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Sw=Object.freeze({__proto__:null,base58btc:Iw,base58flickr:Pw});const Ow=Re({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Aw=Re({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Cw=Re({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Rw=Re({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Fw=Object.freeze({__proto__:null,base64:Ow,base64pad:Aw,base64url:Cw,base64urlpad:Rw});const uh=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),Nw=uh.reduce((i,e,t)=>(i[t]=e,i),[]),Tw=uh.reduce((i,e,t)=>(i[e.codePointAt(0)]=t,i),[]);function Bw(i){return i.reduce((e,t)=>(e+=Nw[t],e),"")}function Dw(i){const e=[];for(const t of i){const s=Tw[t.codePointAt(0)];if(s===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const $w=Qs({prefix:"\u{1F680}",name:"base256emoji",encode:Bw,decode:Dw});var jw=Object.freeze({__proto__:null,base256emoji:$w}),qw=gh,ph=128,Uw=127,Lw=~Uw,kw=Math.pow(2,31);function gh(i,e,t){e=e||[],t=t||0;for(var s=t;i>=kw;)e[t++]=i&255|ph,i/=128;for(;i&Lw;)e[t++]=i&255|ph,i>>>=7;return e[t]=i|0,gh.bytes=t-s+1,e}var Mw=vr,zw=128,fh=127;function vr(i,s){var t=0,s=s||0,r=0,o=s,a,c=i.length;do{if(o>=c)throw vr.bytes=0,new RangeError("Could not decode varint");a=i[o++],t+=r<28?(a&fh)<<r:(a&fh)*Math.pow(2,r),r+=7}while(a>=zw);return vr.bytes=o-s,t}var Hw=Math.pow(2,7),Vw=Math.pow(2,14),Kw=Math.pow(2,21),Gw=Math.pow(2,28),Ww=Math.pow(2,35),Jw=Math.pow(2,42),Zw=Math.pow(2,49),Yw=Math.pow(2,56),Qw=Math.pow(2,63),Xw=function(i){return i<Hw?1:i<Vw?2:i<Kw?3:i<Gw?4:i<Ww?5:i<Jw?6:i<Zw?7:i<Yw?8:i<Qw?9:10},eb={encode:qw,decode:Mw,encodingLength:Xw},yh=eb;const _h=(i,e,t=0)=>(yh.encode(i,e,t),e),mh=i=>yh.encodingLength(i),xr=(i,e)=>{const t=e.byteLength,s=mh(i),r=s+mh(t),o=new Uint8Array(r+t);return _h(i,o,0),_h(t,o,s),o.set(e,r),new tb(i,t,e,o)};class tb{constructor(e,t,s,r){this.code=e,this.size=t,this.digest=s,this.bytes=r}}const wh=({name:i,code:e,encode:t})=>new ib(i,e,t);class ib{constructor(e,t,s){this.name=e,this.code=t,this.encode=s}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?xr(this.code,t):t.then(s=>xr(this.code,s))}else throw Error("Unknown type, must be binary type")}}const bh=i=>async e=>new Uint8Array(await crypto.subtle.digest(i,e)),sb=wh({name:"sha2-256",code:18,encode:bh("SHA-256")}),nb=wh({name:"sha2-512",code:19,encode:bh("SHA-512")});var rb=Object.freeze({__proto__:null,sha256:sb,sha512:nb});const vh=0,ob="identity",xh=dh;var ab=Object.freeze({__proto__:null,identity:{code:vh,name:ob,encode:xh,digest:i=>xr(vh,xh(i))}});new TextEncoder,new TextDecoder;const Eh={...tw,...sw,...rw,...aw,...dw,...bw,...Ew,...Sw,...Fw,...jw};({...rb,...ab});function cb(i=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(i):new Uint8Array(i)}function Ih(i,e,t,s){return{name:i,prefix:e,encoder:{name:i,prefix:e,encode:t},decoder:{decode:s}}}const Ph=Ih("utf8","u",i=>"u"+new TextDecoder("utf8").decode(i),i=>new TextEncoder().encode(i.substring(1))),Er=Ih("ascii","a",i=>{let e="a";for(let t=0;t<i.length;t++)e+=String.fromCharCode(i[t]);return e},i=>{i=i.substring(1);const e=cb(i.length);for(let t=0;t<i.length;t++)e[t]=i.charCodeAt(t);return e}),hb={utf8:Ph,"utf-8":Ph,hex:Eh.base16,latin1:Er,ascii:Er,binary:Er,...Eh};function db(i,e="utf8"){const t=hb[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(i,"utf8"):t.decoder.decode(`${t.prefix}${i}`)}var lb=Object.defineProperty,ub=(i,e,t)=>e in i?lb(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,wt=(i,e,t)=>ub(i,typeof e!="symbol"?e+"":e,t);class pb{constructor(e,t){this.core=e,this.logger=t,wt(this,"keychain",new Map),wt(this,"name",gm),wt(this,"version",fm),wt(this,"initialized",!1),wt(this,"storagePrefix",_t),wt(this,"init",async()=>{if(!this.initialized){const s=await this.getKeyChain();typeof s<"u"&&(this.keychain=s),this.initialized=!0}}),wt(this,"has",s=>(this.isInitialized(),this.keychain.has(s))),wt(this,"set",async(s,r)=>{this.isInitialized(),this.keychain.set(s,r),await this.persist()}),wt(this,"get",s=>{this.isInitialized();const r=this.keychain.get(s);if(typeof r>"u"){const{message:o}=$("NO_MATCHING_KEY",`${this.name}: ${s}`);throw new Error(o)}return r}),wt(this,"del",async s=>{this.isInitialized(),this.keychain.delete(s),await this.persist()}),this.core=e,this.logger=(0,Z.Ep)(t,this.name)}get context(){return(0,Z.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,jn(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?qn(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}}var gb=Object.defineProperty,fb=(i,e,t)=>e in i?gb(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Fe=(i,e,t)=>fb(i,typeof e!="symbol"?e+"":e,t);class yb{constructor(e,t,s){this.core=e,this.logger=t,Fe(this,"name",um),Fe(this,"keychain"),Fe(this,"randomSessionIdentifier",gr()),Fe(this,"initialized",!1),Fe(this,"init",async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)}),Fe(this,"hasKeys",r=>(this.isInitialized(),this.keychain.has(r))),Fe(this,"getClientId",async()=>{this.isInitialized();const r=await this.getClientSeed(),o=pa(r);return ua(o.publicKey)}),Fe(this,"generateKeyPair",()=>{this.isInitialized();const r=Ey();return this.setPrivateKey(r.publicKey,r.privateKey)}),Fe(this,"signJWT",async r=>{this.isInitialized();const o=await this.getClientSeed(),a=pa(o),c=this.randomSessionIdentifier;return await Rp(c,r,pm,a)}),Fe(this,"generateSharedKey",(r,o,a)=>{this.isInitialized();const c=this.getPrivateKey(r),h=Iy(c,o);return this.setSymKey(h,a)}),Fe(this,"setSymKey",async(r,o)=>{this.isInitialized();const a=o||zs(r);return await this.keychain.set(a,r),a}),Fe(this,"deleteKeyPair",async r=>{this.isInitialized(),await this.keychain.del(r)}),Fe(this,"deleteSymKey",async r=>{this.isInitialized(),await this.keychain.del(r)}),Fe(this,"encode",async(r,o,a)=>{this.isInitialized();const c=$c(a),h=(0,st.u)(o);if(qc(c))return Oy(h,a==null?void 0:a.encoding);if(jc(c)){const g=c.senderPublicKey,_=c.receiverPublicKey;r=await this.generateSharedKey(g,_)}const d=this.getSymKey(r),{type:u,senderPublicKey:p}=c;return Py({type:u,symKey:d,message:h,senderPublicKey:p,encoding:a==null?void 0:a.encoding})}),Fe(this,"decode",async(r,o,a)=>{this.isInitialized();const c=Cy(o,a);if(qc(c)){const h=Ay(o,a==null?void 0:a.encoding);return(0,st.D)(h)}if(jc(c)){const h=c.receiverPublicKey,d=c.senderPublicKey;r=await this.generateSharedKey(h,d)}try{const h=this.getSymKey(r),d=Sy({symKey:h,encoded:o,encoding:a==null?void 0:a.encoding});return(0,st.D)(d)}catch(h){this.logger.error(`Failed to decode message from topic: '${r}', clientId: '${await this.getClientId()}'`),this.logger.error(h)}}),Fe(this,"getPayloadType",(r,o=at)=>{const a=hs({encoded:r,encoding:o});return ei(a.type)}),Fe(this,"getPayloadSenderPublicKey",(r,o=at)=>{const a=hs({encoded:r,encoding:o});return a.senderPublicKey?(0,re.BB)(a.senderPublicKey,$e):void 0}),this.core=e,this.logger=(0,Z.Ep)(t,this.name),this.keychain=s||new pb(this.core,this.logger)}get context(){return(0,Z.Fd)(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(nh)}catch{e=gr(),await this.keychain.set(nh,e)}return db(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}}var _b=Object.defineProperty,mb=Object.defineProperties,wb=Object.getOwnPropertyDescriptors,Sh=Object.getOwnPropertySymbols,bb=Object.prototype.hasOwnProperty,vb=Object.prototype.propertyIsEnumerable,Ir=(i,e,t)=>e in i?_b(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,xb=(i,e)=>{for(var t in e||(e={}))bb.call(e,t)&&Ir(i,t,e[t]);if(Sh)for(var t of Sh(e))vb.call(e,t)&&Ir(i,t,e[t]);return i},Eb=(i,e)=>mb(i,wb(e)),Ge=(i,e,t)=>Ir(i,typeof e!="symbol"?e+"":e,t);class Ib extends z_{constructor(e,t){super(e,t),this.logger=e,this.core=t,Ge(this,"messages",new Map),Ge(this,"messagesWithoutClientAck",new Map),Ge(this,"name",ym),Ge(this,"version",_m),Ge(this,"initialized",!1),Ge(this,"storagePrefix",_t),Ge(this,"init",async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const s=await this.getRelayerMessages();typeof s<"u"&&(this.messages=s);const r=await this.getRelayerMessagesWithoutClientAck();typeof r<"u"&&(this.messagesWithoutClientAck=r),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(s){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(s)}finally{this.initialized=!0}}}),Ge(this,"set",async(s,r,o)=>{this.isInitialized();const a=yt(r);let c=this.messages.get(s);if(typeof c>"u"&&(c={}),typeof c[a]<"u")return a;if(c[a]=r,this.messages.set(s,c),o===Ys.inbound){const h=this.messagesWithoutClientAck.get(s)||{};this.messagesWithoutClientAck.set(s,Eb(xb({},h),{[a]:r}))}return await this.persist(),a}),Ge(this,"get",s=>{this.isInitialized();let r=this.messages.get(s);return typeof r>"u"&&(r={}),r}),Ge(this,"getWithoutAck",s=>{this.isInitialized();const r={};for(const o of s){const a=this.messagesWithoutClientAck.get(o)||{};r[o]=Object.values(a)}return r}),Ge(this,"has",(s,r)=>{this.isInitialized();const o=this.get(s),a=yt(r);return typeof o[a]<"u"}),Ge(this,"ack",async(s,r)=>{this.isInitialized();const o=this.messagesWithoutClientAck.get(s);if(typeof o>"u")return;const a=yt(r);delete o[a],Object.keys(o).length===0?this.messagesWithoutClientAck.delete(s):this.messagesWithoutClientAck.set(s,o),await this.persist()}),Ge(this,"del",async s=>{this.isInitialized(),this.messages.delete(s),this.messagesWithoutClientAck.delete(s),await this.persist()}),this.logger=(0,Z.Ep)(e,this.name),this.core=t}get context(){return(0,Z.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get storageKeyWithoutClientAck(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name+"_withoutClientAck"}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,jn(e))}async setRelayerMessagesWithoutClientAck(e){await this.core.storage.setItem(this.storageKeyWithoutClientAck,jn(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?qn(e):void 0}async getRelayerMessagesWithoutClientAck(){const e=await this.core.storage.getItem(this.storageKeyWithoutClientAck);return typeof e<"u"?qn(e):void 0}async persist(){await this.setRelayerMessages(this.messages),await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}}var Pb=Object.defineProperty,Sb=Object.defineProperties,Ob=Object.getOwnPropertyDescriptors,Oh=Object.getOwnPropertySymbols,Ab=Object.prototype.hasOwnProperty,Cb=Object.prototype.propertyIsEnumerable,Pr=(i,e,t)=>e in i?Pb(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Xs=(i,e)=>{for(var t in e||(e={}))Ab.call(e,t)&&Pr(i,t,e[t]);if(Oh)for(var t of Oh(e))Cb.call(e,t)&&Pr(i,t,e[t]);return i},Sr=(i,e)=>Sb(i,Ob(e)),lt=(i,e,t)=>Pr(i,typeof e!="symbol"?e+"":e,t);class Rb extends H_{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,lt(this,"events",new pt.EventEmitter),lt(this,"name",mm),lt(this,"queue",new Map),lt(this,"publishTimeout",(0,D.toMiliseconds)(D.ONE_MINUTE)),lt(this,"initialPublishTimeout",(0,D.toMiliseconds)(D.ONE_SECOND*15)),lt(this,"needsTransportRestart",!1),lt(this,"publish",async(s,r,o)=>{var a;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:s,message:r,opts:o}});const c=(o==null?void 0:o.ttl)||rh,h=Hs(o),d=(o==null?void 0:o.prompt)||!1,u=(o==null?void 0:o.tag)||0,p=(o==null?void 0:o.id)||(0,z.getBigIntRpcId)().toString(),g={topic:s,message:r,opts:{ttl:c,relay:h,prompt:d,tag:u,id:p,attestation:o==null?void 0:o.attestation,tvf:o==null?void 0:o.tvf}},_=`Failed to publish payload, please try again. id:${p} tag:${u}`;try{const f=new Promise(async y=>{const m=({id:w})=>{g.opts.id===w&&(this.removeRequestFromQueue(w),this.relayer.events.removeListener(Ee.publish,m),y(g))};this.relayer.events.on(Ee.publish,m);const v=$t(new Promise((w,x)=>{this.rpcPublish({topic:s,message:r,ttl:c,prompt:d,tag:u,id:p,attestation:o==null?void 0:o.attestation,tvf:o==null?void 0:o.tvf}).then(w).catch(P=>{this.logger.warn(P,P==null?void 0:P.message),x(P)})}),this.initialPublishTimeout,`Failed initial publish, retrying.... id:${p} tag:${u}`);try{await v,this.events.removeListener(Ee.publish,m)}catch(w){this.queue.set(p,Sr(Xs({},g),{attempt:1})),this.logger.warn(w,w==null?void 0:w.message)}});this.logger.trace({type:"method",method:"publish",params:{id:p,topic:s,message:r,opts:o}}),await $t(f,this.publishTimeout,_)}catch(f){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(f),(a=o==null?void 0:o.internal)!=null&&a.throwOnFailedPublish)throw f}finally{this.queue.delete(p)}}),lt(this,"on",(s,r)=>{this.events.on(s,r)}),lt(this,"once",(s,r)=>{this.events.once(s,r)}),lt(this,"off",(s,r)=>{this.events.off(s,r)}),lt(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),this.relayer=e,this.logger=(0,Z.Ep)(t,this.name),this.registerEventListeners()}get context(){return(0,Z.Fd)(this.logger)}async rpcPublish(e){var t,s,r,o;const{topic:a,message:c,ttl:h=rh,prompt:d,tag:u,id:p,attestation:g,tvf:_}=e,f={method:ds(Hs().protocol).publish,params:Xs({topic:a,message:c,ttl:h,prompt:d,tag:u,attestation:g},_),id:p};Ae((t=f.params)==null?void 0:t.prompt)&&((s=f.params)==null||delete s.prompt),Ae((r=f.params)==null?void 0:r.tag)&&((o=f.params)==null||delete o.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:f});const y=await this.relayer.request(f);return this.relayer.events.emit(Ee.publish,e),this.logger.debug("Successfully Published Payload"),y}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async(e,t)=>{const s=e.attempt+1;this.queue.set(t,Sr(Xs({},e),{attempt:s}));const{topic:r,message:o,opts:a,attestation:c}=e;this.logger.warn({},`Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s}`),await this.rpcPublish(Sr(Xs({},e),{topic:r,message:o,ttl:a.ttl,prompt:a.prompt,tag:a.tag,id:a.id,attestation:c,tvf:a.tvf})),this.logger.warn({},`Publisher: queue->published: ${e.opts.id}`)})}registerEventListeners(){this.relayer.core.heartbeat.on(Ci.Lx.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(Ee.connection_stalled);return}this.checkQueue()}),this.relayer.on(Ee.message_ack,e=>{this.removeRequestFromQueue(e.id.toString())})}}var Fb=Object.defineProperty,Nb=(i,e,t)=>e in i?Fb(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Fi=(i,e,t)=>Nb(i,typeof e!="symbol"?e+"":e,t);class Tb{constructor(){Fi(this,"map",new Map),Fi(this,"set",(e,t)=>{const s=this.get(e);this.exists(e,t)||this.map.set(e,[...s,t])}),Fi(this,"get",e=>this.map.get(e)||[]),Fi(this,"exists",(e,t)=>this.get(e).includes(t)),Fi(this,"delete",(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const s=this.get(e);if(!this.exists(e,t))return;const r=s.filter(o=>o!==t);if(!r.length){this.map.delete(e);return}this.map.set(e,r)}),Fi(this,"clear",()=>{this.map.clear()})}get topics(){return Array.from(this.map.keys())}}var Bb=Object.defineProperty,Db=Object.defineProperties,$b=Object.getOwnPropertyDescriptors,Ah=Object.getOwnPropertySymbols,jb=Object.prototype.hasOwnProperty,qb=Object.prototype.propertyIsEnumerable,Or=(i,e,t)=>e in i?Bb(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ys=(i,e)=>{for(var t in e||(e={}))jb.call(e,t)&&Or(i,t,e[t]);if(Ah)for(var t of Ah(e))qb.call(e,t)&&Or(i,t,e[t]);return i},Ar=(i,e)=>Db(i,$b(e)),he=(i,e,t)=>Or(i,typeof e!="symbol"?e+"":e,t);class Ub extends Z_{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,he(this,"subscriptions",new Map),he(this,"topicMap",new Tb),he(this,"events",new pt.EventEmitter),he(this,"name",Pm),he(this,"version",Sm),he(this,"pending",new Map),he(this,"cached",[]),he(this,"initialized",!1),he(this,"storagePrefix",_t),he(this,"subscribeTimeout",(0,D.toMiliseconds)(D.ONE_MINUTE)),he(this,"initialSubscribeTimeout",(0,D.toMiliseconds)(D.ONE_SECOND*15)),he(this,"clientId"),he(this,"batchSubscribeTopicsLimit",500),he(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),await this.restore()),this.initialized=!0}),he(this,"subscribe",async(s,r)=>{this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:r}});try{const o=Hs(r),a={topic:s,relay:o,transportType:r==null?void 0:r.transportType};this.pending.set(s,a);const c=await this.rpcSubscribe(s,o,r);return typeof c=="string"&&(this.onSubscribe(c,a),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:r}})),c}catch(o){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(o),o}}),he(this,"unsubscribe",async(s,r)=>{this.isInitialized(),typeof(r==null?void 0:r.id)<"u"?await this.unsubscribeById(s,r.id,r):await this.unsubscribeByTopic(s,r)}),he(this,"isSubscribed",s=>new Promise(r=>{r(this.topicMap.topics.includes(s))})),he(this,"isKnownTopic",s=>new Promise(r=>{r(this.topicMap.topics.includes(s)||this.pending.has(s)||this.cached.some(o=>o.topic===s))})),he(this,"on",(s,r)=>{this.events.on(s,r)}),he(this,"once",(s,r)=>{this.events.once(s,r)}),he(this,"off",(s,r)=>{this.events.off(s,r)}),he(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),he(this,"start",async()=>{await this.onConnect()}),he(this,"stop",async()=>{await this.onDisconnect()}),he(this,"restart",async()=>{await this.restore(),await this.onRestart()}),he(this,"checkPending",async()=>{if(this.pending.size===0&&(!this.initialized||!this.relayer.connected))return;const s=[];this.pending.forEach(r=>{s.push(r)}),await this.batchSubscribe(s)}),he(this,"registerEventListeners",()=>{this.relayer.core.heartbeat.on(Ci.Lx.pulse,async()=>{await this.checkPending()}),this.events.on(Ke.created,async s=>{const r=Ke.created;this.logger.info(`Emitting ${r}`),this.logger.debug({type:"event",event:r,data:s}),await this.persist()}),this.events.on(Ke.deleted,async s=>{const r=Ke.deleted;this.logger.info(`Emitting ${r}`),this.logger.debug({type:"event",event:r,data:s}),await this.persist()})}),this.relayer=e,this.logger=(0,Z.Ep)(t,this.name),this.clientId=""}get context(){return(0,Z.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}get hasAnyTopics(){return this.topicMap.topics.length>0||this.pending.size>0||this.cached.length>0||this.subscriptions.size>0}hasSubscription(e,t){let s=!1;try{s=this.getSubscription(e).topic===t}catch{}return s}reset(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const s=this.topicMap.get(e);await Promise.all(s.map(async r=>await this.unsubscribeById(e,r,t)))}async unsubscribeById(e,t,s){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}});try{const r=Hs(s);await this.restartToComplete({topic:e,id:t,relay:r}),await this.rpcUnsubscribe(e,t,r);const o=ae("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,o),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}})}catch(r){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(r),r}}async rpcSubscribe(e,t,s){var r;(!s||(s==null?void 0:s.transportType)===pe.relay)&&await this.restartToComplete({topic:e,id:e,relay:t});const o={method:ds(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:o});const a=(r=s==null?void 0:s.internal)==null?void 0:r.throwOnFailedPublish;try{const c=await this.getSubscriptionId(e);if((s==null?void 0:s.transportType)===pe.link_mode)return setTimeout(()=>{(this.relayer.connected||this.relayer.connecting)&&this.relayer.request(o).catch(u=>this.logger.warn(u))},(0,D.toMiliseconds)(D.ONE_SECOND)),c;const h=new Promise(async u=>{const p=g=>{g.topic===e&&(this.events.removeListener(Ke.created,p),u(g.id))};this.events.on(Ke.created,p);try{const g=await $t(new Promise((_,f)=>{this.relayer.request(o).catch(y=>{this.logger.warn(y,y==null?void 0:y.message),f(y)}).then(_)}),this.initialSubscribeTimeout,`Subscribing to ${e} failed, please try again`);this.events.removeListener(Ke.created,p),u(g)}catch{}}),d=await $t(h,this.subscribeTimeout,`Subscribing to ${e} failed, please try again`);if(!d&&a)throw new Error(`Subscribing to ${e} failed, please try again`);return d?c:null}catch(c){if(this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(Ee.connection_stalled),a)throw c}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,s={method:ds(t.protocol).batchSubscribe,params:{topics:e.map(r=>r.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});try{await await $t(new Promise(r=>{this.relayer.request(s).catch(o=>this.logger.warn(o)).then(r)}),this.subscribeTimeout,"rpcBatchSubscribe failed, please try again")}catch{this.relayer.events.emit(Ee.connection_stalled)}}async rpcBatchFetchMessages(e){if(!e.length)return;const t=e[0].relay,s={method:ds(t.protocol).batchFetchMessages,params:{topics:e.map(o=>o.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});let r;try{r=await await $t(new Promise((o,a)=>{this.relayer.request(s).catch(c=>{this.logger.warn(c),a(c)}).then(o)}),this.subscribeTimeout,"rpcBatchFetchMessages failed, please try again")}catch{this.relayer.events.emit(Ee.connection_stalled)}return r}rpcUnsubscribe(e,t,s){const r={method:ds(s.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:r}),this.relayer.request(r)}onSubscribe(e,t){this.setSubscription(e,Ar(ys({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,ys({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,s){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,s),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,ys({},t)),this.topicMap.set(t.topic,e),this.events.emit(Ke.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:s}=$("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const s=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(s.topic,e),this.events.emit(Ke.deleted,Ar(ys({},s),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(Ke.sync)}async onRestart(){if(this.cached.length){const e=[...this.cached],t=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let s=0;s<t;s++){const r=e.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(r)}}this.events.emit(Ke.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=$("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){e.length&&(await this.rpcBatchSubscribe(e),this.onBatchSubscribe(await Promise.all(e.map(async t=>Ar(ys({},t),{id:await this.getSubscriptionId(t.topic)})))))}async batchFetchMessages(e){if(!e.length)return;this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);const t=await this.rpcBatchFetchMessages(e);t&&t.messages&&(await lg((0,D.toMiliseconds)(D.ONE_SECOND)),await this.relayer.handleBatchMessageEvents(t.messages))}async onConnect(){await this.restart(),this.reset()}onDisconnect(){this.onDisable()}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(e){!this.relayer.connected&&!this.relayer.connecting&&(this.cached.push(e),await this.relayer.transportOpen())}async getClientId(){return this.clientId||(this.clientId=await this.relayer.core.crypto.getClientId()),this.clientId}async getSubscriptionId(e){return yt(e+await this.getClientId())}}var Lb=Object.defineProperty,Ch=Object.getOwnPropertySymbols,kb=Object.prototype.hasOwnProperty,Mb=Object.prototype.propertyIsEnumerable,Cr=(i,e,t)=>e in i?Lb(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Rh=(i,e)=>{for(var t in e||(e={}))kb.call(e,t)&&Cr(i,t,e[t]);if(Ch)for(var t of Ch(e))Mb.call(e,t)&&Cr(i,t,e[t]);return i},ie=(i,e,t)=>Cr(i,typeof e!="symbol"?e+"":e,t);class zb extends V_{constructor(e){super(e),ie(this,"protocol","wc"),ie(this,"version",2),ie(this,"core"),ie(this,"logger"),ie(this,"events",new pt.EventEmitter),ie(this,"provider"),ie(this,"messages"),ie(this,"subscriber"),ie(this,"publisher"),ie(this,"name",bm),ie(this,"transportExplicitlyClosed",!1),ie(this,"initialized",!1),ie(this,"connectionAttemptInProgress",!1),ie(this,"relayUrl"),ie(this,"projectId"),ie(this,"packageName"),ie(this,"bundleId"),ie(this,"hasExperiencedNetworkDisruption",!1),ie(this,"pingTimeout"),ie(this,"heartBeatTimeout",(0,D.toMiliseconds)(D.THIRTY_SECONDS+D.FIVE_SECONDS)),ie(this,"reconnectTimeout"),ie(this,"connectPromise"),ie(this,"reconnectInProgress",!1),ie(this,"requestsInFlight",[]),ie(this,"connectTimeout",(0,D.toMiliseconds)(D.ONE_SECOND*15)),ie(this,"request",async t=>{var s,r;this.logger.debug("Publishing Request Payload");const o=t.id||(0,z.getBigIntRpcId)().toString();await this.toEstablishConnection();try{this.logger.trace({id:o,method:t.method,topic:(s=t.params)==null?void 0:s.topic},"relayer.request - publishing...");const a=`${o}:${((r=t.params)==null?void 0:r.tag)||""}`;this.requestsInFlight.push(a);const c=await this.provider.request(t);return this.requestsInFlight=this.requestsInFlight.filter(h=>h!==a),c}catch(a){throw this.logger.debug(`Failed to Publish Request: ${o}`),a}}),ie(this,"resetPingTimeout",()=>{Ts()&&(clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout(()=>{var t,s,r,o;try{this.logger.debug({},"pingTimeout: Connection stalled, terminating..."),(o=(r=(s=(t=this.provider)==null?void 0:t.connection)==null?void 0:s.socket)==null?void 0:r.terminate)==null||o.call(r)}catch(a){this.logger.warn(a,a==null?void 0:a.message)}},this.heartBeatTimeout))}),ie(this,"onPayloadHandler",t=>{this.onProviderPayload(t),this.resetPingTimeout()}),ie(this,"onConnectHandler",()=>{this.logger.warn({},"Relayer connected \u{1F6DC}"),this.startPingTimeout(),this.events.emit(Ee.connect)}),ie(this,"onDisconnectHandler",()=>{this.logger.warn({},"Relayer disconnected \u{1F6D1}"),this.requestsInFlight=[],this.onProviderDisconnect()}),ie(this,"onProviderErrorHandler",t=>{this.logger.fatal(`Fatal socket error: ${t.message}`),this.events.emit(Ee.error,t),this.logger.fatal("Fatal socket error received, closing transport"),this.transportClose()}),ie(this,"registerProviderListeners",()=>{this.provider.on(Ye.payload,this.onPayloadHandler),this.provider.on(Ye.connect,this.onConnectHandler),this.provider.on(Ye.disconnect,this.onDisconnectHandler),this.provider.on(Ye.error,this.onProviderErrorHandler)}),this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?(0,Z.Ep)(e.logger,this.name):(0,Z.gw)((0,Z.jI)({level:e.logger||wm})),this.messages=new Ib(this.logger,e.core),this.subscriber=new Ub(this,this.logger),this.publisher=new Rb(this,this.logger),this.relayUrl=(e==null?void 0:e.relayUrl)||ah,this.projectId=e.projectId,Kp()?this.packageName=va():Gp()&&(this.bundleId=va()),this.provider={}}async init(){if(this.logger.trace("Initialized"),this.registerEventListeners(),await Promise.all([this.messages.init(),this.subscriber.init()]),this.initialized=!0,this.subscriber.hasAnyTopics)try{await this.transportOpen()}catch(e){this.logger.warn(e,e==null?void 0:e.message)}}get context(){return(0,Z.Fd)(this.logger)}get connected(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===1||!1}get connecting(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===0||this.connectPromise!==void 0||!1}async publish(e,t,s){this.isInitialized(),await this.publisher.publish(e,t,s),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now(),transportType:pe.relay},Ys.outbound)}async subscribe(e,t){var s,r,o;this.isInitialized(),(!(t!=null&&t.transportType)||(t==null?void 0:t.transportType)==="relay")&&await this.toEstablishConnection();const a=typeof((s=t==null?void 0:t.internal)==null?void 0:s.throwOnFailedPublish)>"u"?!0:(r=t==null?void 0:t.internal)==null?void 0:r.throwOnFailedPublish;let c=((o=this.subscriber.topicMap.get(e))==null?void 0:o[0])||"",h;const d=u=>{u.topic===e&&(this.subscriber.off(Ke.created,d),h())};return await Promise.all([new Promise(u=>{h=u,this.subscriber.on(Ke.created,d)}),new Promise(async(u,p)=>{c=await this.subscriber.subscribe(e,Rh({internal:{throwOnFailedPublish:a}},t)).catch(g=>{a&&p(g)})||c,u()})]),c}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){this.provider.disconnect&&(this.hasExperiencedNetworkDisruption||this.connected)?await $t(this.provider.disconnect(),2e3,"provider.disconnect()").catch(()=>this.onProviderDisconnect()):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){if(!this.subscriber.hasAnyTopics){this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");return}if(this.connectPromise?(this.logger.debug({},"Waiting for existing connection attempt to resolve..."),await this.connectPromise,this.logger.debug({},"Existing connection attempt resolved")):(this.connectPromise=new Promise(async(t,s)=>{await this.connect(e).then(t).catch(s).finally(()=>{this.connectPromise=void 0})}),await this.connectPromise),!this.connected)throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)}async restartTransport(e){this.logger.debug({},"Restarting transport..."),!this.connectionAttemptInProgress&&(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await Zc())throw new Error("No internet connection detected. Please restart your network and try again.")}async handleBatchMessageEvents(e){if((e==null?void 0:e.length)===0){this.logger.trace("Batch message events is empty. Ignoring...");return}const t=e.sort((s,r)=>s.publishedAt-r.publishedAt);this.logger.debug(`Batch of ${t.length} message events sorted`);for(const s of t)try{await this.onMessageEvent(s)}catch(r){this.logger.warn(r,"Error while processing batch message event: "+(r==null?void 0:r.message))}this.logger.trace(`Batch of ${t.length} message events processed`)}async onLinkMessageEvent(e,t){const{topic:s}=e;if(!t.sessionExists){const r=we(D.FIVE_MINUTES),o={topic:s,expiry:r,relay:{protocol:"irn"},active:!1};await this.core.pairing.pairings.set(s,o)}this.events.emit(Ee.message,e),await this.recordMessageEvent(e,Ys.inbound)}async connect(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect()),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;let t=1;for(;t<6;){try{if(this.transportExplicitlyClosed)break;this.logger.debug({},`Connecting to ${this.relayUrl}, attempt: ${t}...`),await this.createProvider(),await new Promise(async(s,r)=>{const o=()=>{r(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(Ye.disconnect,o),await $t(new Promise((a,c)=>{this.provider.connect().then(a).catch(c)}),this.connectTimeout,`Socket stalled when trying to connect to ${this.relayUrl}`).catch(a=>{r(a)}).finally(()=>{this.provider.off(Ye.disconnect,o),clearTimeout(this.reconnectTimeout)}),await new Promise(async(a,c)=>{const h=()=>{c(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(Ye.disconnect,h),await this.subscriber.start().then(a).catch(c).finally(()=>{this.provider.off(Ye.disconnect,h)})}),this.hasExperiencedNetworkDisruption=!1,s()})}catch(s){await this.subscriber.stop();const r=s;this.logger.warn({},r.message),this.hasExperiencedNetworkDisruption=!0}finally{this.connectionAttemptInProgress=!1}if(this.connected){this.logger.debug({},`Connected to ${this.relayUrl} successfully on attempt: ${t}`);break}await new Promise(s=>setTimeout(s,(0,D.toMiliseconds)(t*1))),t++}}startPingTimeout(){var e,t,s,r,o;if(Ts())try{(t=(e=this.provider)==null?void 0:e.connection)!=null&&t.socket&&((o=(r=(s=this.provider)==null?void 0:s.connection)==null?void 0:r.socket)==null||o.on("ping",()=>{this.resetPingTimeout()})),this.resetPingTimeout()}catch(a){this.logger.warn(a,a==null?void 0:a.message)}}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new Ze.r(new cm(Qp({sdkVersion:br,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId,packageName:this.packageName}))),this.registerProviderListeners()}async recordMessageEvent(e,t){const{topic:s,message:r}=e;await this.messages.set(s,r,t)}async shouldIgnoreMessageEvent(e){const{topic:t,message:s}=e;if(!s||s.length===0)return this.logger.warn(`Ignoring invalid/empty message: ${s}`),!0;if(!await this.subscriber.isKnownTopic(t))return this.logger.warn(`Ignoring message for unknown topic ${t}`),!0;const r=this.messages.has(t,s);return r&&this.logger.warn(`Ignoring duplicate message: ${s}`),r}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),(0,z.isJsonRpcRequest)(e)){if(!e.method.endsWith(vm))return;const t=e.params,{topic:s,message:r,publishedAt:o,attestation:a}=t.data,c={topic:s,message:r,publishedAt:o,transportType:pe.relay,attestation:a};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(Rh({type:"event",event:t.id},c)),this.events.emit(t.id,c),await this.acknowledgePayload(e),await this.onMessageEvent(c)}else(0,z.isJsonRpcResponse)(e)&&this.events.emit(Ee.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(await this.recordMessageEvent(e,Ys.inbound),this.events.emit(Ee.message,e))}async acknowledgePayload(e){const t=(0,z.formatJsonRpcResult)(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(Ye.payload,this.onPayloadHandler),this.provider.off(Ye.connect,this.onConnectHandler),this.provider.off(Ye.disconnect,this.onDisconnectHandler),this.provider.off(Ye.error,this.onProviderErrorHandler),clearTimeout(this.pingTimeout)}async registerEventListeners(){let e=await Zc();v_(async t=>{e!==t&&(e=t,t?await this.transportOpen().catch(s=>this.logger.error(s,s==null?void 0:s.message)):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))})}async onProviderDisconnect(){clearTimeout(this.pingTimeout),this.events.emit(Ee.disconnect),this.connectionAttemptInProgress=!1,!this.reconnectInProgress&&(this.reconnectInProgress=!0,await this.subscriber.stop(),this.subscriber.hasAnyTopics&&(this.transportExplicitlyClosed||(this.reconnectTimeout=setTimeout(async()=>{await this.transportOpen().catch(e=>this.logger.error(e,e==null?void 0:e.message)),this.reconnectTimeout=void 0,this.reconnectInProgress=!1},(0,D.toMiliseconds)(xm)))))}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){await this.confirmOnlineStateOrThrow(),!this.connected&&await this.connect()}}function Hb(){}function Fh(i){if(!i||typeof i!="object")return!1;const e=Object.getPrototypeOf(i);return e===null||e===Object.prototype||Object.getPrototypeOf(e)===null?Object.prototype.toString.call(i)==="[object Object]":!1}function Nh(i){return Object.getOwnPropertySymbols(i).filter(e=>Object.prototype.propertyIsEnumerable.call(i,e))}function Th(i){return i==null?i===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(i)}const Vb="[object RegExp]",Kb="[object String]",Gb="[object Number]",Wb="[object Boolean]",Bh="[object Arguments]",Jb="[object Symbol]",Zb="[object Date]",Yb="[object Map]",Qb="[object Set]",Xb="[object Array]",e0="[object Function]",t0="[object ArrayBuffer]",Rr="[object Object]",i0="[object Error]",s0="[object DataView]",n0="[object Uint8Array]",r0="[object Uint8ClampedArray]",o0="[object Uint16Array]",a0="[object Uint32Array]",c0="[object BigUint64Array]",h0="[object Int8Array]",d0="[object Int16Array]",l0="[object Int32Array]",u0="[object BigInt64Array]",p0="[object Float32Array]",g0="[object Float64Array]";function f0(i,e){return i===e||Number.isNaN(i)&&Number.isNaN(e)}function y0(i,e,t){return _s(i,e,void 0,void 0,void 0,void 0,t)}function _s(i,e,t,s,r,o,a){const c=a(i,e,t,s,r,o);if(c!==void 0)return c;if(typeof i==typeof e)switch(typeof i){case"bigint":case"string":case"boolean":case"symbol":case"undefined":return i===e;case"number":return i===e||Object.is(i,e);case"function":return i===e;case"object":return ms(i,e,o,a)}return ms(i,e,o,a)}function ms(i,e,t,s){if(Object.is(i,e))return!0;let r=Th(i),o=Th(e);if(r===Bh&&(r=Rr),o===Bh&&(o=Rr),r!==o)return!1;switch(r){case Kb:return i.toString()===e.toString();case Gb:{const h=i.valueOf(),d=e.valueOf();return f0(h,d)}case Wb:case Zb:case Jb:return Object.is(i.valueOf(),e.valueOf());case Vb:return i.source===e.source&&i.flags===e.flags;case e0:return i===e}t=t??new Map;const a=t.get(i),c=t.get(e);if(a!=null&&c!=null)return a===e;t.set(i,e),t.set(e,i);try{switch(r){case Yb:{if(i.size!==e.size)return!1;for(const[h,d]of i.entries())if(!e.has(h)||!_s(d,e.get(h),h,i,e,t,s))return!1;return!0}case Qb:{if(i.size!==e.size)return!1;const h=Array.from(i.values()),d=Array.from(e.values());for(let u=0;u<h.length;u++){const p=h[u],g=d.findIndex(_=>_s(p,_,void 0,i,e,t,s));if(g===-1)return!1;d.splice(g,1)}return!0}case Xb:case n0:case r0:case o0:case a0:case c0:case h0:case d0:case l0:case u0:case p0:case g0:{if(typeof wr<"u"&&wr.isBuffer(i)!==wr.isBuffer(e)||i.length!==e.length)return!1;for(let h=0;h<i.length;h++)if(!_s(i[h],e[h],h,i,e,t,s))return!1;return!0}case t0:return i.byteLength!==e.byteLength?!1:ms(new Uint8Array(i),new Uint8Array(e),t,s);case s0:return i.byteLength!==e.byteLength||i.byteOffset!==e.byteOffset?!1:ms(new Uint8Array(i),new Uint8Array(e),t,s);case i0:return i.name===e.name&&i.message===e.message;case Rr:{if(!(ms(i.constructor,e.constructor,t,s)||Fh(i)&&Fh(e)))return!1;const h=[...Object.keys(i),...Nh(i)],d=[...Object.keys(e),...Nh(e)];if(h.length!==d.length)return!1;for(let u=0;u<h.length;u++){const p=h[u],g=i[p];if(!Object.hasOwn(e,p))return!1;const _=e[p];if(!_s(g,_,p,i,e,t,s))return!1}return!0}default:return!1}}finally{t.delete(i),t.delete(e)}}function _0(i,e){return y0(i,e,Hb)}var m0=Object.defineProperty,Dh=Object.getOwnPropertySymbols,w0=Object.prototype.hasOwnProperty,b0=Object.prototype.propertyIsEnumerable,Fr=(i,e,t)=>e in i?m0(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,$h=(i,e)=>{for(var t in e||(e={}))w0.call(e,t)&&Fr(i,t,e[t]);if(Dh)for(var t of Dh(e))b0.call(e,t)&&Fr(i,t,e[t]);return i},ze=(i,e,t)=>Fr(i,typeof e!="symbol"?e+"":e,t);class ri extends K_{constructor(e,t,s,r=_t,o=void 0){super(e,t,s,r),this.core=e,this.logger=t,this.name=s,ze(this,"map",new Map),ze(this,"version",Em),ze(this,"cached",[]),ze(this,"initialized",!1),ze(this,"getKey"),ze(this,"storagePrefix",_t),ze(this,"recentlyDeleted",[]),ze(this,"recentlyDeletedLimit",200),ze(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(a=>{this.getKey&&a!==null&&!Ae(a)?this.map.set(this.getKey(a),a):Qy(a)?this.map.set(a.id,a):Xy(a)&&this.map.set(a.topic,a)}),this.cached=[],this.initialized=!0)}),ze(this,"set",async(a,c)=>{this.isInitialized(),this.map.has(a)?await this.update(a,c):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:a,value:c}),this.map.set(a,c),await this.persist())}),ze(this,"get",a=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:a}),this.getData(a))),ze(this,"getAll",a=>(this.isInitialized(),a?this.values.filter(c=>Object.keys(a).every(h=>_0(c[h],a[h]))):this.values)),ze(this,"update",async(a,c)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:a,update:c});const h=$h($h({},this.getData(a)),c);this.map.set(a,h),await this.persist()}),ze(this,"delete",async(a,c)=>{this.isInitialized(),this.map.has(a)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:a,reason:c}),this.map.delete(a),this.addToRecentlyDeleted(a),await this.persist())}),this.logger=(0,Z.Ep)(t,this.name),this.storagePrefix=r,this.getKey=o}get context(){return(0,Z.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:r}=$("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(r),new Error(r)}const{message:s}=$("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(s),new Error(s)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=$("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}}var v0=Object.defineProperty,x0=(i,e,t)=>e in i?v0(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Y=(i,e,t)=>x0(i,typeof e!="symbol"?e+"":e,t);class E0{constructor(e,t){this.core=e,this.logger=t,Y(this,"name",Om),Y(this,"version",Am),Y(this,"events",new(hn())),Y(this,"pairings"),Y(this,"initialized",!1),Y(this,"storagePrefix",_t),Y(this,"ignoredPayloadTypes",[Rt]),Y(this,"registeredMethods",[]),Y(this,"init",async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))}),Y(this,"register",({methods:s})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...s])]}),Y(this,"create",async s=>{this.isInitialized();const r=gr(),o=await this.core.crypto.setSymKey(r),a=we(D.FIVE_MINUTES),c={protocol:oh},h={topic:o,expiry:a,relay:c,active:!1,methods:s==null?void 0:s.methods},d=Lc({protocol:this.core.protocol,version:this.core.version,topic:o,symKey:r,relay:c,expiryTimestamp:a,methods:s==null?void 0:s.methods});return this.events.emit(ii.create,h),this.core.expirer.set(o,a),await this.pairings.set(o,h),await this.core.relayer.subscribe(o,{transportType:s==null?void 0:s.transportType}),{topic:o,uri:d}}),Y(this,"pair",async s=>{this.isInitialized();const r=this.core.eventClient.createEvent({properties:{topic:s==null?void 0:s.uri,trace:[mt.pairing_started]}});this.isValidPair(s,r);const{topic:o,symKey:a,relay:c,expiryTimestamp:h,methods:d}=Uc(s.uri);r.props.properties.topic=o,r.addTrace(mt.pairing_uri_validation_success),r.addTrace(mt.pairing_uri_not_expired);let u;if(this.pairings.keys.includes(o)){if(u=this.pairings.get(o),r.addTrace(mt.existing_pairing),u.active)throw r.setError(Ft.active_pairing_already_exists),new Error(`Pairing already exists: ${o}. Please try again with a new connection URI.`);r.addTrace(mt.pairing_not_expired)}const p=h||we(D.FIVE_MINUTES),g={topic:o,relay:c,expiry:p,active:!1,methods:d};this.core.expirer.set(o,p),await this.pairings.set(o,g),r.addTrace(mt.store_new_pairing),s.activatePairing&&await this.activate({topic:o}),this.events.emit(ii.create,g),r.addTrace(mt.emit_inactive_pairing),this.core.crypto.keychain.has(o)||await this.core.crypto.setSymKey(a,o),r.addTrace(mt.subscribing_pairing_topic);try{await this.core.relayer.confirmOnlineStateOrThrow()}catch{r.setError(Ft.no_internet_connection)}try{await this.core.relayer.subscribe(o,{relay:c})}catch(_){throw r.setError(Ft.subscribe_pairing_topic_failure),_}return r.addTrace(mt.subscribe_pairing_topic_success),g}),Y(this,"activate",async({topic:s})=>{this.isInitialized();const r=we(D.FIVE_MINUTES);this.core.expirer.set(s,r),await this.pairings.update(s,{active:!0,expiry:r})}),Y(this,"ping",async s=>{this.isInitialized(),await this.isValidPing(s),this.logger.warn("ping() is deprecated and will be removed in the next major release.");const{topic:r}=s;if(this.pairings.keys.includes(r)){const o=await this.sendRequest(r,"wc_pairingPing",{}),{done:a,resolve:c,reject:h}=Jt();this.events.once(oe("pairing_ping",o),({error:d})=>{d?h(d):c()}),await a()}}),Y(this,"updateExpiry",async({topic:s,expiry:r})=>{this.isInitialized(),await this.pairings.update(s,{expiry:r})}),Y(this,"updateMetadata",async({topic:s,metadata:r})=>{this.isInitialized(),await this.pairings.update(s,{peerMetadata:r})}),Y(this,"getPairings",()=>(this.isInitialized(),this.pairings.values)),Y(this,"disconnect",async s=>{this.isInitialized(),await this.isValidDisconnect(s);const{topic:r}=s;this.pairings.keys.includes(r)&&(await this.sendRequest(r,"wc_pairingDelete",ae("USER_DISCONNECTED")),await this.deletePairing(r))}),Y(this,"formatUriFromPairing",s=>{this.isInitialized();const{topic:r,relay:o,expiry:a,methods:c}=s,h=this.core.crypto.keychain.get(r);return Lc({protocol:this.core.protocol,version:this.core.version,topic:r,symKey:h,relay:o,expiryTimestamp:a,methods:c})}),Y(this,"sendRequest",async(s,r,o)=>{const a=(0,z.formatJsonRpcRequest)(r,o),c=await this.core.crypto.encode(s,a),h=us[r].req;return this.core.history.set(s,a),this.core.relayer.publish(s,c,h),a.id}),Y(this,"sendResult",async(s,r,o)=>{const a=(0,z.formatJsonRpcResult)(s,o),c=await this.core.crypto.encode(r,a),h=(await this.core.history.get(r,s)).request.method,d=us[h].res;await this.core.relayer.publish(r,c,d),await this.core.history.resolve(a)}),Y(this,"sendError",async(s,r,o)=>{const a=(0,z.formatJsonRpcError)(s,o),c=await this.core.crypto.encode(r,a),h=(await this.core.history.get(r,s)).request.method,d=us[h]?us[h].res:us.unregistered_method.res;await this.core.relayer.publish(r,c,d),await this.core.history.resolve(a)}),Y(this,"deletePairing",async(s,r)=>{await this.core.relayer.unsubscribe(s),await Promise.all([this.pairings.delete(s,ae("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(s),r?Promise.resolve():this.core.expirer.del(s)])}),Y(this,"cleanup",async()=>{const s=this.pairings.getAll().filter(r=>jt(r.expiry));await Promise.all(s.map(r=>this.deletePairing(r.topic)))}),Y(this,"onRelayEventRequest",async s=>{const{topic:r,payload:o}=s;switch(o.method){case"wc_pairingPing":return await this.onPairingPingRequest(r,o);case"wc_pairingDelete":return await this.onPairingDeleteRequest(r,o);default:return await this.onUnknownRpcMethodRequest(r,o)}}),Y(this,"onRelayEventResponse",async s=>{const{topic:r,payload:o}=s,a=(await this.core.history.get(r,o.id)).request.method;switch(a){case"wc_pairingPing":return this.onPairingPingResponse(r,o);default:return this.onUnknownRpcMethodResponse(a)}}),Y(this,"onPairingPingRequest",async(s,r)=>{const{id:o}=r;try{this.isValidPing({topic:s}),await this.sendResult(o,s,!0),this.events.emit(ii.ping,{id:o,topic:s})}catch(a){await this.sendError(o,s,a),this.logger.error(a)}}),Y(this,"onPairingPingResponse",(s,r)=>{const{id:o}=r;setTimeout(()=>{(0,z.isJsonRpcResult)(r)?this.events.emit(oe("pairing_ping",o),{}):(0,z.isJsonRpcError)(r)&&this.events.emit(oe("pairing_ping",o),{error:r.error})},500)}),Y(this,"onPairingDeleteRequest",async(s,r)=>{const{id:o}=r;try{this.isValidDisconnect({topic:s}),await this.deletePairing(s),this.events.emit(ii.delete,{id:o,topic:s})}catch(a){await this.sendError(o,s,a),this.logger.error(a)}}),Y(this,"onUnknownRpcMethodRequest",async(s,r)=>{const{id:o,method:a}=r;try{if(this.registeredMethods.includes(a))return;const c=ae("WC_METHOD_UNSUPPORTED",a);await this.sendError(o,s,c),this.logger.error(c)}catch(c){await this.sendError(o,s,c),this.logger.error(c)}}),Y(this,"onUnknownRpcMethodResponse",s=>{this.registeredMethods.includes(s)||this.logger.error(ae("WC_METHOD_UNSUPPORTED",s))}),Y(this,"isValidPair",(s,r)=>{var o;if(!Me(s)){const{message:c}=$("MISSING_OR_INVALID",`pair() params: ${s}`);throw r.setError(Ft.malformed_pairing_uri),new Error(c)}if(!Yy(s.uri)){const{message:c}=$("MISSING_OR_INVALID",`pair() uri: ${s.uri}`);throw r.setError(Ft.malformed_pairing_uri),new Error(c)}const a=Uc(s==null?void 0:s.uri);if(!((o=a==null?void 0:a.relay)!=null&&o.protocol)){const{message:c}=$("MISSING_OR_INVALID","pair() uri#relay-protocol");throw r.setError(Ft.malformed_pairing_uri),new Error(c)}if(!(a!=null&&a.symKey)){const{message:c}=$("MISSING_OR_INVALID","pair() uri#symKey");throw r.setError(Ft.malformed_pairing_uri),new Error(c)}if(a!=null&&a.expiryTimestamp&&(0,D.toMiliseconds)(a==null?void 0:a.expiryTimestamp)<Date.now()){r.setError(Ft.pairing_expired);const{message:c}=$("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(c)}}),Y(this,"isValidPing",async s=>{if(!Me(s)){const{message:o}=$("MISSING_OR_INVALID",`ping() params: ${s}`);throw new Error(o)}const{topic:r}=s;await this.isValidPairingTopic(r)}),Y(this,"isValidDisconnect",async s=>{if(!Me(s)){const{message:o}=$("MISSING_OR_INVALID",`disconnect() params: ${s}`);throw new Error(o)}const{topic:r}=s;await this.isValidPairingTopic(r)}),Y(this,"isValidPairingTopic",async s=>{if(!ye(s,!1)){const{message:r}=$("MISSING_OR_INVALID",`pairing topic should be a string: ${s}`);throw new Error(r)}if(!this.pairings.keys.includes(s)){const{message:r}=$("NO_MATCHING_KEY",`pairing topic doesn't exist: ${s}`);throw new Error(r)}if(jt(this.pairings.get(s).expiry)){await this.deletePairing(s);const{message:r}=$("EXPIRED",`pairing topic: ${s}`);throw new Error(r)}}),this.core=e,this.logger=(0,Z.Ep)(t,this.name),this.pairings=new ri(this.core,this.logger,this.name,this.storagePrefix)}get context(){return(0,Z.Fd)(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(Ee.message,async e=>{const{topic:t,message:s,transportType:r}=e;if(this.pairings.keys.includes(t)&&r!==pe.link_mode&&!this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s)))try{const o=await this.core.crypto.decode(t,s);(0,z.isJsonRpcRequest)(o)?(this.core.history.set(t,o),await this.onRelayEventRequest({topic:t,payload:o})):(0,z.isJsonRpcResponse)(o)&&(await this.core.history.resolve(o),await this.onRelayEventResponse({topic:t,payload:o}),this.core.history.delete(t,o.id)),await this.core.relayer.messages.ack(t,s)}catch(o){this.logger.error(o)}})}registerExpirerEvents(){this.core.expirer.on(Qe.expired,async e=>{const{topic:t}=Pa(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(ii.expire,{topic:t}))})}}var I0=Object.defineProperty,P0=(i,e,t)=>e in i?I0(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ne=(i,e,t)=>P0(i,typeof e!="symbol"?e+"":e,t);class S0 extends M_{constructor(e,t){super(e,t),this.core=e,this.logger=t,Ne(this,"records",new Map),Ne(this,"events",new pt.EventEmitter),Ne(this,"name",Cm),Ne(this,"version",Rm),Ne(this,"cached",[]),Ne(this,"initialized",!1),Ne(this,"storagePrefix",_t),Ne(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.records.set(s.id,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),Ne(this,"set",(s,r,o)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:s,request:r,chainId:o}),this.records.has(r.id))return;const a={id:r.id,topic:s,request:{method:r.method,params:r.params||null},chainId:o,expiry:we(D.THIRTY_DAYS)};this.records.set(a.id,a),this.persist(),this.events.emit(ht.created,a)}),Ne(this,"resolve",async s=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:s}),!this.records.has(s.id))return;const r=await this.getRecord(s.id);typeof r.response>"u"&&(r.response=(0,z.isJsonRpcError)(s)?{error:s.error}:{result:s.result},this.records.set(r.id,r),this.persist(),this.events.emit(ht.updated,r))}),Ne(this,"get",async(s,r)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:s,id:r}),await this.getRecord(r))),Ne(this,"delete",(s,r)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:r}),this.values.forEach(o=>{if(o.topic===s){if(typeof r<"u"&&o.id!==r)return;this.records.delete(o.id),this.events.emit(ht.deleted,o)}}),this.persist()}),Ne(this,"exists",async(s,r)=>(this.isInitialized(),this.records.has(r)?(await this.getRecord(r)).topic===s:!1)),Ne(this,"on",(s,r)=>{this.events.on(s,r)}),Ne(this,"once",(s,r)=>{this.events.once(s,r)}),Ne(this,"off",(s,r)=>{this.events.off(s,r)}),Ne(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),this.logger=(0,Z.Ep)(t,this.name)}get context(){return(0,Z.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const s={topic:t.topic,request:(0,z.formatJsonRpcRequest)(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(s)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:s}=$("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(ht.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=$("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(ht.created,e=>{const t=ht.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(ht.updated,e=>{const t=ht.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(ht.deleted,e=>{const t=ht.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.core.heartbeat.on(Ci.Lx.pulse,()=>{this.cleanup()})}cleanup(){try{this.isInitialized();let e=!1;this.records.forEach(t=>{(0,D.toMiliseconds)(t.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${t.id}`),this.records.delete(t.id),this.events.emit(ht.deleted,t,!1),e=!0)}),e&&this.persist()}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}}var O0=Object.defineProperty,A0=(i,e,t)=>e in i?O0(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Be=(i,e,t)=>A0(i,typeof e!="symbol"?e+"":e,t);class C0 extends Y_{constructor(e,t){super(e,t),this.core=e,this.logger=t,Be(this,"expirations",new Map),Be(this,"events",new pt.EventEmitter),Be(this,"name",Fm),Be(this,"version",Nm),Be(this,"cached",[]),Be(this,"initialized",!1),Be(this,"storagePrefix",_t),Be(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.expirations.set(s.target,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),Be(this,"has",s=>{try{const r=this.formatTarget(s);return typeof this.getExpiration(r)<"u"}catch{return!1}}),Be(this,"set",(s,r)=>{this.isInitialized();const o=this.formatTarget(s),a={target:o,expiry:r};this.expirations.set(o,a),this.checkExpiry(o,a),this.events.emit(Qe.created,{target:o,expiration:a})}),Be(this,"get",s=>{this.isInitialized();const r=this.formatTarget(s);return this.getExpiration(r)}),Be(this,"del",s=>{if(this.isInitialized(),this.has(s)){const r=this.formatTarget(s),o=this.getExpiration(r);this.expirations.delete(r),this.events.emit(Qe.deleted,{target:r,expiration:o})}}),Be(this,"on",(s,r)=>{this.events.on(s,r)}),Be(this,"once",(s,r)=>{this.events.once(s,r)}),Be(this,"off",(s,r)=>{this.events.off(s,r)}),Be(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),this.logger=(0,Z.Ep)(t,this.name)}get context(){return(0,Z.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return ig(e);if(typeof e=="number")return sg(e);const{message:t}=$("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(Qe.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=$("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:s}=$("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(s),new Error(s)}return t}checkExpiry(e,t){const{expiry:s}=t;(0,D.toMiliseconds)(s)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(Qe.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(Ci.Lx.pulse,()=>this.checkExpirations()),this.events.on(Qe.created,e=>{const t=Qe.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(Qe.expired,e=>{const t=Qe.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(Qe.deleted,e=>{const t=Qe.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}}var R0=Object.defineProperty,F0=(i,e,t)=>e in i?R0(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,_e=(i,e,t)=>F0(i,typeof e!="symbol"?e+"":e,t);class N0 extends Q_{constructor(e,t,s){super(e,t,s),this.core=e,this.logger=t,this.store=s,_e(this,"name",Tm),_e(this,"abortController"),_e(this,"isDevEnv"),_e(this,"verifyUrlV3",Dm),_e(this,"storagePrefix",_t),_e(this,"version",sh),_e(this,"publicKey"),_e(this,"fetchPromise"),_e(this,"init",async()=>{var r;this.isDevEnv||(this.publicKey=await this.store.getItem(this.storeKey),this.publicKey&&(0,D.toMiliseconds)((r=this.publicKey)==null?void 0:r.expiresAt)<Date.now()&&(this.logger.debug("verify v2 public key expired"),await this.removePublicKey()))}),_e(this,"register",async r=>{if(!Qi()||this.isDevEnv)return;const o=window.location.origin,{id:a,decryptedId:c}=r,h=`${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${o}&id=${a}&decryptedId=${c}`;try{const d=(0,zt.getDocument)(),u=this.startAbortTimer(D.ONE_SECOND*5),p=await new Promise((g,_)=>{const f=()=>{window.removeEventListener("message",m),d.body.removeChild(y),_("attestation aborted")};this.abortController.signal.addEventListener("abort",f);const y=d.createElement("iframe");y.src=h,y.style.display="none",y.addEventListener("error",f,{signal:this.abortController.signal});const m=v=>{if(v.data&&typeof v.data=="string")try{const w=JSON.parse(v.data);if(w.type==="verify_attestation"){if(Rs(w.attestation).payload.id!==a)return;clearInterval(u),d.body.removeChild(y),this.abortController.signal.removeEventListener("abort",f),window.removeEventListener("message",m),g(w.attestation===null?"":w.attestation)}}catch(w){this.logger.warn(w)}};d.body.appendChild(y),window.addEventListener("message",m,{signal:this.abortController.signal})});return this.logger.debug("jwt attestation",p),p}catch(d){this.logger.warn(d)}return""}),_e(this,"resolve",async r=>{if(this.isDevEnv)return"";const{attestationId:o,hash:a,encryptedId:c}=r;if(o===""){this.logger.debug("resolve: attestationId is empty, skipping");return}if(o){if(Rs(o).payload.id!==c)return;const d=await this.isValidJwtAttestation(o);if(d){if(!d.isVerified){this.logger.warn("resolve: jwt attestation: origin url not verified");return}return d}}if(!a)return;const h=this.getVerifyUrl(r==null?void 0:r.verifyUrl);return this.fetchAttestation(a,h)}),_e(this,"fetchAttestation",async(r,o)=>{this.logger.debug(`resolving attestation: ${r} from url: ${o}`);const a=this.startAbortTimer(D.ONE_SECOND*5),c=await fetch(`${o}/attestation/${r}?v2Supported=true`,{signal:this.abortController.signal});return clearTimeout(a),c.status===200?await c.json():void 0}),_e(this,"getVerifyUrl",r=>{let o=r||ps;return $m.includes(o)||(this.logger.info(`verify url: ${o}, not included in trusted list, assigning default: ${ps}`),o=ps),o}),_e(this,"fetchPublicKey",async()=>{try{this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);const r=this.startAbortTimer(D.FIVE_SECONDS),o=await fetch(`${this.verifyUrlV3}/public-key`,{signal:this.abortController.signal});return clearTimeout(r),await o.json()}catch(r){this.logger.warn(r)}}),_e(this,"persistPublicKey",async r=>{this.logger.debug("persisting public key to local storage",r),await this.store.setItem(this.storeKey,r),this.publicKey=r}),_e(this,"removePublicKey",async()=>{this.logger.debug("removing verify v2 public key from storage"),await this.store.removeItem(this.storeKey),this.publicKey=void 0}),_e(this,"isValidJwtAttestation",async r=>{const o=await this.getPublicKey();try{if(o)return this.validateAttestation(r,o)}catch(c){this.logger.error(c),this.logger.warn("error validating attestation")}const a=await this.fetchAndPersistPublicKey();try{if(a)return this.validateAttestation(r,a)}catch(c){this.logger.error(c),this.logger.warn("error validating attestation")}}),_e(this,"getPublicKey",async()=>this.publicKey?this.publicKey:await this.fetchAndPersistPublicKey()),_e(this,"fetchAndPersistPublicKey",async()=>{if(this.fetchPromise)return await this.fetchPromise,this.publicKey;this.fetchPromise=new Promise(async o=>{const a=await this.fetchPublicKey();a&&(await this.persistPublicKey(a),o(a))});const r=await this.fetchPromise;return this.fetchPromise=void 0,r}),_e(this,"validateAttestation",(r,o)=>{const a=Fy(r,o.publicKey),c={hasExpired:(0,D.toMiliseconds)(a.exp)<Date.now(),payload:a};if(c.hasExpired)throw this.logger.warn("resolve: jwt attestation expired"),new Error("JWT attestation expired");return{origin:c.payload.origin,isScam:c.payload.isScam,isVerified:c.payload.isVerified}}),this.logger=(0,Z.Ep)(t,this.name),this.abortController=new AbortController,this.isDevEnv=Un(),this.init()}get storeKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//verify:public:key"}get context(){return(0,Z.Fd)(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),(0,D.toMiliseconds)(e))}}var T0=Object.defineProperty,B0=(i,e,t)=>e in i?T0(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,jh=(i,e,t)=>B0(i,typeof e!="symbol"?e+"":e,t);class D0 extends X_{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,jh(this,"context",jm),jh(this,"registerDeviceToken",async s=>{const{clientId:r,token:o,notificationType:a,enableEncrypted:c=!1}=s,h=`${qm}/${this.projectId}/clients`;await fetch(h,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:r,type:a,token:o,always_raw:c})})}),this.logger=(0,Z.Ep)(t,this.context)}}var $0=Object.defineProperty,qh=Object.getOwnPropertySymbols,j0=Object.prototype.hasOwnProperty,q0=Object.prototype.propertyIsEnumerable,Nr=(i,e,t)=>e in i?$0(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ws=(i,e)=>{for(var t in e||(e={}))j0.call(e,t)&&Nr(i,t,e[t]);if(qh)for(var t of qh(e))q0.call(e,t)&&Nr(i,t,e[t]);return i},Ie=(i,e,t)=>Nr(i,typeof e!="symbol"?e+"":e,t);class U0 extends em{constructor(e,t,s=!0){super(e,t,s),this.core=e,this.logger=t,Ie(this,"context",Lm),Ie(this,"storagePrefix",_t),Ie(this,"storageVersion",Um),Ie(this,"events",new Map),Ie(this,"shouldPersist",!1),Ie(this,"init",async()=>{if(!Un())try{const r={eventId:Aa(),timestamp:Date.now(),domain:this.getAppDomain(),props:{event:"INIT",type:"",properties:{client_id:await this.core.crypto.getClientId(),user_agent:Ea(this.core.relayer.protocol,this.core.relayer.version,br)}}};await this.sendEvent([r])}catch(r){this.logger.warn(r)}}),Ie(this,"createEvent",r=>{const{event:o="ERROR",type:a="",properties:{topic:c,trace:h}}=r,d=Aa(),u=this.core.projectId||"",p=Date.now(),g=ws({eventId:d,timestamp:p,props:{event:o,type:a,properties:{topic:c,trace:h}},bundleId:u,domain:this.getAppDomain()},this.setMethods(d));return this.telemetryEnabled&&(this.events.set(d,g),this.shouldPersist=!0),g}),Ie(this,"getEvent",r=>{const{eventId:o,topic:a}=r;if(o)return this.events.get(o);const c=Array.from(this.events.values()).find(h=>h.props.properties.topic===a);if(c)return ws(ws({},c),this.setMethods(c.eventId))}),Ie(this,"deleteEvent",r=>{const{eventId:o}=r;this.events.delete(o),this.shouldPersist=!0}),Ie(this,"setEventListeners",()=>{this.core.heartbeat.on(Ci.Lx.pulse,async()=>{this.shouldPersist&&await this.persist(),this.events.forEach(r=>{(0,D.fromMiliseconds)(Date.now())-(0,D.fromMiliseconds)(r.timestamp)>km&&(this.events.delete(r.eventId),this.shouldPersist=!0)})})}),Ie(this,"setMethods",r=>({addTrace:o=>this.addTrace(r,o),setError:o=>this.setError(r,o)})),Ie(this,"addTrace",(r,o)=>{const a=this.events.get(r);a&&(a.props.properties.trace.push(o),this.events.set(r,a),this.shouldPersist=!0)}),Ie(this,"setError",(r,o)=>{const a=this.events.get(r);a&&(a.props.type=o,a.timestamp=Date.now(),this.events.set(r,a),this.shouldPersist=!0)}),Ie(this,"persist",async()=>{await this.core.storage.setItem(this.storageKey,Array.from(this.events.values())),this.shouldPersist=!1}),Ie(this,"restore",async()=>{try{const r=await this.core.storage.getItem(this.storageKey)||[];if(!r.length)return;r.forEach(o=>{this.events.set(o.eventId,ws(ws({},o),this.setMethods(o.eventId)))})}catch(r){this.logger.warn(r)}}),Ie(this,"submit",async()=>{if(!this.telemetryEnabled||this.events.size===0)return;const r=[];for(const[o,a]of this.events)a.props.type&&r.push(a);if(r.length!==0)try{if((await this.sendEvent(r)).ok)for(const o of r)this.events.delete(o.eventId),this.shouldPersist=!0}catch(o){this.logger.warn(o)}}),Ie(this,"sendEvent",async r=>{const o=this.getAppDomain()?"":"&sp=desktop";return await fetch(`${Mm}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${br}${o}`,{method:"POST",body:JSON.stringify(r)})}),Ie(this,"getAppDomain",()=>xa().url),this.logger=(0,Z.Ep)(t,this.context),this.telemetryEnabled=s,s?this.restore().then(async()=>{await this.submit(),this.setEventListeners()}):this.persist()}get storageKey(){return this.storagePrefix+this.storageVersion+this.core.customStoragePrefix+"//"+this.context}}var L0=Object.defineProperty,Uh=Object.getOwnPropertySymbols,k0=Object.prototype.hasOwnProperty,M0=Object.prototype.propertyIsEnumerable,Tr=(i,e,t)=>e in i?L0(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Lh=(i,e)=>{for(var t in e||(e={}))k0.call(e,t)&&Tr(i,t,e[t]);if(Uh)for(var t of Uh(e))M0.call(e,t)&&Tr(i,t,e[t]);return i},le=(i,e,t)=>Tr(i,typeof e!="symbol"?e+"":e,t);class Br extends q_{constructor(e){var t;super(e),le(this,"protocol",ih),le(this,"version",sh),le(this,"name",Zs),le(this,"relayUrl"),le(this,"projectId"),le(this,"customStoragePrefix"),le(this,"events",new pt.EventEmitter),le(this,"logger"),le(this,"heartbeat"),le(this,"relayer"),le(this,"crypto"),le(this,"storage"),le(this,"history"),le(this,"expirer"),le(this,"pairing"),le(this,"verify"),le(this,"echoClient"),le(this,"linkModeSupportedApps"),le(this,"eventClient"),le(this,"initialized",!1),le(this,"logChunkController"),le(this,"on",(c,h)=>this.events.on(c,h)),le(this,"once",(c,h)=>this.events.once(c,h)),le(this,"off",(c,h)=>this.events.off(c,h)),le(this,"removeListener",(c,h)=>this.events.removeListener(c,h)),le(this,"dispatchEnvelope",({topic:c,message:h,sessionExists:d})=>{if(!c||!h)return;const u={topic:c,message:h,publishedAt:Date.now(),transportType:pe.link_mode};this.relayer.onLinkMessageEvent(u,{sessionExists:d})});const s=this.getGlobalCore(e==null?void 0:e.customStoragePrefix);if(s)try{return this.customStoragePrefix=s.customStoragePrefix,this.logger=s.logger,this.heartbeat=s.heartbeat,this.crypto=s.crypto,this.history=s.history,this.expirer=s.expirer,this.storage=s.storage,this.relayer=s.relayer,this.pairing=s.pairing,this.verify=s.verify,this.echoClient=s.echoClient,this.linkModeSupportedApps=s.linkModeSupportedApps,this.eventClient=s.eventClient,this.initialized=s.initialized,this.logChunkController=s.logChunkController,s}catch(c){console.warn("Failed to copy global core",c)}this.projectId=e==null?void 0:e.projectId,this.relayUrl=(e==null?void 0:e.relayUrl)||ah,this.customStoragePrefix=e!=null&&e.customStoragePrefix?`:${e.customStoragePrefix}`:"";const r=(0,Z.jI)({level:typeof(e==null?void 0:e.logger)=="string"&&e.logger?e.logger:dm.logger,name:Zs}),{logger:o,chunkLoggerController:a}=(0,Z.Rt)({opts:r,maxSizeInBytes:e==null?void 0:e.maxLogBlobSizeInBytes,loggerOverride:e==null?void 0:e.logger});this.logChunkController=a,(t=this.logChunkController)!=null&&t.downloadLogsBlobInBrowser&&(window.downloadLogsBlobInBrowser=async()=>{var c,h;(c=this.logChunkController)!=null&&c.downloadLogsBlobInBrowser&&((h=this.logChunkController)==null||h.downloadLogsBlobInBrowser({clientId:await this.crypto.getClientId()}))}),this.logger=(0,Z.Ep)(o,this.name),this.heartbeat=new Ci.C$,this.crypto=new yb(this,this.logger,e==null?void 0:e.keychain),this.history=new S0(this,this.logger),this.expirer=new C0(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new D_(Lh(Lh({},lm),e==null?void 0:e.storageOptions)),this.relayer=new zb({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new E0(this,this.logger),this.verify=new N0(this,this.logger,this.storage),this.echoClient=new D0(this.projectId||"",this.logger),this.linkModeSupportedApps=[],this.eventClient=new U0(this,this.logger,e==null?void 0:e.telemetryEnabled),this.setGlobalCore(this)}static async init(e){const t=new Br(e);await t.initialize();const s=await t.crypto.getClientId();return await t.storage.setItem(Im,s),t}get context(){return(0,Z.Fd)(this.logger)}async start(){this.initialized||await this.initialize()}async getLogsBlob(){var e;return(e=this.logChunkController)==null?void 0:e.logsToBlob({clientId:await this.crypto.getClientId()})}async addLinkModeSupportedApp(e){this.linkModeSupportedApps.includes(e)||(this.linkModeSupportedApps.push(e),await this.storage.setItem(ch,this.linkModeSupportedApps))}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.linkModeSupportedApps=await this.storage.getItem(ch)||[],this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}getGlobalCore(e=""){try{if(this.isGlobalCoreDisabled())return;const t=`_walletConnectCore_${e}`,s=`${t}_count`;return globalThis[s]=(globalThis[s]||0)+1,globalThis[s]>1&&console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[s]} times.`),globalThis[t]}catch(t){console.warn("Failed to get global WalletConnect core",t);return}}setGlobalCore(e){var t;try{if(this.isGlobalCoreDisabled())return;const s=`_walletConnectCore_${((t=e.opts)==null?void 0:t.customStoragePrefix)||""}`;globalThis[s]=e}catch(s){console.warn("Failed to set global WalletConnect core",s)}}isGlobalCoreDisabled(){try{return typeof hm<"u"&&{NODE_ENV:"production",PUBLIC_PATH:"/"}.DISABLE_GLOBAL_CORE==="true"}catch{return!0}}}const z0=Br,kh="wc",Mh=2,zh="client",Dr=`${kh}@${Mh}:${zh}:`,$r={name:zh,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"},nE={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire",session_connect:"session_connect"},rE={database:":memory:"},Hh="WALLETCONNECT_DEEPLINK_CHOICE",oE={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},aE="history",cE="0.3",H0="proposal",hE=null,Vh="Proposal expired",V0="session",Ni=D.SEVEN_DAYS,K0="engine",Pe={wc_sessionPropose:{req:{ttl:D.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:D.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:D.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:D.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:D.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:D.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:D.ONE_DAY,prompt:!1,tag:1104},res:{ttl:D.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:D.ONE_DAY,prompt:!1,tag:1106},res:{ttl:D.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:D.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:D.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:D.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:D.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:D.ONE_DAY,prompt:!1,tag:1112},res:{ttl:D.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:D.ONE_DAY,prompt:!1,tag:1114},res:{ttl:D.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:D.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:D.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:D.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:D.FIVE_MINUTES,prompt:!1,tag:1119}}},jr={min:D.FIVE_MINUTES,max:D.SEVEN_DAYS},bt={idle:"IDLE",active:"ACTIVE"},Kh={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"}},G0="request",W0=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],J0="wc",dE=1.5,Z0="auth",Y0="authKeys",Q0="pairingTopics",X0="requests",en=`${J0}@${1.5}:${Z0}:`,tn=`${en}:PUB_KEY`;var ev=Object.defineProperty,tv=Object.defineProperties,iv=Object.getOwnPropertyDescriptors,Gh=Object.getOwnPropertySymbols,sv=Object.prototype.hasOwnProperty,nv=Object.prototype.propertyIsEnumerable,qr=(i,e,t)=>e in i?ev(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,de=(i,e)=>{for(var t in e||(e={}))sv.call(e,t)&&qr(i,t,e[t]);if(Gh)for(var t of Gh(e))nv.call(e,t)&&qr(i,t,e[t]);return i},je=(i,e)=>tv(i,iv(e)),T=(i,e,t)=>qr(i,typeof e!="symbol"?e+"":e,t);class rv extends nm{constructor(e){super(e),T(this,"name",K0),T(this,"events",new(hn())),T(this,"initialized",!1),T(this,"requestQueue",{state:bt.idle,queue:[]}),T(this,"sessionRequestQueue",{state:bt.idle,queue:[]}),T(this,"requestQueueDelay",D.ONE_SECOND),T(this,"expectedPairingMethodMap",new Map),T(this,"recentlyDeletedMap",new Map),T(this,"recentlyDeletedLimit",200),T(this,"relayMessageCache",[]),T(this,"pendingSessions",new Map),T(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(Pe)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},(0,D.toMiliseconds)(this.requestQueueDelay)))}),T(this,"connect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const s=je(de({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(s);const{pairingTopic:r,requiredNamespaces:o,optionalNamespaces:a,sessionProperties:c,scopedProperties:h,relays:d}=s;let u=r,p,g=!1;try{if(u){const A=this.client.core.pairing.pairings.get(u);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),g=A.active}}catch(A){throw this.client.logger.error(`connect() -> pairing.get(${u}) failed`),A}if(!u||!g){const{topic:A,uri:C}=await this.client.core.pairing.create();u=A,p=C}if(!u){const{message:A}=$("NO_MATCHING_KEY",`connect() pairing topic: ${u}`);throw new Error(A)}const _=await this.client.core.crypto.generateKeyPair(),f=Pe.wc_sessionPropose.req.ttl||D.FIVE_MINUTES,y=we(f),m=je(de(de({requiredNamespaces:o,optionalNamespaces:a,relays:d??[{protocol:oh}],proposer:{publicKey:_,metadata:this.client.metadata},expiryTimestamp:y,pairingTopic:u},c&&{sessionProperties:c}),h&&{scopedProperties:h}),{id:(0,z.payloadId)()}),v=oe("session_connect",m.id),{reject:w,resolve:x,done:P}=Jt(f,Vh),R=({id:A})=>{A===m.id&&(this.client.events.off("proposal_expire",R),this.pendingSessions.delete(m.id),this.events.emit(v,{error:{message:Vh,code:0}}))};return this.client.events.on("proposal_expire",R),this.events.once(v,({error:A,session:C})=>{this.client.events.off("proposal_expire",R),A?w(A):C&&x(C)}),await this.sendRequest({topic:u,method:"wc_sessionPropose",params:m,throwOnFailedPublish:!0,clientRpcId:m.id}),await this.setProposal(m.id,m),{uri:p,approval:P}}),T(this,"pair",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(t)}catch(s){throw this.client.logger.error("pair() failed"),s}}),T(this,"approve",async t=>{var s,r,o;const a=this.client.core.eventClient.createEvent({properties:{topic:(s=t==null?void 0:t.id)==null?void 0:s.toString(),trace:[dt.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(S){throw a.setError(si.no_internet_connection),S}try{await this.isValidProposalId(t==null?void 0:t.id)}catch(S){throw this.client.logger.error(`approve() -> proposal.get(${t==null?void 0:t.id}) failed`),a.setError(si.proposal_not_found),S}try{await this.isValidApprove(t)}catch(S){throw this.client.logger.error("approve() -> isValidApprove() failed"),a.setError(si.session_approve_namespace_validation_failure),S}const{id:c,relayProtocol:h,namespaces:d,sessionProperties:u,scopedProperties:p,sessionConfig:g}=t,_=this.client.proposal.get(c);this.client.core.eventClient.deleteEvent({eventId:a.eventId});const{pairingTopic:f,proposer:y,requiredNamespaces:m,optionalNamespaces:v}=_;let w=(r=this.client.core.eventClient)==null?void 0:r.getEvent({topic:f});w||(w=(o=this.client.core.eventClient)==null?void 0:o.createEvent({type:dt.session_approve_started,properties:{topic:f,trace:[dt.session_approve_started,dt.session_namespaces_validation_success]}}));const x=await this.client.core.crypto.generateKeyPair(),P=y.publicKey,R=await this.client.core.crypto.generateSharedKey(x,P),A=de(de(de({relay:{protocol:h??"irn"},namespaces:d,controller:{publicKey:x,metadata:this.client.metadata},expiry:we(Ni)},u&&{sessionProperties:u}),p&&{scopedProperties:p}),g&&{sessionConfig:g}),C=pe.relay;w.addTrace(dt.subscribing_session_topic);try{await this.client.core.relayer.subscribe(R,{transportType:C})}catch(S){throw w.setError(si.subscribe_session_topic_failure),S}w.addTrace(dt.subscribe_session_topic_success);const B=je(de({},A),{topic:R,requiredNamespaces:m,optionalNamespaces:v,pairingTopic:f,acknowledged:!1,self:A.controller,peer:{publicKey:y.publicKey,metadata:y.metadata},controller:x,transportType:pe.relay});await this.client.session.set(R,B),w.addTrace(dt.store_session);try{w.addTrace(dt.publishing_session_settle),await this.sendRequest({topic:R,method:"wc_sessionSettle",params:A,throwOnFailedPublish:!0}).catch(S=>{throw w==null||w.setError(si.session_settle_publish_failure),S}),w.addTrace(dt.session_settle_publish_success),w.addTrace(dt.publishing_session_approve),await this.sendResult({id:c,topic:f,result:{relay:{protocol:h??"irn"},responderPublicKey:x},throwOnFailedPublish:!0}).catch(S=>{throw w==null||w.setError(si.session_approve_publish_failure),S}),w.addTrace(dt.session_approve_publish_success)}catch(S){throw this.client.logger.error(S),this.client.session.delete(R,ae("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(R),S}return this.client.core.eventClient.deleteEvent({eventId:w.eventId}),await this.client.core.pairing.updateMetadata({topic:f,metadata:y.metadata}),await this.client.proposal.delete(c,ae("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:f}),await this.setExpiry(R,we(Ni)),{topic:R,acknowledged:()=>Promise.resolve(this.client.session.get(R))}}),T(this,"reject",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(t)}catch(a){throw this.client.logger.error("reject() -> isValidReject() failed"),a}const{id:s,reason:r}=t;let o;try{o=this.client.proposal.get(s).pairingTopic}catch(a){throw this.client.logger.error(`reject() -> proposal.get(${s}) failed`),a}o&&(await this.sendError({id:s,topic:o,error:r,rpcOpts:Pe.wc_sessionPropose.reject}),await this.client.proposal.delete(s,ae("USER_DISCONNECTED")))}),T(this,"update",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(t)}catch(p){throw this.client.logger.error("update() -> isValidUpdate() failed"),p}const{topic:s,namespaces:r}=t,{done:o,resolve:a,reject:c}=Jt(),h=(0,z.payloadId)(),d=(0,z.getBigIntRpcId)().toString(),u=this.client.session.get(s).namespaces;return this.events.once(oe("session_update",h),({error:p})=>{p?c(p):a()}),await this.client.session.update(s,{namespaces:r}),await this.sendRequest({topic:s,method:"wc_sessionUpdate",params:{namespaces:r},throwOnFailedPublish:!0,clientRpcId:h,relayRpcId:d}).catch(p=>{this.client.logger.error(p),this.client.session.update(s,{namespaces:u}),c(p)}),{acknowledged:o}}),T(this,"extend",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(t)}catch(h){throw this.client.logger.error("extend() -> isValidExtend() failed"),h}const{topic:s}=t,r=(0,z.payloadId)(),{done:o,resolve:a,reject:c}=Jt();return this.events.once(oe("session_extend",r),({error:h})=>{h?c(h):a()}),await this.setExpiry(s,we(Ni)),this.sendRequest({topic:s,method:"wc_sessionExtend",params:{},clientRpcId:r,throwOnFailedPublish:!0}).catch(h=>{c(h)}),{acknowledged:o}}),T(this,"request",async t=>{this.isInitialized();try{await this.isValidRequest(t)}catch(v){throw this.client.logger.error("request() -> isValidRequest() failed"),v}const{chainId:s,request:r,topic:o,expiry:a=Pe.wc_sessionRequest.req.ttl}=t,c=this.client.session.get(o);(c==null?void 0:c.transportType)===pe.relay&&await this.confirmOnlineStateOrThrow();const h=(0,z.payloadId)(),d=(0,z.getBigIntRpcId)().toString(),{done:u,resolve:p,reject:g}=Jt(a,"Request expired. Please try again.");this.events.once(oe("session_request",h),({error:v,result:w})=>{v?g(v):p(w)});const _="wc_sessionRequest",f=this.getAppLinkIfEnabled(c.peer.metadata,c.transportType);if(f)return await this.sendRequest({clientRpcId:h,relayRpcId:d,topic:o,method:_,params:{request:je(de({},r),{expiryTimestamp:we(a)}),chainId:s},expiry:a,throwOnFailedPublish:!0,appLink:f}).catch(v=>g(v)),this.client.events.emit("session_request_sent",{topic:o,request:r,chainId:s,id:h}),await u();const y={request:je(de({},r),{expiryTimestamp:we(a)}),chainId:s},m=this.shouldSetTVF(_,y);return await Promise.all([new Promise(async v=>{await this.sendRequest(de({clientRpcId:h,relayRpcId:d,topic:o,method:_,params:y,expiry:a,throwOnFailedPublish:!0},m&&{tvf:this.getTVFParams(h,y)})).catch(w=>g(w)),this.client.events.emit("session_request_sent",{topic:o,request:r,chainId:s,id:h}),v()}),new Promise(async v=>{var w;if(!((w=c.sessionConfig)!=null&&w.disableDeepLink)){const x=await ag(this.client.core.storage,Hh);await ng({id:h,topic:o,wcDeepLink:x})}v()}),u()]).then(v=>v[2])}),T(this,"respond",async t=>{this.isInitialized(),await this.isValidRespond(t);const{topic:s,response:r}=t,{id:o}=r,a=this.client.session.get(s);a.transportType===pe.relay&&await this.confirmOnlineStateOrThrow();const c=this.getAppLinkIfEnabled(a.peer.metadata,a.transportType);(0,z.isJsonRpcResult)(r)?await this.sendResult({id:o,topic:s,result:r.result,throwOnFailedPublish:!0,appLink:c}):(0,z.isJsonRpcError)(r)&&await this.sendError({id:o,topic:s,error:r.error,appLink:c}),this.cleanupAfterResponse(t)}),T(this,"ping",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(t)}catch(r){throw this.client.logger.error("ping() -> isValidPing() failed"),r}const{topic:s}=t;if(this.client.session.keys.includes(s)){const r=(0,z.payloadId)(),o=(0,z.getBigIntRpcId)().toString(),{done:a,resolve:c,reject:h}=Jt();this.events.once(oe("session_ping",r),({error:d})=>{d?h(d):c()}),await Promise.all([this.sendRequest({topic:s,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:r,relayRpcId:o}),a()])}else this.client.core.pairing.pairings.keys.includes(s)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:s}))}),T(this,"emit",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(t);const{topic:s,event:r,chainId:o}=t,a=(0,z.getBigIntRpcId)().toString(),c=(0,z.payloadId)();await this.sendRequest({topic:s,method:"wc_sessionEvent",params:{event:r,chainId:o},throwOnFailedPublish:!0,relayRpcId:a,clientRpcId:c})}),T(this,"disconnect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(t);const{topic:s}=t;if(this.client.session.keys.includes(s))await this.sendRequest({topic:s,method:"wc_sessionDelete",params:ae("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:s,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(s))await this.client.core.pairing.disconnect({topic:s});else{const{message:r}=$("MISMATCHED_TOPIC",`Session or pairing topic not found: ${s}`);throw new Error(r)}}),T(this,"find",t=>(this.isInitialized(),this.client.session.getAll().filter(s=>Jy(s,t)))),T(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),T(this,"authenticate",async(t,s)=>{var r;this.isInitialized(),this.isValidAuthenticate(t);const o=s&&this.client.core.linkModeSupportedApps.includes(s)&&((r=this.client.metadata.redirect)==null?void 0:r.linkMode),a=o?pe.link_mode:pe.relay;a===pe.relay&&await this.confirmOnlineStateOrThrow();const{chains:c,statement:h="",uri:d,domain:u,nonce:p,type:g,exp:_,nbf:f,methods:y=[],expiry:m}=t,v=[...t.resources||[]],{topic:w,uri:x}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:a});this.client.logger.info({message:"Generated new pairing",pairing:{topic:w,uri:x}});const P=await this.client.core.crypto.generateKeyPair(),R=zs(P);if(await Promise.all([this.client.auth.authKeys.set(tn,{responseTopic:R,publicKey:P}),this.client.auth.pairingTopics.set(R,{topic:R,pairingTopic:w})]),await this.client.core.relayer.subscribe(R,{transportType:a}),this.client.logger.info(`sending request to new pairing topic: ${w}`),y.length>0){const{namespace:I}=Gt(c[0]);let j=Xg(I,"request",y);_i(v)&&(j=ef(j,v.pop())),v.push(j)}const A=m&&m>Pe.wc_sessionAuthenticate.req.ttl?m:Pe.wc_sessionAuthenticate.req.ttl,C={authPayload:{type:g??"caip122",chains:c,statement:h,aud:d,domain:u,version:"1",nonce:p,iat:new Date().toISOString(),exp:_,nbf:f,resources:v},requester:{publicKey:P,metadata:this.client.metadata},expiryTimestamp:we(A)},B={eip155:{chains:c,methods:[...new Set(["personal_sign",...y])],events:["chainChanged","accountsChanged"]}},S={requiredNamespaces:{},optionalNamespaces:B,relays:[{protocol:"irn"}],pairingTopic:w,proposer:{publicKey:P,metadata:this.client.metadata},expiryTimestamp:we(Pe.wc_sessionPropose.req.ttl),id:(0,z.payloadId)()},{done:H,resolve:U,reject:k}=Jt(A,"Request expired"),V=(0,z.payloadId)(),N=oe("session_connect",S.id),E=oe("session_request",V),b=async({error:I,session:j})=>{this.events.off(E,O),I?k(I):j&&U({session:j})},O=async I=>{var j,L,M;if(await this.deletePendingAuthRequest(V,{message:"fulfilled",code:0}),I.error){const ne=ae("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return I.error.code===ne.code?void 0:(this.events.off(N,b),k(I.error.message))}await this.deleteProposal(S.id),this.events.off(N,b);const{cacaos:K,responder:G}=I.result,J=[],X=[];for(const ne of K){await Ha({cacao:ne,projectId:this.client.core.projectId})||(this.client.logger.error(ne,"Signature verification failed"),k(ae("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:De}=ne,Te=_i(De.resources),qe=[Kn(De.iss)],tt=Ds(De.iss);if(Te){const it=Ja(Te),Gi=Za(Te);J.push(...it),qe.push(...Gi)}for(const it of qe)X.push(`${it}:${tt}`)}const ue=await this.client.core.crypto.generateSharedKey(P,G.publicKey);let ce;J.length>0&&(ce={topic:ue,acknowledged:!0,self:{publicKey:P,metadata:this.client.metadata},peer:G,controller:G.publicKey,expiry:we(Ni),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:w,namespaces:Hc([...new Set(J)],[...new Set(X)]),transportType:a},await this.client.core.relayer.subscribe(ue,{transportType:a}),await this.client.session.set(ue,ce),w&&await this.client.core.pairing.updateMetadata({topic:w,metadata:G.metadata}),ce=this.client.session.get(ue)),(j=this.client.metadata.redirect)!=null&&j.linkMode&&(L=G.metadata.redirect)!=null&&L.linkMode&&(M=G.metadata.redirect)!=null&&M.universal&&s&&(this.client.core.addLinkModeSupportedApp(G.metadata.redirect.universal),this.client.session.update(ue,{transportType:pe.link_mode})),U({auths:K,session:ce})};this.events.once(N,b),this.events.once(E,O);let F;try{if(o){const I=(0,z.formatJsonRpcRequest)("wc_sessionAuthenticate",C,V);this.client.core.history.set(w,I);const j=await this.client.core.crypto.encode("",I,{type:as,encoding:Mt});F=Vs(s,w,j)}else await Promise.all([this.sendRequest({topic:w,method:"wc_sessionAuthenticate",params:C,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:V}),this.sendRequest({topic:w,method:"wc_sessionPropose",params:S,expiry:Pe.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:S.id})])}catch(I){throw this.events.off(N,b),this.events.off(E,O),I}return await this.setProposal(S.id,S),await this.setAuthRequest(V,{request:je(de({},C),{verifyContext:{}}),pairingTopic:w,transportType:a}),{uri:F??x,response:H}}),T(this,"approveSessionAuthenticate",async t=>{const{id:s,auths:r}=t,o=this.client.core.eventClient.createEvent({properties:{topic:s.toString(),trace:[ni.authenticated_session_approve_started]}});try{this.isInitialized()}catch(m){throw o.setError(gs.no_internet_connection),m}const a=this.getPendingAuthRequest(s);if(!a)throw o.setError(gs.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${s}`);const c=a.transportType||pe.relay;c===pe.relay&&await this.confirmOnlineStateOrThrow();const h=a.requester.publicKey,d=await this.client.core.crypto.generateKeyPair(),u=zs(h),p={type:Rt,receiverPublicKey:h,senderPublicKey:d},g=[],_=[];for(const m of r){if(!await Ha({cacao:m,projectId:this.client.core.projectId})){o.setError(gs.invalid_cacao);const R=ae("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:s,topic:u,error:R,encodeOpts:p}),new Error(R.message)}o.addTrace(ni.cacaos_verified);const{p:v}=m,w=_i(v.resources),x=[Kn(v.iss)],P=Ds(v.iss);if(w){const R=Ja(w),A=Za(w);g.push(...R),x.push(...A)}for(const R of x)_.push(`${R}:${P}`)}const f=await this.client.core.crypto.generateSharedKey(d,h);o.addTrace(ni.create_authenticated_session_topic);let y;if((g==null?void 0:g.length)>0){y={topic:f,acknowledged:!0,self:{publicKey:d,metadata:this.client.metadata},peer:{publicKey:h,metadata:a.requester.metadata},controller:h,expiry:we(Ni),authentication:r,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:a.pairingTopic,namespaces:Hc([...new Set(g)],[...new Set(_)]),transportType:c},o.addTrace(ni.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(f,{transportType:c})}catch(m){throw o.setError(gs.subscribe_authenticated_session_topic_failure),m}o.addTrace(ni.subscribe_authenticated_session_topic_success),await this.client.session.set(f,y),o.addTrace(ni.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:a.pairingTopic,metadata:a.requester.metadata})}o.addTrace(ni.publishing_authenticated_session_approve);try{await this.sendResult({topic:u,id:s,result:{cacaos:r,responder:{publicKey:d,metadata:this.client.metadata}},encodeOpts:p,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(a.requester.metadata,c)})}catch(m){throw o.setError(gs.authenticated_session_approve_publish_failure),m}return await this.client.auth.requests.delete(s,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:a.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:o.eventId}),{session:y}}),T(this,"rejectSessionAuthenticate",async t=>{this.isInitialized();const{id:s,reason:r}=t,o=this.getPendingAuthRequest(s);if(!o)throw new Error(`Could not find pending auth request with id ${s}`);o.transportType===pe.relay&&await this.confirmOnlineStateOrThrow();const a=o.requester.publicKey,c=await this.client.core.crypto.generateKeyPair(),h=zs(a),d={type:Rt,receiverPublicKey:a,senderPublicKey:c};await this.sendError({id:s,topic:h,error:r,encodeOpts:d,rpcOpts:Pe.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(o.requester.metadata,o.transportType)}),await this.client.auth.requests.delete(s,{message:"rejected",code:0}),await this.client.proposal.delete(s,ae("USER_DISCONNECTED"))}),T(this,"formatAuthMessage",t=>{this.isInitialized();const{request:s,iss:r}=t;return Va(s,r)}),T(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)}),T(this,"cleanupDuplicatePairings",async t=>{if(t.pairingTopic)try{const s=this.client.core.pairing.pairings.get(t.pairingTopic),r=this.client.core.pairing.pairings.getAll().filter(o=>{var a,c;return((a=o.peerMetadata)==null?void 0:a.url)&&((c=o.peerMetadata)==null?void 0:c.url)===t.peer.metadata.url&&o.topic&&o.topic!==s.topic});if(r.length===0)return;this.client.logger.info(`Cleaning up ${r.length} duplicate pairing(s)`),await Promise.all(r.map(o=>this.client.core.pairing.disconnect({topic:o.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(s){this.client.logger.error(s)}}),T(this,"deleteSession",async t=>{var s;const{topic:r,expirerHasDeleted:o=!1,emitEvent:a=!0,id:c=0}=t,{self:h}=this.client.session.get(r);await this.client.core.relayer.unsubscribe(r),await this.client.session.delete(r,ae("USER_DISCONNECTED")),this.addToRecentlyDeleted(r,"session"),this.client.core.crypto.keychain.has(h.publicKey)&&await this.client.core.crypto.deleteKeyPair(h.publicKey),this.client.core.crypto.keychain.has(r)&&await this.client.core.crypto.deleteSymKey(r),o||this.client.core.expirer.del(r),this.client.core.storage.removeItem(Hh).catch(d=>this.client.logger.warn(d)),this.getPendingSessionRequests().forEach(d=>{d.topic===r&&this.deletePendingSessionRequest(d.id,ae("USER_DISCONNECTED"))}),r===((s=this.sessionRequestQueue.queue[0])==null?void 0:s.topic)&&(this.sessionRequestQueue.state=bt.idle),a&&this.client.events.emit("session_delete",{id:c,topic:r})}),T(this,"deleteProposal",async(t,s)=>{if(s)try{const r=this.client.proposal.get(t),o=this.client.core.eventClient.getEvent({topic:r.pairingTopic});o==null||o.setError(si.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,ae("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")}),T(this,"deletePendingSessionRequest",async(t,s,r=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,s),r?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(o=>o.id!==t),r&&(this.sessionRequestQueue.state=bt.idle,this.client.events.emit("session_request_expire",{id:t}))}),T(this,"deletePendingAuthRequest",async(t,s,r=!1)=>{await Promise.all([this.client.auth.requests.delete(t,s),r?Promise.resolve():this.client.core.expirer.del(t)])}),T(this,"setExpiry",async(t,s)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,s),await this.client.session.update(t,{expiry:s}))}),T(this,"setProposal",async(t,s)=>{this.client.core.expirer.set(t,we(Pe.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,s)}),T(this,"setAuthRequest",async(t,s)=>{const{request:r,pairingTopic:o,transportType:a=pe.relay}=s;this.client.core.expirer.set(t,r.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:r.authPayload,requester:r.requester,expiryTimestamp:r.expiryTimestamp,id:t,pairingTopic:o,verifyContext:r.verifyContext,transportType:a})}),T(this,"setPendingSessionRequest",async t=>{const{id:s,topic:r,params:o,verifyContext:a}=t,c=o.request.expiryTimestamp||we(Pe.wc_sessionRequest.req.ttl);this.client.core.expirer.set(s,c),await this.client.pendingRequest.set(s,{id:s,topic:r,params:o,verifyContext:a})}),T(this,"sendRequest",async t=>{const{topic:s,method:r,params:o,expiry:a,relayRpcId:c,clientRpcId:h,throwOnFailedPublish:d,appLink:u,tvf:p}=t,g=(0,z.formatJsonRpcRequest)(r,o,h);let _;const f=!!u;try{const v=f?Mt:at;_=await this.client.core.crypto.encode(s,g,{encoding:v})}catch(v){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${s} failed`),v}let y;if(W0.includes(r)){const v=yt(JSON.stringify(g)),w=yt(_);y=await this.client.core.verify.register({id:w,decryptedId:v})}const m=Pe[r].req;if(m.attestation=y,a&&(m.ttl=a),c&&(m.id=c),this.client.core.history.set(s,g),f){const v=Vs(u,s,_);await q.g.Linking.openURL(v,this.client.name)}else{const v=Pe[r].req;a&&(v.ttl=a),c&&(v.id=c),v.tvf=je(de({},p),{correlationId:g.id}),d?(v.internal=je(de({},v.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,_,v)):this.client.core.relayer.publish(s,_,v).catch(w=>this.client.logger.error(w))}return g.id}),T(this,"sendResult",async t=>{const{id:s,topic:r,result:o,throwOnFailedPublish:a,encodeOpts:c,appLink:h}=t,d=(0,z.formatJsonRpcResult)(s,o);let u;const p=h&&typeof(q.g==null?void 0:q.g.Linking)<"u";try{const f=p?Mt:at;u=await this.client.core.crypto.encode(r,d,je(de({},c||{}),{encoding:f}))}catch(f){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${r} failed`),f}let g,_;try{g=await this.client.core.history.get(r,s);const f=g.request;try{this.shouldSetTVF(f.method,f.params)&&(_=this.getTVFParams(s,f.params,o))}catch(y){this.client.logger.warn("sendResult() -> getTVFParams() failed",y)}}catch(f){throw this.client.logger.error(`sendResult() -> history.get(${r}, ${s}) failed`),f}if(p){const f=Vs(h,r,u);await q.g.Linking.openURL(f,this.client.name)}else{const f=g.request.method,y=Pe[f].res;y.tvf=je(de({},_),{correlationId:s}),a?(y.internal=je(de({},y.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(r,u,y)):this.client.core.relayer.publish(r,u,y).catch(m=>this.client.logger.error(m))}await this.client.core.history.resolve(d)}),T(this,"sendError",async t=>{const{id:s,topic:r,error:o,encodeOpts:a,rpcOpts:c,appLink:h}=t,d=(0,z.formatJsonRpcError)(s,o);let u;const p=h&&typeof(q.g==null?void 0:q.g.Linking)<"u";try{const _=p?Mt:at;u=await this.client.core.crypto.encode(r,d,je(de({},a||{}),{encoding:_}))}catch(_){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${r} failed`),_}let g;try{g=await this.client.core.history.get(r,s)}catch(_){throw this.client.logger.error(`sendError() -> history.get(${r}, ${s}) failed`),_}if(p){const _=Vs(h,r,u);await q.g.Linking.openURL(_,this.client.name)}else{const _=g.request.method,f=c||Pe[_].res;this.client.core.relayer.publish(r,u,f)}await this.client.core.history.resolve(d)}),T(this,"cleanup",async()=>{const t=[],s=[];this.client.session.getAll().forEach(r=>{let o=!1;jt(r.expiry)&&(o=!0),this.client.core.crypto.keychain.has(r.topic)||(o=!0),o&&t.push(r.topic)}),this.client.proposal.getAll().forEach(r=>{jt(r.expiryTimestamp)&&s.push(r.id)}),await Promise.all([...t.map(r=>this.deleteSession({topic:r})),...s.map(r=>this.deleteProposal(r))])}),T(this,"onProviderMessageEvent",async t=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(t):await this.onRelayMessage(t)}),T(this,"onRelayEventRequest",async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()}),T(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===bt.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=bt.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(s){this.client.logger.warn(s)}}this.requestQueue.state=bt.idle}),T(this,"processRequest",async t=>{const{topic:s,payload:r,attestation:o,transportType:a,encryptedId:c}=t,h=r.method;if(!this.shouldIgnorePairingRequest({topic:s,requestMethod:h}))switch(h){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:s,payload:r,attestation:o,encryptedId:c});case"wc_sessionSettle":return await this.onSessionSettleRequest(s,r);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(s,r);case"wc_sessionExtend":return await this.onSessionExtendRequest(s,r);case"wc_sessionPing":return await this.onSessionPingRequest(s,r);case"wc_sessionDelete":return await this.onSessionDeleteRequest(s,r);case"wc_sessionRequest":return await this.onSessionRequest({topic:s,payload:r,attestation:o,encryptedId:c,transportType:a});case"wc_sessionEvent":return await this.onSessionEventRequest(s,r);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:s,payload:r,attestation:o,encryptedId:c,transportType:a});default:return this.client.logger.info(`Unsupported request method ${h}`)}}),T(this,"onRelayEventResponse",async t=>{const{topic:s,payload:r,transportType:o}=t,a=(await this.client.core.history.get(s,r.id)).request.method;switch(a){case"wc_sessionPropose":return this.onSessionProposeResponse(s,r,o);case"wc_sessionSettle":return this.onSessionSettleResponse(s,r);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,r);case"wc_sessionExtend":return this.onSessionExtendResponse(s,r);case"wc_sessionPing":return this.onSessionPingResponse(s,r);case"wc_sessionRequest":return this.onSessionRequestResponse(s,r);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(s,r);default:return this.client.logger.info(`Unsupported response method ${a}`)}}),T(this,"onRelayEventUnknownPayload",t=>{const{topic:s}=t,{message:r}=$("MISSING_OR_INVALID",`Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);throw new Error(r)}),T(this,"shouldIgnorePairingRequest",t=>{const{topic:s,requestMethod:r}=t,o=this.expectedPairingMethodMap.get(s);return!o||o.includes(r)?!1:!!(o.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),T(this,"onSessionProposeRequest",async t=>{const{topic:s,payload:r,attestation:o,encryptedId:a}=t,{params:c,id:h}=r;try{const d=this.client.core.eventClient.getEvent({topic:s});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),d==null||d.setError(Ft.proposal_listener_not_found)),this.isValidConnect(de({},r.params));const u=c.expiryTimestamp||we(Pe.wc_sessionPropose.req.ttl),p=de({id:h,pairingTopic:s,expiryTimestamp:u},c);await this.setProposal(h,p);const g=await this.getVerifyContext({attestationId:o,hash:yt(JSON.stringify(r)),encryptedId:a,metadata:p.proposer.metadata});d==null||d.addTrace(mt.emit_session_proposal),this.client.events.emit("session_proposal",{id:h,params:p,verifyContext:g})}catch(d){await this.sendError({id:h,topic:s,error:d,rpcOpts:Pe.wc_sessionPropose.autoReject}),this.client.logger.error(d)}}),T(this,"onSessionProposeResponse",async(t,s,r)=>{const{id:o}=s;if((0,z.isJsonRpcResult)(s)){const{result:a}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:a});const c=this.client.proposal.get(o);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:c});const h=c.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:h});const d=a.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:d});const u=await this.client.core.crypto.generateSharedKey(h,d);this.pendingSessions.set(o,{sessionTopic:u,pairingTopic:t,proposalId:o,publicKey:h});const p=await this.client.core.relayer.subscribe(u,{transportType:r});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:p}),await this.client.core.pairing.activate({topic:t})}else if((0,z.isJsonRpcError)(s)){await this.client.proposal.delete(o,ae("USER_DISCONNECTED"));const a=oe("session_connect",o);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners, 954`);this.events.emit(a,{error:s.error})}}),T(this,"onSessionSettleRequest",async(t,s)=>{const{id:r,params:o}=s;try{this.isValidSessionSettleRequest(o);const{relay:a,controller:c,expiry:h,namespaces:d,sessionProperties:u,scopedProperties:p,sessionConfig:g}=s.params,_=[...this.pendingSessions.values()].find(m=>m.sessionTopic===t);if(!_)return this.client.logger.error(`Pending session not found for topic ${t}`);const f=this.client.proposal.get(_.proposalId),y=je(de(de(de({topic:t,relay:a,expiry:h,namespaces:d,acknowledged:!0,pairingTopic:_.pairingTopic,requiredNamespaces:f.requiredNamespaces,optionalNamespaces:f.optionalNamespaces,controller:c.publicKey,self:{publicKey:_.publicKey,metadata:this.client.metadata},peer:{publicKey:c.publicKey,metadata:c.metadata}},u&&{sessionProperties:u}),p&&{scopedProperties:p}),g&&{sessionConfig:g}),{transportType:pe.relay});await this.client.session.set(y.topic,y),await this.setExpiry(y.topic,y.expiry),await this.client.core.pairing.updateMetadata({topic:_.pairingTopic,metadata:y.peer.metadata}),this.client.events.emit("session_connect",{session:y}),this.events.emit(oe("session_connect",_.proposalId),{session:y}),this.pendingSessions.delete(_.proposalId),this.deleteProposal(_.proposalId,!1),this.cleanupDuplicatePairings(y),await this.sendResult({id:s.id,topic:t,result:!0,throwOnFailedPublish:!0})}catch(a){await this.sendError({id:r,topic:t,error:a}),this.client.logger.error(a)}}),T(this,"onSessionSettleResponse",async(t,s)=>{const{id:r}=s;(0,z.isJsonRpcResult)(s)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(oe("session_approve",r),{})):(0,z.isJsonRpcError)(s)&&(await this.client.session.delete(t,ae("USER_DISCONNECTED")),this.events.emit(oe("session_approve",r),{error:s.error}))}),T(this,"onSessionUpdateRequest",async(t,s)=>{const{params:r,id:o}=s;try{const a=`${t}_session_update`,c=ls.get(a);if(c&&this.isRequestOutOfSync(c,o)){this.client.logger.warn(`Discarding out of sync request - ${o}`),this.sendError({id:o,topic:t,error:ae("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(de({topic:t},r));try{ls.set(a,o),await this.client.session.update(t,{namespaces:r.namespaces}),await this.sendResult({id:o,topic:t,result:!0,throwOnFailedPublish:!0})}catch(h){throw ls.delete(a),h}this.client.events.emit("session_update",{id:o,topic:t,params:r})}catch(a){await this.sendError({id:o,topic:t,error:a}),this.client.logger.error(a)}}),T(this,"isRequestOutOfSync",(t,s)=>s.toString().slice(0,-3)<t.toString().slice(0,-3)),T(this,"onSessionUpdateResponse",(t,s)=>{const{id:r}=s,o=oe("session_update",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);(0,z.isJsonRpcResult)(s)?this.events.emit(oe("session_update",r),{}):(0,z.isJsonRpcError)(s)&&this.events.emit(oe("session_update",r),{error:s.error})}),T(this,"onSessionExtendRequest",async(t,s)=>{const{id:r}=s;try{this.isValidExtend({topic:t}),await this.setExpiry(t,we(Ni)),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:r,topic:t})}catch(o){await this.sendError({id:r,topic:t,error:o}),this.client.logger.error(o)}}),T(this,"onSessionExtendResponse",(t,s)=>{const{id:r}=s,o=oe("session_extend",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);(0,z.isJsonRpcResult)(s)?this.events.emit(oe("session_extend",r),{}):(0,z.isJsonRpcError)(s)&&this.events.emit(oe("session_extend",r),{error:s.error})}),T(this,"onSessionPingRequest",async(t,s)=>{const{id:r}=s;try{this.isValidPing({topic:t}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:r,topic:t})}catch(o){await this.sendError({id:r,topic:t,error:o}),this.client.logger.error(o)}}),T(this,"onSessionPingResponse",(t,s)=>{const{id:r}=s,o=oe("session_ping",r);setTimeout(()=>{if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners 2176`);(0,z.isJsonRpcResult)(s)?this.events.emit(oe("session_ping",r),{}):(0,z.isJsonRpcError)(s)&&this.events.emit(oe("session_ping",r),{error:s.error})},500)}),T(this,"onSessionDeleteRequest",async(t,s)=>{const{id:r}=s;try{this.isValidDisconnect({topic:t,reason:s.params}),Promise.all([new Promise(o=>{this.client.core.relayer.once(Ee.publish,async()=>{o(await this.deleteSession({topic:t,id:r}))})}),this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:ae("USER_DISCONNECTED")})]).catch(o=>this.client.logger.error(o))}catch(o){this.client.logger.error(o)}}),T(this,"onSessionRequest",async t=>{var s,r,o;const{topic:a,payload:c,attestation:h,encryptedId:d,transportType:u}=t,{id:p,params:g}=c;try{await this.isValidRequest(de({topic:a},g));const _=this.client.session.get(a),f=await this.getVerifyContext({attestationId:h,hash:yt(JSON.stringify((0,z.formatJsonRpcRequest)("wc_sessionRequest",g,p))),encryptedId:d,metadata:_.peer.metadata,transportType:u}),y={id:p,topic:a,params:g,verifyContext:f};await this.setPendingSessionRequest(y),u===pe.link_mode&&(s=_.peer.metadata.redirect)!=null&&s.universal&&this.client.core.addLinkModeSupportedApp((r=_.peer.metadata.redirect)==null?void 0:r.universal),(o=this.client.signConfig)!=null&&o.disableRequestQueue?this.emitSessionRequest(y):(this.addSessionRequestToSessionRequestQueue(y),this.processSessionRequestQueue())}catch(_){await this.sendError({id:p,topic:a,error:_}),this.client.logger.error(_)}}),T(this,"onSessionRequestResponse",(t,s)=>{const{id:r}=s,o=oe("session_request",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);(0,z.isJsonRpcResult)(s)?this.events.emit(oe("session_request",r),{result:s.result}):(0,z.isJsonRpcError)(s)&&this.events.emit(oe("session_request",r),{error:s.error})}),T(this,"onSessionEventRequest",async(t,s)=>{const{id:r,params:o}=s;try{const a=`${t}_session_event_${o.event.name}`,c=ls.get(a);if(c&&this.isRequestOutOfSync(c,r)){this.client.logger.info(`Discarding out of sync request - ${r}`);return}this.isValidEmit(de({topic:t},o)),this.client.events.emit("session_event",{id:r,topic:t,params:o}),ls.set(a,r)}catch(a){await this.sendError({id:r,topic:t,error:a}),this.client.logger.error(a)}}),T(this,"onSessionAuthenticateResponse",(t,s)=>{const{id:r}=s;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:s}),(0,z.isJsonRpcResult)(s)?this.events.emit(oe("session_request",r),{result:s.result}):(0,z.isJsonRpcError)(s)&&this.events.emit(oe("session_request",r),{error:s.error})}),T(this,"onSessionAuthenticateRequest",async t=>{var s;const{topic:r,payload:o,attestation:a,encryptedId:c,transportType:h}=t;try{const{requester:d,authPayload:u,expiryTimestamp:p}=o.params,g=await this.getVerifyContext({attestationId:a,hash:yt(JSON.stringify(o)),encryptedId:c,metadata:d.metadata,transportType:h}),_={requester:d,pairingTopic:r,id:o.id,authPayload:u,verifyContext:g,expiryTimestamp:p};await this.setAuthRequest(o.id,{request:_,pairingTopic:r,transportType:h}),h===pe.link_mode&&(s=d.metadata.redirect)!=null&&s.universal&&this.client.core.addLinkModeSupportedApp(d.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:r,params:o.params,id:o.id,verifyContext:g})}catch(d){this.client.logger.error(d);const u=o.params.requester.publicKey,p=await this.client.core.crypto.generateKeyPair(),g=this.getAppLinkIfEnabled(o.params.requester.metadata,h),_={type:Rt,receiverPublicKey:u,senderPublicKey:p};await this.sendError({id:o.id,topic:r,error:d,encodeOpts:_,rpcOpts:Pe.wc_sessionAuthenticate.autoReject,appLink:g})}}),T(this,"addSessionRequestToSessionRequestQueue",t=>{this.sessionRequestQueue.queue.push(t)}),T(this,"cleanupAfterResponse",t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=bt.idle,this.processSessionRequestQueue()},(0,D.toMiliseconds)(this.requestQueueDelay))}),T(this,"cleanupPendingSentRequestsForTopic",({topic:t,error:s})=>{const r=this.client.core.history.pending;r.length>0&&r.filter(o=>o.topic===t&&o.request.method==="wc_sessionRequest").forEach(o=>{const a=o.request.id,c=oe("session_request",a);if(this.events.listenerCount(c)===0)throw new Error(`emitting ${c} without any listeners`);this.events.emit(oe("session_request",o.request.id),{error:s})})}),T(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===bt.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=bt.active,this.emitSessionRequest(t)}catch(s){this.client.logger.error(s)}}),T(this,"emitSessionRequest",t=>{this.client.events.emit("session_request",t)}),T(this,"onPairingCreated",t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const s=this.client.proposal.getAll().find(r=>r.pairingTopic===t.topic);s&&this.onSessionProposeRequest({topic:t.topic,payload:(0,z.formatJsonRpcRequest)("wc_sessionPropose",je(de({},s),{requiredNamespaces:s.requiredNamespaces,optionalNamespaces:s.optionalNamespaces,relays:s.relays,proposer:s.proposer,sessionProperties:s.sessionProperties,scopedProperties:s.scopedProperties}),s.id)})}),T(this,"isValidConnect",async t=>{if(!Me(t)){const{message:d}=$("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(d)}const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:o,sessionProperties:a,scopedProperties:c,relays:h}=t;if(Ae(s)||await this.isValidPairingTopic(s),!a_(h,!0)){const{message:d}=$("MISSING_OR_INVALID",`connect() relays: ${h}`);throw new Error(d)}if(!Ae(r)&&Ai(r)!==0&&this.validateNamespaces(r,"requiredNamespaces"),!Ae(o)&&Ai(o)!==0&&this.validateNamespaces(o,"optionalNamespaces"),Ae(a)||this.validateSessionProps(a,"sessionProperties"),!Ae(c)){this.validateSessionProps(c,"scopedProperties");const d=Object.keys(r||{}).concat(Object.keys(o||{}));if(!Object.keys(c).every(u=>d.includes(u)))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(c)}, required/optional namespaces: ${JSON.stringify(d)}`)}}),T(this,"validateNamespaces",(t,s)=>{const r=o_(t,"connect()",s);if(r)throw new Error(r.message)}),T(this,"isValidApprove",async t=>{if(!Me(t))throw new Error($("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:s,namespaces:r,relayProtocol:o,sessionProperties:a,scopedProperties:c}=t;this.checkRecentlyDeleted(s),await this.isValidProposalId(s);const h=this.client.proposal.get(s),d=Ws(r,"approve()");if(d)throw new Error(d.message);const u=yr(h.requiredNamespaces,r,"approve()");if(u)throw new Error(u.message);if(!ye(o,!0)){const{message:p}=$("MISSING_OR_INVALID",`approve() relayProtocol: ${o}`);throw new Error(p)}if(Ae(a)||this.validateSessionProps(a,"sessionProperties"),!Ae(c)){this.validateSessionProps(c,"scopedProperties");const p=new Set(Object.keys(r));if(!Object.keys(c).every(g=>p.has(g)))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(c)}, approved namespaces: ${Array.from(p).join(", ")}`)}}),T(this,"isValidReject",async t=>{if(!Me(t)){const{message:o}=$("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(o)}const{id:s,reason:r}=t;if(this.checkRecentlyDeleted(s),await this.isValidProposalId(s),!h_(r)){const{message:o}=$("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(r)}`);throw new Error(o)}}),T(this,"isValidSessionSettleRequest",t=>{if(!Me(t)){const{message:d}=$("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(d)}const{relay:s,controller:r,namespaces:o,expiry:a}=t;if(!Gc(s)){const{message:d}=$("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(d)}const c=e_(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);const h=Ws(o,"onSessionSettleRequest()");if(h)throw new Error(h.message);if(jt(a)){const{message:d}=$("EXPIRED","onSessionSettleRequest()");throw new Error(d)}}),T(this,"isValidUpdate",async t=>{if(!Me(t)){const{message:h}=$("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(h)}const{topic:s,namespaces:r}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s);const o=this.client.session.get(s),a=Ws(r,"update()");if(a)throw new Error(a.message);const c=yr(o.requiredNamespaces,r,"update()");if(c)throw new Error(c.message)}),T(this,"isValidExtend",async t=>{if(!Me(t)){const{message:r}=$("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(r)}const{topic:s}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s)}),T(this,"isValidRequest",async t=>{if(!Me(t)){const{message:h}=$("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(h)}const{topic:s,request:r,chainId:o,expiry:a}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s);const{namespaces:c}=this.client.session.get(s);if(!Wc(c,o)){const{message:h}=$("MISSING_OR_INVALID",`request() chainId: ${o}`);throw new Error(h)}if(!d_(r)){const{message:h}=$("MISSING_OR_INVALID",`request() ${JSON.stringify(r)}`);throw new Error(h)}if(!p_(c,o,r.method)){const{message:h}=$("MISSING_OR_INVALID",`request() method: ${r.method}`);throw new Error(h)}if(a&&!__(a,jr)){const{message:h}=$("MISSING_OR_INVALID",`request() expiry: ${a}. Expiry must be a number (in seconds) between ${jr.min} and ${jr.max}`);throw new Error(h)}}),T(this,"isValidRespond",async t=>{var s;if(!Me(t)){const{message:a}=$("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(a)}const{topic:r,response:o}=t;try{await this.isValidSessionTopic(r)}catch(a){throw(s=t==null?void 0:t.response)!=null&&s.id&&this.cleanupAfterResponse(t),a}if(!l_(o)){const{message:a}=$("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(o)}`);throw new Error(a)}}),T(this,"isValidPing",async t=>{if(!Me(t)){const{message:r}=$("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(r)}const{topic:s}=t;await this.isValidSessionOrPairingTopic(s)}),T(this,"isValidEmit",async t=>{if(!Me(t)){const{message:c}=$("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(c)}const{topic:s,event:r,chainId:o}=t;await this.isValidSessionTopic(s);const{namespaces:a}=this.client.session.get(s);if(!Wc(a,o)){const{message:c}=$("MISSING_OR_INVALID",`emit() chainId: ${o}`);throw new Error(c)}if(!u_(r)){const{message:c}=$("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(r)}`);throw new Error(c)}if(!g_(a,o,r.name)){const{message:c}=$("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(r)}`);throw new Error(c)}}),T(this,"isValidDisconnect",async t=>{if(!Me(t)){const{message:r}=$("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(r)}const{topic:s}=t;await this.isValidSessionOrPairingTopic(s)}),T(this,"isValidAuthenticate",t=>{const{chains:s,uri:r,domain:o,nonce:a}=t;if(!Array.isArray(s)||s.length===0)throw new Error("chains is required and must be a non-empty array");if(!ye(r,!1))throw new Error("uri is required parameter");if(!ye(o,!1))throw new Error("domain is required parameter");if(!ye(a,!1))throw new Error("nonce is required parameter");if([...new Set(s.map(h=>Gt(h).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:c}=Gt(s[0]);if(c!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),T(this,"getVerifyContext",async t=>{const{attestationId:s,hash:r,encryptedId:o,metadata:a,transportType:c}=t,h={verified:{verifyUrl:a.verifyUrl||ps,validation:"UNKNOWN",origin:a.url||""}};try{if(c===pe.link_mode){const u=this.getAppLinkIfEnabled(a,c);return h.verified.validation=u&&new URL(u).origin===new URL(a.url).origin?"VALID":"INVALID",h}const d=await this.client.core.verify.resolve({attestationId:s,hash:r,encryptedId:o,verifyUrl:a.verifyUrl});d&&(h.verified.origin=d.origin,h.verified.isScam=d.isScam,h.verified.validation=d.origin===new URL(a.url).origin?"VALID":"INVALID")}catch(d){this.client.logger.warn(d)}return this.client.logger.debug(`Verify context: ${JSON.stringify(h)}`),h}),T(this,"validateSessionProps",(t,s)=>{Object.values(t).forEach((r,o)=>{if(r==null){const{message:a}=$("MISSING_OR_INVALID",`${s} must contain an existing value for each key. Received: ${r} for key ${Object.keys(t)[o]}`);throw new Error(a)}})}),T(this,"getPendingAuthRequest",t=>{const s=this.client.auth.requests.get(t);return typeof s=="object"?s:void 0}),T(this,"addToRecentlyDeleted",(t,s)=>{if(this.recentlyDeletedMap.set(t,s),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let r=0;const o=this.recentlyDeletedLimit/2;for(const a of this.recentlyDeletedMap.keys()){if(r++>=o)break;this.recentlyDeletedMap.delete(a)}}}),T(this,"checkRecentlyDeleted",t=>{const s=this.recentlyDeletedMap.get(t);if(s){const{message:r}=$("MISSING_OR_INVALID",`Record was recently deleted - ${s}: ${t}`);throw new Error(r)}}),T(this,"isLinkModeEnabled",(t,s)=>{var r,o,a,c,h,d,u,p,g;return!t||s!==pe.link_mode?!1:((o=(r=this.client.metadata)==null?void 0:r.redirect)==null?void 0:o.linkMode)===!0&&((c=(a=this.client.metadata)==null?void 0:a.redirect)==null?void 0:c.universal)!==void 0&&((d=(h=this.client.metadata)==null?void 0:h.redirect)==null?void 0:d.universal)!==""&&((u=t==null?void 0:t.redirect)==null?void 0:u.universal)!==void 0&&((p=t==null?void 0:t.redirect)==null?void 0:p.universal)!==""&&((g=t==null?void 0:t.redirect)==null?void 0:g.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(t.redirect.universal)&&typeof(q.g==null?void 0:q.g.Linking)<"u"}),T(this,"getAppLinkIfEnabled",(t,s)=>{var r;return this.isLinkModeEnabled(t,s)?(r=t==null?void 0:t.redirect)==null?void 0:r.universal:void 0}),T(this,"handleLinkModeMessage",({url:t})=>{if(!t||!t.includes("wc_ev")||!t.includes("topic"))return;const s=Oa(t,"topic")||"",r=decodeURIComponent(Oa(t,"wc_ev")||""),o=this.client.session.keys.includes(s);o&&this.client.session.update(s,{transportType:pe.link_mode}),this.client.core.dispatchEnvelope({topic:s,message:r,sessionExists:o})}),T(this,"registerLinkModeListeners",async()=>{var t;if(Un()||Dt()&&(t=this.client.metadata.redirect)!=null&&t.linkMode){const s=q.g==null?void 0:q.g.Linking;if(typeof s<"u"){s.addEventListener("url",this.handleLinkModeMessage,this.client.name);const r=await s.getInitialURL();r&&setTimeout(()=>{this.handleLinkModeMessage({url:r})},50)}}}),T(this,"shouldSetTVF",(t,s)=>{if(!s||t!=="wc_sessionRequest")return!1;const{request:r}=s;return Object.keys(Kh).includes(r.method)}),T(this,"getTVFParams",(t,s,r)=>{var o,a;try{const c=s.request.method,h=this.extractTxHashesFromResult(c,r);return je(de({correlationId:t,rpcMethods:[c],chainId:s.chainId},this.isValidContractData(s.request.params)&&{contractAddresses:[(a=(o=s.request.params)==null?void 0:o[0])==null?void 0:a.to]}),{txHashes:h})}catch(c){this.client.logger.warn("Error getting TVF params",c)}return{}}),T(this,"isValidContractData",t=>{var s;if(!t)return!1;try{const r=(t==null?void 0:t.data)||((s=t==null?void 0:t[0])==null?void 0:s.data);if(!r.startsWith("0x"))return!1;const o=r.slice(2);return/^[0-9a-fA-F]*$/.test(o)?o.length%2===0:!1}catch{}return!1}),T(this,"extractTxHashesFromResult",(t,s)=>{try{const r=Kh[t];if(typeof s=="string")return[s];const o=s[r.key];if(ct(o))return t==="solana_signAllTransactions"?o.map(a=>qg(a)):o;if(typeof o=="string")return[o]}catch(r){this.client.logger.warn("Error extracting tx hashes from result",r)}return[]})}async processPendingMessageEvents(){try{const e=this.client.session.keys,t=this.client.core.relayer.messages.getWithoutAck(e);for(const[s,r]of Object.entries(t))for(const o of r)try{await this.onProviderMessageEvent({topic:s,message:o,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${s}, message: ${o}`)}}catch(e){this.client.logger.warn("processPendingMessageEvents failed",e)}}isInitialized(){if(!this.initialized){const{message:e}=$("NOT_INITIALIZED",this.name);throw new Error(e)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(Ee.message,e=>{this.onProviderMessageEvent(e)})}async onRelayMessage(e){const{topic:t,message:s,attestation:r,transportType:o}=e,{publicKey:a}=this.client.auth.authKeys.keys.includes(tn)?this.client.auth.authKeys.get(tn):{responseTopic:void 0,publicKey:void 0};try{const c=await this.client.core.crypto.decode(t,s,{receiverPublicKey:a,encoding:o===pe.link_mode?Mt:at});(0,z.isJsonRpcRequest)(c)?(this.client.core.history.set(t,c),await this.onRelayEventRequest({topic:t,payload:c,attestation:r,transportType:o,encryptedId:yt(s)})):(0,z.isJsonRpcResponse)(c)?(await this.client.core.history.resolve(c),await this.onRelayEventResponse({topic:t,payload:c,transportType:o}),this.client.core.history.delete(t,c.id)):await this.onRelayEventUnknownPayload({topic:t,payload:c,transportType:o}),await this.client.core.relayer.messages.ack(t,s)}catch(c){this.client.logger.error(c)}}registerExpirerEvents(){this.client.core.expirer.on(Qe.expired,async e=>{const{topic:t,id:s}=Pa(e.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,$("EXPIRED"),!0);if(s&&this.client.auth.requests.keys.includes(s))return await this.deletePendingAuthRequest(s,$("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s}))})}registerPairingEvents(){this.client.core.pairing.events.on(ii.create,e=>this.onPairingCreated(e)),this.client.core.pairing.events.on(ii.delete,e=>{this.addToRecentlyDeleted(e.topic,"pairing")})}isValidPairingTopic(e){if(!ye(e,!1)){const{message:t}=$("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(e)){const{message:t}=$("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if(jt(this.client.core.pairing.pairings.get(e).expiry)){const{message:t}=$("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}}async isValidSessionTopic(e){if(!ye(e,!1)){const{message:t}=$("MISSING_OR_INVALID",`session topic should be a string: ${e}`);throw new Error(t)}if(this.checkRecentlyDeleted(e),!this.client.session.keys.includes(e)){const{message:t}=$("NO_MATCHING_KEY",`session topic doesn't exist: ${e}`);throw new Error(t)}if(jt(this.client.session.get(e).expiry)){await this.deleteSession({topic:e});const{message:t}=$("EXPIRED",`session topic: ${e}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(e)){const{message:t}=$("MISSING_OR_INVALID",`session topic does not exist in keychain: ${e}`);throw await this.deleteSession({topic:e}),new Error(t)}}async isValidSessionOrPairingTopic(e){if(this.checkRecentlyDeleted(e),this.client.session.keys.includes(e))await this.isValidSessionTopic(e);else if(this.client.core.pairing.pairings.keys.includes(e))this.isValidPairingTopic(e);else if(ye(e,!1)){const{message:t}=$("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${e}`);throw new Error(t)}else{const{message:t}=$("MISSING_OR_INVALID",`session or pairing topic should be a string: ${e}`);throw new Error(t)}}async isValidProposalId(e){if(!c_(e)){const{message:t}=$("MISSING_OR_INVALID",`proposal id should be a number: ${e}`);throw new Error(t)}if(!this.client.proposal.keys.includes(e)){const{message:t}=$("NO_MATCHING_KEY",`proposal id doesn't exist: ${e}`);throw new Error(t)}if(jt(this.client.proposal.get(e).expiryTimestamp)){await this.deleteProposal(e);const{message:t}=$("EXPIRED",`proposal id: ${e}`);throw new Error(t)}}}class ov extends ri{constructor(e,t){super(e,t,H0,Dr),this.core=e,this.logger=t}}class av extends ri{constructor(e,t){super(e,t,V0,Dr),this.core=e,this.logger=t}}class cv extends ri{constructor(e,t){super(e,t,G0,Dr,s=>s.id),this.core=e,this.logger=t}}class hv extends ri{constructor(e,t){super(e,t,Y0,en,()=>tn),this.core=e,this.logger=t}}class dv extends ri{constructor(e,t){super(e,t,Q0,en),this.core=e,this.logger=t}}class lv extends ri{constructor(e,t){super(e,t,X0,en,s=>s.id),this.core=e,this.logger=t}}var uv=Object.defineProperty,pv=(i,e,t)=>e in i?uv(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ur=(i,e,t)=>pv(i,typeof e!="symbol"?e+"":e,t);class gv{constructor(e,t){this.core=e,this.logger=t,Ur(this,"authKeys"),Ur(this,"pairingTopics"),Ur(this,"requests"),this.authKeys=new hv(this.core,this.logger),this.pairingTopics=new dv(this.core,this.logger),this.requests=new lv(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var fv=Object.defineProperty,yv=(i,e,t)=>e in i?fv(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Q=(i,e,t)=>yv(i,typeof e!="symbol"?e+"":e,t);class Lr extends sm{constructor(e){super(e),Q(this,"protocol",kh),Q(this,"version",Mh),Q(this,"name",$r.name),Q(this,"metadata"),Q(this,"core"),Q(this,"logger"),Q(this,"events",new pt.EventEmitter),Q(this,"engine"),Q(this,"session"),Q(this,"proposal"),Q(this,"pendingRequest"),Q(this,"auth"),Q(this,"signConfig"),Q(this,"on",(s,r)=>this.events.on(s,r)),Q(this,"once",(s,r)=>this.events.once(s,r)),Q(this,"off",(s,r)=>this.events.off(s,r)),Q(this,"removeListener",(s,r)=>this.events.removeListener(s,r)),Q(this,"removeAllListeners",s=>this.events.removeAllListeners(s)),Q(this,"connect",async s=>{try{return await this.engine.connect(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"pair",async s=>{try{return await this.engine.pair(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"approve",async s=>{try{return await this.engine.approve(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"reject",async s=>{try{return await this.engine.reject(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"update",async s=>{try{return await this.engine.update(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"extend",async s=>{try{return await this.engine.extend(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"request",async s=>{try{return await this.engine.request(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"respond",async s=>{try{return await this.engine.respond(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"ping",async s=>{try{return await this.engine.ping(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"emit",async s=>{try{return await this.engine.emit(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"disconnect",async s=>{try{return await this.engine.disconnect(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"find",s=>{try{return this.engine.find(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}}),Q(this,"authenticate",async(s,r)=>{try{return await this.engine.authenticate(s,r)}catch(o){throw this.logger.error(o.message),o}}),Q(this,"formatAuthMessage",s=>{try{return this.engine.formatAuthMessage(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"approveSessionAuthenticate",async s=>{try{return await this.engine.approveSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),Q(this,"rejectSessionAuthenticate",async s=>{try{return await this.engine.rejectSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),this.name=(e==null?void 0:e.name)||$r.name,this.metadata=Jp(e==null?void 0:e.metadata),this.signConfig=e==null?void 0:e.signConfig;const t=typeof(e==null?void 0:e.logger)<"u"&&typeof(e==null?void 0:e.logger)!="string"?e.logger:(0,Z.gw)((0,Z.jI)({level:(e==null?void 0:e.logger)||$r.logger}));this.core=(e==null?void 0:e.core)||new z0(e),this.logger=(0,Z.Ep)(t,this.name),this.session=new av(this.core,this.logger),this.proposal=new ov(this.core,this.logger),this.pendingRequest=new cv(this.core,this.logger),this.engine=new rv(this),this.auth=new gv(this.core,this.logger)}static async init(e){const t=new Lr(e);return await t.initialize(),t}get context(){return(0,Z.Fd)(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},(0,D.toMiliseconds)(D.ONE_SECOND))}catch(e){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(e.message),e}}}const lE=null,uE=null;var ut=q(55437),sn=q(55872).Buffer;const Wh="error",_v="wss://relay.walletconnect.org",mv="wc",wv="universal_provider",nn=`${mv}@2:${wv}:`,Jh="https://rpc.walletconnect.org/v1/",Ti="generic",bv=`${Jh}bundler`,Xe={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function vv(){}function kr(i){return i==null||typeof i!="object"&&typeof i!="function"}function Mr(i){return ArrayBuffer.isView(i)&&!(i instanceof DataView)}function xv(i){if(kr(i))return i;if(Array.isArray(i)||Mr(i)||i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer)return i.slice(0);const e=Object.getPrototypeOf(i),t=e.constructor;if(i instanceof Date||i instanceof Map||i instanceof Set)return new t(i);if(i instanceof RegExp){const s=new t(i);return s.lastIndex=i.lastIndex,s}if(i instanceof DataView)return new t(i.buffer.slice(0));if(i instanceof Error){const s=new t(i.message);return s.stack=i.stack,s.name=i.name,s.cause=i.cause,s}if(typeof File<"u"&&i instanceof File)return new t([i],i.name,{type:i.type,lastModified:i.lastModified});if(typeof i=="object"){const s=Object.create(e);return Object.assign(s,i)}return i}function Zh(i){return typeof i=="object"&&i!==null}function Yh(i){return Object.getOwnPropertySymbols(i).filter(e=>Object.prototype.propertyIsEnumerable.call(i,e))}function Qh(i){return i==null?i===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(i)}const Ev="[object RegExp]",Xh="[object String]",ed="[object Number]",td="[object Boolean]",id="[object Arguments]",Iv="[object Symbol]",Pv="[object Date]",Sv="[object Map]",Ov="[object Set]",Av="[object Array]",Cv="[object ArrayBuffer]",Rv="[object Object]",Fv="[object DataView]",Nv="[object Uint8Array]",Tv="[object Uint8ClampedArray]",Bv="[object Uint16Array]",Dv="[object Uint32Array]",$v="[object Int8Array]",jv="[object Int16Array]",qv="[object Int32Array]",Uv="[object Float32Array]",Lv="[object Float64Array]";function kv(i,e){return Bi(i,void 0,i,new Map,e)}function Bi(i,e,t,s=new Map,r=void 0){const o=r==null?void 0:r(i,e,t,s);if(o!=null)return o;if(kr(i))return i;if(s.has(i))return s.get(i);if(Array.isArray(i)){const a=new Array(i.length);s.set(i,a);for(let c=0;c<i.length;c++)a[c]=Bi(i[c],c,t,s,r);return Object.hasOwn(i,"index")&&(a.index=i.index),Object.hasOwn(i,"input")&&(a.input=i.input),a}if(i instanceof Date)return new Date(i.getTime());if(i instanceof RegExp){const a=new RegExp(i.source,i.flags);return a.lastIndex=i.lastIndex,a}if(i instanceof Map){const a=new Map;s.set(i,a);for(const[c,h]of i)a.set(c,Bi(h,c,t,s,r));return a}if(i instanceof Set){const a=new Set;s.set(i,a);for(const c of i)a.add(Bi(c,void 0,t,s,r));return a}if(typeof sn<"u"&&sn.isBuffer(i))return i.subarray();if(Mr(i)){const a=new(Object.getPrototypeOf(i)).constructor(i.length);s.set(i,a);for(let c=0;c<i.length;c++)a[c]=Bi(i[c],c,t,s,r);return a}if(i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer)return i.slice(0);if(i instanceof DataView){const a=new DataView(i.buffer.slice(0),i.byteOffset,i.byteLength);return s.set(i,a),oi(a,i,t,s,r),a}if(typeof File<"u"&&i instanceof File){const a=new File([i],i.name,{type:i.type});return s.set(i,a),oi(a,i,t,s,r),a}if(i instanceof Blob){const a=new Blob([i],{type:i.type});return s.set(i,a),oi(a,i,t,s,r),a}if(i instanceof Error){const a=new i.constructor;return s.set(i,a),a.message=i.message,a.name=i.name,a.stack=i.stack,a.cause=i.cause,oi(a,i,t,s,r),a}if(typeof i=="object"&&Mv(i)){const a=Object.create(Object.getPrototypeOf(i));return s.set(i,a),oi(a,i,t,s,r),a}return i}function oi(i,e,t=i,s,r){const o=[...Object.keys(e),...Yh(e)];for(let a=0;a<o.length;a++){const c=o[a],h=Object.getOwnPropertyDescriptor(i,c);(h==null||h.writable)&&(i[c]=Bi(e[c],c,t,s,r))}}function Mv(i){switch(Qh(i)){case id:case Av:case Cv:case Fv:case td:case Pv:case Uv:case Lv:case $v:case jv:case qv:case Sv:case ed:case Rv:case Ev:case Ov:case Xh:case Iv:case Nv:case Tv:case Bv:case Dv:return!0;default:return!1}}function zv(i,e){return kv(i,(t,s,r,o)=>{const a=e==null?void 0:e(t,s,r,o);if(a!=null)return a;if(typeof i=="object")switch(Object.prototype.toString.call(i)){case ed:case Xh:case td:{const c=new i.constructor(i==null?void 0:i.valueOf());return oi(c,i),c}case id:{const c={};return oi(c,i),c.length=i.length,c[Symbol.iterator]=i[Symbol.iterator],c}default:return}})}function sd(i){return zv(i)}function nd(i){return i!==null&&typeof i=="object"&&Qh(i)==="[object Arguments]"}function Hv(i){return Mr(i)}function Vv(i){var t;if(typeof i!="object"||i==null)return!1;if(Object.getPrototypeOf(i)===null)return!0;if(Object.prototype.toString.call(i)!=="[object Object]"){const s=i[Symbol.toStringTag];return s==null||!((t=Object.getOwnPropertyDescriptor(i,Symbol.toStringTag))!=null&&t.writable)?!1:i.toString()===`[object ${s}]`}let e=i;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(i)===e}function Kv(i,...e){const t=e.slice(0,-1),s=e[e.length-1];let r=i;for(let o=0;o<t.length;o++){const a=t[o];r=zr(r,a,s,new Map)}return r}function zr(i,e,t,s){if(kr(i)&&(i=Object(i)),e==null||typeof e!="object")return i;if(s.has(e))return xv(s.get(e));if(s.set(e,i),Array.isArray(e)){e=e.slice();for(let o=0;o<e.length;o++)e[o]=e[o]??void 0}const r=[...Object.keys(e),...Yh(e)];for(let o=0;o<r.length;o++){const a=r[o];let c=e[a],h=i[a];if(nd(c)&&(c={...c}),nd(h)&&(h={...h}),typeof sn<"u"&&sn.isBuffer(c)&&(c=sd(c)),Array.isArray(c))if(typeof h=="object"&&h!=null){const u=[],p=Reflect.ownKeys(h);for(let g=0;g<p.length;g++){const _=p[g];u[_]=h[_]}h=u}else h=[];const d=t(h,c,a,i,e,s);d!=null?i[a]=d:Array.isArray(c)||Zh(h)&&Zh(c)?i[a]=zr(h,c,t,s):h==null&&Vv(c)?i[a]=zr({},c,t,s):h==null&&Hv(c)?i[a]=sd(c):(h===void 0||c!==void 0)&&(i[a]=c)}return i}function Gv(i,...e){return Kv(i,...e,vv)}var Wv=Object.defineProperty,Jv=Object.defineProperties,Zv=Object.getOwnPropertyDescriptors,rd=Object.getOwnPropertySymbols,Yv=Object.prototype.hasOwnProperty,Qv=Object.prototype.propertyIsEnumerable,od=(i,e,t)=>e in i?Wv(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,rn=(i,e)=>{for(var t in e||(e={}))Yv.call(e,t)&&od(i,t,e[t]);if(rd)for(var t of rd(e))Qv.call(e,t)&&od(i,t,e[t]);return i},Xv=(i,e)=>Jv(i,Zv(e));function We(i,e,t){var s;const r=Gt(i);return((s=e.rpcMap)==null?void 0:s[r.reference])||`${Jh}?chainId=${r.namespace}:${r.reference}&projectId=${t}`}function ai(i){return i.includes(":")?i.split(":")[1]:i}function ad(i){return i.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}function e1(i,e){const t=Object.keys(e.namespaces).filter(r=>r.includes(i));if(!t.length)return[];const s=[];return t.forEach(r=>{const o=e.namespaces[r].accounts;s.push(...o)}),s}function Hr(i={},e={}){const t=cd(i),s=cd(e);return Gv(t,s)}function cd(i){var e,t,s,r;const o={};if(!Ai(i))return o;for(const[a,c]of Object.entries(i)){const h=Ks(a)?[a]:c.chains,d=c.methods||[],u=c.events||[],p=c.rpcMap||{},g=Oi(a);o[g]=Xv(rn(rn({},o[g]),c),{chains:rt(h,(e=o[g])==null?void 0:e.chains),methods:rt(d,(t=o[g])==null?void 0:t.methods),events:rt(u,(s=o[g])==null?void 0:s.events),rpcMap:rn(rn({},p),(r=o[g])==null?void 0:r.rpcMap)})}return o}function hd(i){return i.includes(":")?i.split(":")[2]:i}function dd(i){const e={};for(const[t,s]of Object.entries(i)){const r=s.methods||[],o=s.events||[],a=s.accounts||[],c=Ks(t)?[t]:s.chains?s.chains:ad(s.accounts);e[t]={chains:c,methods:r,events:o,accounts:a}}return e}function Vr(i){return typeof i=="number"?i:i.includes("0x")?parseInt(i,16):(i=i.includes(":")?i.split(":")[1]:i,isNaN(Number(i))?i:Number(i))}const ld={},se=i=>ld[i],Kr=(i,e)=>{ld[i]=e};var t1=Object.defineProperty,i1=(i,e,t)=>e in i?t1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Di=(i,e,t)=>i1(i,typeof e!="symbol"?e+"":e,t);class s1{constructor(e){Di(this,"name","polkadot"),Di(this,"client"),Di(this,"httpProviders"),Di(this,"events"),Di(this,"namespace"),Di(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ai(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||We(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Ze.r(new ut.Z(s,se("disableProviderPing")))}}var n1=Object.defineProperty,r1=Object.defineProperties,o1=Object.getOwnPropertyDescriptors,ud=Object.getOwnPropertySymbols,a1=Object.prototype.hasOwnProperty,c1=Object.prototype.propertyIsEnumerable,Gr=(i,e,t)=>e in i?n1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,pd=(i,e)=>{for(var t in e||(e={}))a1.call(e,t)&&Gr(i,t,e[t]);if(ud)for(var t of ud(e))c1.call(e,t)&&Gr(i,t,e[t]);return i},gd=(i,e)=>r1(i,o1(e)),$i=(i,e,t)=>Gr(i,typeof e!="symbol"?e+"":e,t);class h1{constructor(e){$i(this,"name","eip155"),$i(this,"client"),$i(this,"chainId"),$i(this,"namespace"),$i(this,"httpProviders"),$i(this,"events"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(parseInt(e),t),this.chainId=parseInt(e),this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,t){const s=t||We(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Ze.r(new ut.k(s,se("disableProviderPing")))}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=parseInt(ai(t));e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}getHttpProvider(){const e=this.chainId,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}async handleSwitchChain(e){var t,s;let r=e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:"0x0";r=r.startsWith("0x")?r:`0x${r}`;const o=parseInt(r,16);if(this.isChainApproved(o))this.setDefaultChain(`${o}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:r}]},chainId:(s=this.namespace.chains)==null?void 0:s[0]}),this.setDefaultChain(`${o}`);else throw new Error(`Failed to switch to chain 'eip155:${o}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var t,s,r;const o=(s=(t=e.request)==null?void 0:t.params)==null?void 0:s[0];if(!o)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const a=this.client.session.get(e.topic),c=((r=a==null?void 0:a.sessionProperties)==null?void 0:r.capabilities)||{};if(c!=null&&c[o])return c==null?void 0:c[o];const h=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:gd(pd({},a.sessionProperties||{}),{capabilities:gd(pd({},c||{}),{[o]:h})})})}catch(d){console.warn("Failed to update session with capabilities",d)}return h}async getCallStatus(e){var t,s;const r=this.client.session.get(e.topic),o=(t=r.sessionProperties)==null?void 0:t.bundler_name;if(o){const c=this.getBundlerUrl(e.chainId,o);try{return await this.getUserOperationReceipt(c,e)}catch(h){console.warn("Failed to fetch call status from bundler",h,c)}}const a=(s=r.sessionProperties)==null?void 0:s.bundler_url;if(a)try{return await this.getUserOperationReceipt(a,e)}catch(c){console.warn("Failed to fetch call status from custom bundler",c,a)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,t){var s;const r=new URL(e),o=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify((0,z.formatJsonRpcRequest)("eth_getUserOperationReceipt",[(s=t.request.params)==null?void 0:s[0]]))});if(!o.ok)throw new Error(`Failed to fetch user operation receipt - ${o.status}`);return await o.json()}getBundlerUrl(e,t){return`${bv}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`}}var d1=Object.defineProperty,l1=(i,e,t)=>e in i?d1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ji=(i,e,t)=>l1(i,typeof e!="symbol"?e+"":e,t);class u1{constructor(e){ji(this,"name","solana"),ji(this,"client"),ji(this,"httpProviders"),ji(this,"events"),ji(this,"namespace"),ji(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ai(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||We(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Ze.r(new ut.Z(s,se("disableProviderPing")))}}var p1=Object.defineProperty,g1=(i,e,t)=>e in i?p1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,qi=(i,e,t)=>g1(i,typeof e!="symbol"?e+"":e,t);class f1{constructor(e){qi(this,"name","cosmos"),qi(this,"client"),qi(this,"httpProviders"),qi(this,"events"),qi(this,"namespace"),qi(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ai(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||We(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Ze.r(new ut.Z(s,se("disableProviderPing")))}}var y1=Object.defineProperty,_1=(i,e,t)=>e in i?y1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ui=(i,e,t)=>_1(i,typeof e!="symbol"?e+"":e,t);class m1{constructor(e){Ui(this,"name","algorand"),Ui(this,"client"),Ui(this,"httpProviders"),Ui(this,"events"),Ui(this,"namespace"),Ui(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(!this.httpProviders[e]){const s=t||We(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.chainId=e,this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;e[t]=this.createHttpProvider(t,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||We(e,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new Ze.r(new ut.Z(s,se("disableProviderPing")))}}var w1=Object.defineProperty,b1=(i,e,t)=>e in i?w1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Li=(i,e,t)=>b1(i,typeof e!="symbol"?e+"":e,t);class v1{constructor(e){Li(this,"name","cip34"),Li(this,"client"),Li(this,"httpProviders"),Li(this,"events"),Li(this,"namespace"),Li(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{const s=this.getCardanoRPCUrl(t),r=ai(t);e[r]=this.createHttpProvider(r,s)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}getCardanoRPCUrl(e){const t=this.namespace.rpcMap;if(t)return t[e]}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||this.getCardanoRPCUrl(e);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Ze.r(new ut.Z(s,se("disableProviderPing")))}}var x1=Object.defineProperty,E1=(i,e,t)=>e in i?x1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ki=(i,e,t)=>E1(i,typeof e!="symbol"?e+"":e,t);class I1{constructor(e){ki(this,"name","elrond"),ki(this,"client"),ki(this,"httpProviders"),ki(this,"events"),ki(this,"namespace"),ki(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ai(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||We(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Ze.r(new ut.Z(s,se("disableProviderPing")))}}var P1=Object.defineProperty,S1=(i,e,t)=>e in i?P1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Mi=(i,e,t)=>S1(i,typeof e!="symbol"?e+"":e,t);class O1{constructor(e){Mi(this,"name","multiversx"),Mi(this,"client"),Mi(this,"httpProviders"),Mi(this,"events"),Mi(this,"namespace"),Mi(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=ai(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||We(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Ze.r(new ut.Z(s,se("disableProviderPing")))}}var A1=Object.defineProperty,C1=(i,e,t)=>e in i?A1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,zi=(i,e,t)=>C1(i,typeof e!="symbol"?e+"":e,t);class R1{constructor(e){zi(this,"name","near"),zi(this,"client"),zi(this,"httpProviders"),zi(this,"events"),zi(this,"namespace"),zi(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||We(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;e[t]=this.createHttpProvider(t,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||We(e,this.namespace);return typeof s>"u"?void 0:new Ze.r(new ut.Z(s,se("disableProviderPing")))}}var F1=Object.defineProperty,N1=(i,e,t)=>e in i?F1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Hi=(i,e,t)=>N1(i,typeof e!="symbol"?e+"":e,t);class T1{constructor(e){Hi(this,"name","tezos"),Hi(this,"client"),Hi(this,"httpProviders"),Hi(this,"events"),Hi(this,"namespace"),Hi(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||We(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||We(e,this.namespace);return typeof s>"u"?void 0:new Ze.r(new ut.Z(s))}}var B1=Object.defineProperty,D1=(i,e,t)=>e in i?B1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Vi=(i,e,t)=>D1(i,typeof e!="symbol"?e+"":e,t);class $1{constructor(e){Vi(this,"name",Ti),Vi(this,"client"),Vi(this,"httpProviders"),Vi(this,"events"),Vi(this,"namespace"),Vi(this,"chainId"),this.namespace=e.namespace,this.events=se("events"),this.client=se("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(Xe.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){var e,t;const s={};return(t=(e=this.namespace)==null?void 0:e.accounts)==null||t.forEach(r=>{const o=Gt(r);s[`${o.namespace}:${o.reference}`]=this.createHttpProvider(r)}),s}getHttpProvider(e){const t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||We(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Ze.r(new ut.Z(s,se("disableProviderPing")))}}var j1=Object.defineProperty,q1=Object.defineProperties,U1=Object.getOwnPropertyDescriptors,fd=Object.getOwnPropertySymbols,L1=Object.prototype.hasOwnProperty,k1=Object.prototype.propertyIsEnumerable,Wr=(i,e,t)=>e in i?j1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,on=(i,e)=>{for(var t in e||(e={}))L1.call(e,t)&&Wr(i,t,e[t]);if(fd)for(var t of fd(e))k1.call(e,t)&&Wr(i,t,e[t]);return i},Jr=(i,e)=>q1(i,U1(e)),et=(i,e,t)=>Wr(i,typeof e!="symbol"?e+"":e,t);class Zr{constructor(e){et(this,"client"),et(this,"namespaces"),et(this,"optionalNamespaces"),et(this,"sessionProperties"),et(this,"scopedProperties"),et(this,"events",new(hn())),et(this,"rpcProviders",{}),et(this,"session"),et(this,"providerOpts"),et(this,"logger"),et(this,"uri"),et(this,"disableProviderPing",!1),this.providerOpts=e,this.logger=typeof(e==null?void 0:e.logger)<"u"&&typeof(e==null?void 0:e.logger)!="string"?e.logger:(0,Z.gw)((0,Z.jI)({level:(e==null?void 0:e.logger)||Wh})),this.disableProviderPing=(e==null?void 0:e.disableProviderPing)||!1}static async init(e){const t=new Zr(e);return await t.initialize(),t}async request(e,t,s){const[r,o]=this.validateChain(t);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(r).request({request:on({},e),chainId:`${r}:${o}`,topic:this.session.topic,expiry:s})}sendAsync(e,t,s,r){const o=new Date().getTime();this.request(e,s,r).then(a=>t(null,(0,z.formatJsonRpcResult)(o,a))).catch(a=>t(a,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:ae("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(e),await this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}async authenticate(e,t){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(e),await this.cleanupPendingPairings();const{uri:s,response:r}=await this.client.authenticate(e,t);s&&(this.uri=s,this.events.emit("display_uri",s));const o=await r();if(this.session=o.session,this.session){const a=dd(this.session.namespaces);this.namespaces=Hr(this.namespaces,a),await this.persist("namespaces",this.namespaces),this.onConnect()}return o}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}removeListener(e,t){this.events.removeListener(e,t)}off(e,t){this.events.off(e,t)}get isWalletConnect(){return!0}async pair(e){const{uri:t,approval:s}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});t&&(this.uri=t,this.events.emit("display_uri",t));const r=await s();this.session=r;const o=dd(r.namespaces);return this.namespaces=Hr(this.namespaces,o),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(e,t){try{if(!this.session)return;const[s,r]=this.validateChain(e),o=this.getProvider(s);o.name===Ti?o.setDefaultChain(`${s}:${r}`,t):o.setDefaultChain(r,t)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(e={}){this.logger.info("Cleaning up inactive pairings...");const t=this.client.pairing.getAll();if(ct(t)){for(const s of t)e.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${t.length}`)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var e,t;if(this.client=this.providerOpts.client||await Lr.init({core:this.providerOpts.core,logger:this.providerOpts.logger||Wh,relayUrl:this.providerOpts.relayUrl||_v,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(s){throw this.logger.error("Failed to get session",s),new Error(`The provided session: ${(t=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:t.topic} doesn't exist in the Sign client`)}else{const s=this.client.session.getAll();this.session=s[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const e=[...new Set(Object.keys(this.session.namespaces).map(t=>Oi(t)))];Kr("client",this.client),Kr("events",this.events),Kr("disableProviderPing",this.disableProviderPing),e.forEach(t=>{if(!this.session)return;const s=e1(t,this.session),r=ad(s),o=Hr(this.namespaces,this.optionalNamespaces),a=Jr(on({},o[t]),{accounts:s,chains:r});switch(t){case"eip155":this.rpcProviders[t]=new h1({namespace:a});break;case"algorand":this.rpcProviders[t]=new m1({namespace:a});break;case"solana":this.rpcProviders[t]=new u1({namespace:a});break;case"cosmos":this.rpcProviders[t]=new f1({namespace:a});break;case"polkadot":this.rpcProviders[t]=new s1({namespace:a});break;case"cip34":this.rpcProviders[t]=new v1({namespace:a});break;case"elrond":this.rpcProviders[t]=new I1({namespace:a});break;case"multiversx":this.rpcProviders[t]=new O1({namespace:a});break;case"near":this.rpcProviders[t]=new R1({namespace:a});break;case"tezos":this.rpcProviders[t]=new T1({namespace:a});break;default:this.rpcProviders[Ti]?this.rpcProviders[Ti].updateNamespace(a):this.rpcProviders[Ti]=new $1({namespace:a})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{var t;const{topic:s}=e;s===((t=this.session)==null?void 0:t.topic)&&this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{var t;const{params:s,topic:r}=e;if(r!==((t=this.session)==null?void 0:t.topic))return;const{event:o}=s;if(o.name==="accountsChanged"){const a=o.data;a&&ct(a)&&this.events.emit("accountsChanged",a.map(hd))}else if(o.name==="chainChanged"){const a=s.chainId,c=s.event.data,h=Oi(a),d=Vr(a)!==Vr(c)?`${h}:${Vr(c)}`:a;this.onChainChanged(d)}else this.events.emit(o.name,o.data);this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:t})=>{var s,r;if(e!==((s=this.session)==null?void 0:s.topic))return;const{namespaces:o}=t,a=(r=this.client)==null?void 0:r.session.get(e);this.session=Jr(on({},a),{namespaces:o}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:t})}),this.client.on("session_delete",async e=>{var t;e.topic===((t=this.session)==null?void 0:t.topic)&&(await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",Jr(on({},ae("USER_DISCONNECTED")),{data:e.topic})))}),this.on(Xe.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(e,!0)})}getProvider(e){return this.rpcProviders[e]||this.rpcProviders[Ti]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var t;this.getProvider(e).updateNamespace((t=this.session)==null?void 0:t.namespaces[e])})}setNamespaces(e){const{namespaces:t,optionalNamespaces:s,sessionProperties:r,scopedProperties:o}=e;t&&Object.keys(t).length&&(this.namespaces=t),s&&Object.keys(s).length&&(this.optionalNamespaces=s),this.sessionProperties=r,this.scopedProperties=o}validateChain(e){const[t,s]=(e==null?void 0:e.split(":"))||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[t,s];if(t&&!Object.keys(this.namespaces||{}).map(a=>Oi(a)).includes(t))throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);if(t&&s)return[t,s];const r=Oi(Object.keys(this.namespaces)[0]),o=this.rpcProviders[r].getDefaultChain();return[r,o]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}async onChainChanged(e,t=!1){if(!this.namespaces)return;const[s,r]=this.validateChain(e);if(!r)return;this.updateNamespaceChain(s,r),this.events.emit("chainChanged",r);const o=this.getProvider(s).getDefaultChain();t||this.getProvider(s).setDefaultChain(r),this.emitAccountsChangedOnChainChange({namespace:s,previousChainId:o,newChainId:e}),await this.persist("namespaces",this.namespaces)}emitAccountsChangedOnChainChange({namespace:e,previousChainId:t,newChainId:s}){var r,o;try{if(t===s)return;const a=(o=(r=this.session)==null?void 0:r.namespaces[e])==null?void 0:o.accounts;if(!a)return;const c=a.filter(h=>h.includes(`${s}:`)).map(hd);if(!ct(c))return;this.events.emit("accountsChanged",c)}catch(a){this.logger.warn("Failed to emit accountsChanged on chain change",a)}}updateNamespaceChain(e,t){if(!this.namespaces)return;const s=this.namespaces[e]?e:`${e}:${t}`,r={chains:[],methods:[],events:[],defaultChain:t};this.namespaces[s]?this.namespaces[s]&&(this.namespaces[s].defaultChain=t):this.namespaces[s]=r}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(e,t){var s;const r=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.setItem(`${nn}/${e}${r}`,t)}async getFromStore(e){var t;const s=((t=this.session)==null?void 0:t.topic)||"";return await this.client.core.storage.getItem(`${nn}/${e}${s}`)}async deleteFromStore(e){var t;const s=((t=this.session)==null?void 0:t.topic)||"";await this.client.core.storage.removeItem(`${nn}/${e}${s}`)}async cleanupStorage(){var e;try{if(((e=this.client)==null?void 0:e.session.length)>0)return;const t=await this.client.core.storage.getKeys();for(const s of t)s.startsWith(nn)&&await this.client.core.storage.removeItem(s)}catch(t){this.logger.warn("Failed to cleanup storage",t)}}}const M1=Zr,z1="wc",H1="ethereum_provider",V1=`${z1}@2:${H1}:`,K1="https://rpc.walletconnect.org/v1/",Yr=["eth_sendTransaction","personal_sign"],G1=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_sendCalls","wallet_getCapabilities","wallet_getCallsStatus","wallet_showCallsStatus"],Qr=["chainChanged","accountsChanged"],W1=["chainChanged","accountsChanged","message","disconnect","connect"];var J1=Object.defineProperty,Z1=Object.defineProperties,Y1=Object.getOwnPropertyDescriptors,yd=Object.getOwnPropertySymbols,Q1=Object.prototype.hasOwnProperty,X1=Object.prototype.propertyIsEnumerable,Xr=(i,e,t)=>e in i?J1(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ki=(i,e)=>{for(var t in e||(e={}))Q1.call(e,t)&&Xr(i,t,e[t]);if(yd)for(var t of yd(e))X1.call(e,t)&&Xr(i,t,e[t]);return i},eo=(i,e)=>Z1(i,Y1(e)),Je=(i,e,t)=>Xr(i,typeof e!="symbol"?e+"":e,t);function an(i){return Number(i[0].split(":")[1])}function cn(i){return`0x${i.toString(16)}`}function ex(i){const{chains:e,optionalChains:t,methods:s,optionalMethods:r,events:o,optionalEvents:a,rpcMap:c}=i;if(!ct(e))throw new Error("Invalid chains");const h={chains:e,methods:s||Yr,events:o||Qr,rpcMap:Ki({},e.length?{[an(e)]:c[an(e)]}:{})},d=o==null?void 0:o.filter(_=>!Qr.includes(_)),u=s==null?void 0:s.filter(_=>!Yr.includes(_));if(!t&&!a&&!r&&!(d!=null&&d.length)&&!(u!=null&&u.length))return{required:e.length?h:void 0};const p=(d==null?void 0:d.length)&&(u==null?void 0:u.length)||!t,g={chains:[...new Set(p?h.chains.concat(t||[]):t)],methods:[...new Set(h.methods.concat(r!=null&&r.length?r:G1))],events:[...new Set(h.events.concat(a!=null&&a.length?a:W1))],rpcMap:c};return{required:e.length?h:void 0,optional:t.length?g:void 0}}class to{constructor(){Je(this,"events",new pt.EventEmitter),Je(this,"namespace","eip155"),Je(this,"accounts",[]),Je(this,"signer"),Je(this,"chainId",1),Je(this,"modal"),Je(this,"rpc"),Je(this,"STORAGE_KEY",V1),Je(this,"on",(e,t)=>(this.events.on(e,t),this)),Je(this,"once",(e,t)=>(this.events.once(e,t),this)),Je(this,"removeListener",(e,t)=>(this.events.removeListener(e,t),this)),Je(this,"off",(e,t)=>(this.events.off(e,t),this)),Je(this,"parseAccount",e=>this.isCompatibleChainId(e)?this.parseAccountId(e).address:e),this.signer={},this.rpc={}}static async init(e){const t=new to;return await t.initialize(e),t}async request(e,t){return await this.signer.request(e,this.formatChainId(this.chainId),t)}sendAsync(e,t,s){this.signer.sendAsync(e,t,this.formatChainId(this.chainId),s)}get connected(){return this.signer.client?this.signer.client.core.relayer.connected:!1}get connecting(){return this.signer.client?this.signer.client.core.relayer.connecting:!1}async enable(){return this.session||await this.connect(),await this.request({method:"eth_requestAccounts"})}async connect(e){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts(e);const{required:t,optional:s}=ex(this.rpc);try{const r=await new Promise(async(a,c)=>{var h;this.rpc.showQrModal&&((h=this.modal)==null||h.subscribeModal(u=>{!u.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),c(new Error("Connection request reset. Please try again.")))}));const d=e!=null&&e.scopedProperties?{[this.namespace]:e.scopedProperties}:void 0;await this.signer.connect(eo(Ki({namespaces:Ki({},t&&{[this.namespace]:t})},s&&{optionalNamespaces:{[this.namespace]:s}}),{pairingTopic:e==null?void 0:e.pairingTopic,scopedProperties:d})).then(u=>{a(u)}).catch(u=>{c(new Error(u.message))})});if(!r)return;const o=ya(r.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:o),this.setAccounts(o),this.events.emit("connect",{chainId:cn(this.chainId)})}catch(r){throw this.signer.logger.error(r),r}finally{this.modal&&this.modal.closeModal()}}async authenticate(e,t){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts({chains:e==null?void 0:e.chains});try{const s=await new Promise(async(o,a)=>{var c;this.rpc.showQrModal&&((c=this.modal)==null||c.subscribeModal(h=>{!h.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),a(new Error("Connection request reset. Please try again.")))})),await this.signer.authenticate(eo(Ki({},e),{chains:this.rpc.chains}),t).then(h=>{o(h)}).catch(h=>{a(new Error(h.message))})}),r=s.session;if(r){const o=ya(r.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:o),this.setAccounts(o),this.events.emit("connect",{chainId:cn(this.chainId)})}return s}catch(s){throw this.signer.logger.error(s),s}finally{this.modal&&this.modal.closeModal()}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset()}get isWalletConnect(){return!0}get session(){return this.signer.session}registerEventListeners(){this.signer.on("session_event",e=>{const{params:t}=e,{event:s}=t;s.name==="accountsChanged"?(this.accounts=this.parseAccounts(s.data),this.events.emit("accountsChanged",this.accounts)):s.name==="chainChanged"?this.setChainId(this.formatChainId(s.data)):this.events.emit(s.name,s.data),this.events.emit("session_event",e)}),this.signer.on("accountsChanged",e=>{this.accounts=this.parseAccounts(e),this.events.emit("accountsChanged",this.accounts)}),this.signer.on("chainChanged",e=>{const t=parseInt(e);this.chainId=t,this.events.emit("chainChanged",cn(this.chainId)),this.persist()}),this.signer.on("session_update",e=>{this.events.emit("session_update",e)}),this.signer.on("session_delete",e=>{this.reset(),this.events.emit("session_delete",e),this.events.emit("disconnect",eo(Ki({},ae("USER_DISCONNECTED")),{data:e.topic,name:"USER_DISCONNECTED"}))}),this.signer.on("display_uri",e=>{var t,s;this.rpc.showQrModal&&((t=this.modal)==null||t.closeModal(),(s=this.modal)==null||s.openModal({uri:e})),this.events.emit("display_uri",e)})}switchEthereumChain(e){this.request({method:"wallet_switchEthereumChain",params:[{chainId:e.toString(16)}]})}isCompatibleChainId(e){return typeof e=="string"?e.startsWith(`${this.namespace}:`):!1}formatChainId(e){return`${this.namespace}:${e}`}parseChainId(e){return Number(e.split(":")[1])}setChainIds(e){const t=e.filter(s=>this.isCompatibleChainId(s)).map(s=>this.parseChainId(s));t.length&&(this.chainId=t[0],this.events.emit("chainChanged",cn(this.chainId)),this.persist())}setChainId(e){if(this.isCompatibleChainId(e)){const t=this.parseChainId(e);this.chainId=t,this.switchEthereumChain(t)}}parseAccountId(e){const[t,s,r]=e.split(":");return{chainId:`${t}:${s}`,address:r}}setAccounts(e){this.accounts=e.filter(t=>this.parseChainId(this.parseAccountId(t).chainId)===this.chainId).map(t=>this.parseAccountId(t).address),this.events.emit("accountsChanged",this.accounts)}getRpcConfig(e){var t,s;const r=(t=e==null?void 0:e.chains)!=null?t:[],o=(s=e==null?void 0:e.optionalChains)!=null?s:[],a=r.concat(o);if(!a.length)throw new Error("No chains specified in either `chains` or `optionalChains`");const c=r.length?(e==null?void 0:e.methods)||Yr:[],h=r.length?(e==null?void 0:e.events)||Qr:[],d=(e==null?void 0:e.optionalMethods)||[],u=(e==null?void 0:e.optionalEvents)||[],p=(e==null?void 0:e.rpcMap)||this.buildRpcMap(a,e.projectId),g=(e==null?void 0:e.qrModalOptions)||void 0;return{chains:r==null?void 0:r.map(_=>this.formatChainId(_)),optionalChains:o.map(_=>this.formatChainId(_)),methods:c,events:h,optionalMethods:d,optionalEvents:u,rpcMap:p,showQrModal:!!(e!=null&&e.showQrModal),qrModalOptions:g,projectId:e.projectId,metadata:e.metadata}}buildRpcMap(e,t){const s={};return e.forEach(r=>{s[r]=this.getRpcUrl(r,t)}),s}async initialize(e){if(this.rpc=this.getRpcConfig(e),this.chainId=this.rpc.chains.length?an(this.rpc.chains):an(this.rpc.optionalChains),this.signer=await M1.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:e.disableProviderPing,relayUrl:e.relayUrl,storage:e.storage,storageOptions:e.storageOptions,customStoragePrefix:e.customStoragePrefix,telemetryEnabled:e.telemetryEnabled,logger:e.logger}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal){let t;try{const{WalletConnectModal:s}=await q.e(1481).then(q.bind(q,81481));t=s}catch{throw new Error("To use QR modal, please install @walletconnect/modal package")}if(t)try{this.modal=new t(Ki({projectId:this.rpc.projectId},this.rpc.qrModalOptions))}catch(s){throw this.signer.logger.error(s),new Error("Could not generate WalletConnectModal Instance")}}}loadConnectOpts(e){if(!e)return;const{chains:t,optionalChains:s,rpcMap:r}=e;t&&ct(t)&&(this.rpc.chains=t.map(o=>this.formatChainId(o)),t.forEach(o=>{this.rpc.rpcMap[o]=(r==null?void 0:r[o])||this.getRpcUrl(o)})),s&&ct(s)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=s==null?void 0:s.map(o=>this.formatChainId(o)),s.forEach(o=>{this.rpc.rpcMap[o]=(r==null?void 0:r[o])||this.getRpcUrl(o)}))}getRpcUrl(e,t){var s;return((s=this.rpc.rpcMap)==null?void 0:s[e])||`${K1}?chainId=eip155:${e}&projectId=${t||this.rpc.projectId}`}async loadPersistedSession(){if(this.session)try{const e=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),t=this.session.namespaces[`${this.namespace}:${e}`]?this.session.namespaces[`${this.namespace}:${e}`]:this.session.namespaces[this.namespace];this.setChainIds(e?[this.formatChainId(e)]:t==null?void 0:t.accounts),this.setAccounts(t==null?void 0:t.accounts)}catch(e){this.signer.logger.error("Failed to load persisted session, clearing state..."),this.signer.logger.error(e),await this.disconnect().catch(t=>this.signer.logger.warn(t))}}reset(){this.chainId=1,this.accounts=[]}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId)}parseAccounts(e){return typeof e=="string"||e instanceof String?[this.parseAccount(e)]:e.map(t=>this.parseAccount(t))}}const tx=to}}]);
