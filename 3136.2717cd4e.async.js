"use strict";(self.webpackChunk_ant_design_web3_docs=self.webpackChunk_ant_design_web3_docs||[]).push([[3136],{53136:function(Es,Rt,$){$.d(Rt,{EthereumProvider:function(){return Nw}});var xe=$(72100),Ie=$.n(xe),ft=$(81365),C=$(46196),Te=$(73079),rt=$(42669),de=$(42014),ot=$(96884),He=$(55710),te=$(90032),Nt=$(24242),se=$(14224),ae=$(55872).Buffer;const we=":";function Pe(i){const[e,t]=i.split(we);return{namespace:e,reference:t}}function Et(i){const{namespace:e,reference:t}=i;return[e,t].join(we)}function Xt(i){const[e,t,s]=i.split(we);return{namespace:e,reference:t,address:s}}function di(i){const{namespace:e,reference:t,address:s}=i;return[e,t,s].join(we)}function ne(i,e){const t=[];return i.forEach(s=>{const r=e(s);t.includes(r)||t.push(r)}),t}function Q(i){const{address:e}=Xt(i);return e}function G(i){const{namespace:e,reference:t}=Xt(i);return Et({namespace:e,reference:t})}function De(i,e){const{namespace:t,reference:s}=Pe(e);return di({namespace:t,reference:s,address:i})}function Ke(i){return ne(i,Q)}function Mt(i){return ne(i,G)}function ei(i,e=[]){const t=[];return Object.keys(i).forEach(s=>{if(e.length&&!e.includes(s))return;const r=i[s];t.push(...r.accounts)}),t}function Tt(i,e=[]){const t=[];return Object.keys(i).forEach(s=>{if(e.length&&!e.includes(s))return;const r=i[s];t.push(...Mt(r.accounts))}),t}function pi(i,e=[]){const t=[];return Object.keys(i).forEach(s=>{if(e.length&&!e.includes(s))return;const r=i[s];t.push(...zt(s,r))}),t}function zt(i,e){return i.includes(":")?[i]:e.chains||[]}var N=Object.defineProperty,ee=Object.defineProperties,Ae=Object.getOwnPropertyDescriptors,ve=Object.getOwnPropertySymbols,$e=Object.prototype.hasOwnProperty,Qe=Object.prototype.propertyIsEnumerable,ht=(i,e,t)=>e in i?N(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,gi=(i,e)=>{for(var t in e||(e={}))$e.call(e,t)&&ht(i,t,e[t]);if(ve)for(var t of ve(e))Qe.call(e,t)&&ht(i,t,e[t]);return i},zi=(i,e)=>ee(i,Ae(e));const Fn="ReactNative",Xe={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"},Ht=" ",xs=":",Is="/",Ps=2,kn=1e3,Ln="js";function Hi(){return typeof se<"u"&&typeof se.versions<"u"&&typeof se.versions.node<"u"}function Kt(){return!(0,Te.getDocument)()&&!!(0,Te.getNavigator)()&&navigator.product===Fn}function Bn(){return Kt()&&typeof $.g<"u"&&typeof($.g==null?void 0:$.g.Platform)<"u"&&($.g==null?void 0:$.g.Platform.OS)==="android"}function Un(){return Kt()&&typeof $.g<"u"&&typeof($.g==null?void 0:$.g.Platform)<"u"&&($.g==null?void 0:$.g.Platform.OS)==="ios"}function fi(){return!Hi()&&!!(0,Te.getNavigator)()&&!!(0,Te.getDocument)()}function yi(){return Kt()?Xe.reactNative:Hi()?Xe.node:fi()?Xe.browser:Xe.unknown}function Js(){var i;try{return Kt()&&typeof $.g<"u"&&typeof($.g==null?void 0:$.g.Application)<"u"?(i=$.g.Application)==null?void 0:i.applicationId:void 0}catch{return}}function Mn(i,e){const t=new URLSearchParams(i);for(const s of Object.keys(e).sort())if(e.hasOwnProperty(s)){const r=e[s];r!==void 0&&t.set(s,r)}return t.toString()}function Zs(i){var e,t;const s=Ss();try{return i!=null&&i.url&&s.url&&new URL(i.url).host!==new URL(s.url).host&&(console.warn(`The configured WalletConnect 'metadata.url':${i.url} differs from the actual page url:${s.url}. This is probably unintended and can lead to issues.`),i.url=s.url),(e=i==null?void 0:i.icons)!=null&&e.length&&i.icons.length>0&&(i.icons=i.icons.filter(r=>r!=="")),zi(gi(gi({},s),i),{url:(i==null?void 0:i.url)||s.url,name:(i==null?void 0:i.name)||s.name,description:(i==null?void 0:i.description)||s.description,icons:(t=i==null?void 0:i.icons)!=null&&t.length&&i.icons.length>0?i.icons:s.icons})}catch(r){return console.warn("Error populating app metadata",r),i||s}}function Ss(){return(0,rt.D)()||{name:"",description:"",url:"",icons:[""]}}function zn(i,e){var t;const s=yi(),r={protocol:i,version:e,env:s};return s==="browser"&&(r.host=((t=On())==null?void 0:t.host)||"unknown"),r}function Ys(){if(yi()===Xe.reactNative&&typeof $.g<"u"&&typeof($.g==null?void 0:$.g.Platform)<"u"){const{OS:t,Version:s}=$.g.Platform;return[t,s].join("-")}const i=(0,ft.qY)();if(i===null)return"unknown";const e=i.os?i.os.replace(" ","").toLowerCase():"unknown";return i.type==="browser"?[e,i.name,i.version].join("-"):[e,i.version].join("-")}function Hn(){var i;const e=yi();return e===Xe.browser?[e,((i=(0,Te.getLocation)())==null?void 0:i.host)||"unknown"].join(":"):e}function Kn(i,e,t){const s=Ys(),r=Hn();return[[i,e].join("-"),[Ln,t].join("-"),s,r].join("/")}function go({protocol:i,version:e,relayUrl:t,sdkVersion:s,auth:r,projectId:o,useOnCloseEvent:a,bundleId:c,packageName:h}){const u=t.split("?"),d=Kn(i,e,s),p={auth:r,ua:d,projectId:o,useOnCloseEvent:a||void 0,packageName:h||void 0,bundleId:c||void 0},f=Mn(u[1]||"",p);return u[0]+"?"+f}function oh(i){let e=(i.match(/^[^:]+(?=:\/\/)/gi)||[])[0];const t=typeof e<"u"?i.split("://")[1]:i;return e=e==="wss"?"https":"http",[e,t].join("://")}function ah(i,e,t){if(!i[e]||typeof i[e]!==t)throw new Error(`Missing or invalid "${e}" param`)}function fo(i,e=Ps){return yo(i.split(Is),e)}function ch(i){return fo(i).join(Ht)}function mi(i,e){return i.filter(t=>e.includes(t)).length===i.length}function yo(i,e=Ps){return i.slice(Math.max(i.length-e,0))}function xt(i){return Object.fromEntries(i.entries())}function Ki(i){return new Map(Object.entries(i))}function Vn(i,e){const t={};return Object.keys(i).forEach(s=>{t[s]=e(i[s])}),t}const Gn=i=>i;function Wn(i){return i.trim().replace(/^\w/,e=>e.toUpperCase())}function Vi(i){return i.split(Ht).map(e=>Wn(e)).join(Ht)}function ti(i=C.FIVE_MINUTES,e){const t=(0,C.toMiliseconds)(i||C.FIVE_MINUTES);let s,r,o,a;return{resolve:c=>{o&&s&&(clearTimeout(o),s(c),a=Promise.resolve(c))},reject:c=>{o&&r&&(clearTimeout(o),r(c))},done:()=>new Promise((c,h)=>{if(a)return c(a);o=setTimeout(()=>{const u=new Error(e);a=Promise.reject(u),h(u)},t),s=c,r=h})}}function Vt(i,e,t){return new Promise(async(s,r)=>{const o=setTimeout(()=>r(new Error(t)),e);try{const a=await i;s(a)}catch(a){r(a)}clearTimeout(o)})}function Qs(i,e){if(typeof e=="string"&&e.startsWith(`${i}:`))return e;if(i.toLowerCase()==="topic"){if(typeof e!="string")throw new Error('Value must be "string" for expirer target type: topic');return`topic:${e}`}else if(i.toLowerCase()==="id"){if(typeof e!="number")throw new Error('Value must be "number" for expirer target type: id');return`id:${e}`}throw new Error(`Unknown expirer target type: ${i}`)}function Jn(i){return Qs("topic",i)}function Zn(i){return Qs("id",i)}function Xs(i){const[e,t]=i.split(":"),s={id:void 0,topic:void 0};if(e==="topic"&&typeof t=="string")s.topic=t;else if(e==="id"&&Number.isInteger(Number(t)))s.id=Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);return s}function Ne(i,e){return(0,C.fromMiliseconds)((e||Date.now())+(0,C.toMiliseconds)(i))}function $t(i){return Date.now()>=(0,C.toMiliseconds)(i)}function pe(i,e){return`${i}${e?`:${e}`:""}`}function Ue(i=[],e=[]){return[...new Set([...i,...e])]}async function Yn({id:i,topic:e,wcDeepLink:t}){var s;try{if(!t)return;const r=typeof t=="string"?JSON.parse(t):t,o=r==null?void 0:r.href;if(typeof o!="string")return;const a=mo(o,i,e),c=yi();if(c===Xe.browser){if(!((s=(0,Te.getDocument)())!=null&&s.hasFocus())){console.warn("Document does not have focus, skipping deeplink.");return}wo(a)}else c===Xe.reactNative&&typeof($.g==null?void 0:$.g.Linking)<"u"&&await $.g.Linking.openURL(a)}catch(r){console.error(r)}}function mo(i,e,t){const s=`requestId=${e}&sessionTopic=${t}`;i.endsWith("/")&&(i=i.slice(0,-1));let r=`${i}`;if(i.startsWith("https://t.me")){const o=i.includes("?")?"&startapp=":"?startapp=";r=`${r}${o}${Eo(s,!0)}`}else r=`${r}/wc?${s}`;return r}function wo(i){let e="_self";bo()?e="_top":(vo()||i.startsWith("https://")||i.startsWith("http://"))&&(e="_blank"),window.open(i,e,"noreferrer noopener")}async function _o(i,e){let t="";try{if(fi()&&(t=localStorage.getItem(e),t))return t;t=await i.getItem(e)}catch(s){console.error(s)}return t}function Qn(i,e){return i.filter(t=>e.includes(t))}function Xn(i,e){if(!i.includes(e))return null;const t=i.split(/([&,?,=])/),s=t.indexOf(e);return t[s+2]}function en(){return typeof crypto<"u"&&crypto!=null&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu,i=>{const e=Math.random()*16|0;return(i==="x"?e:e&3|8).toString(16)})}function tn(){return typeof se<"u"&&{NODE_ENV:"production",PUBLIC_PATH:"/"}.IS_VITEST==="true"}function vo(){return typeof window<"u"&&(!!window.TelegramWebviewProxy||!!window.Telegram||!!window.TelegramWebviewProxyProto)}function bo(){try{return window.self!==window.top}catch{return!1}}function Eo(i,e=!1){const t=ae.from(i).toString("base64");return e?t.replace(/[=]/g,""):t}function er(i){return ae.from(i,"base64").toString("utf-8")}function sn(i){return new Promise(e=>setTimeout(e,i))}function Oi(i){if(!Number.isSafeInteger(i)||i<0)throw new Error("positive integer expected, got "+i)}function Os(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function wi(i,...e){if(!Os(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function nn(i){if(typeof i!="function"||typeof i.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Oi(i.outputLen),Oi(i.blockLen)}function _i(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function rn(i,e){wi(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}const Ai=BigInt(2**32-1),on=BigInt(32);function y(i,e=!1){return e?{h:Number(i&Ai),l:Number(i>>on&Ai)}:{h:Number(i>>on&Ai)|0,l:Number(i&Ai)|0}}function g(i,e=!1){let t=new Uint32Array(i.length),s=new Uint32Array(i.length);for(let r=0;r<i.length;r++){const{h:o,l:a}=y(i[r],e);[t[r],s[r]]=[o,a]}return[t,s]}const m=(i,e,t)=>i<<t|e>>>32-t,I=(i,e,t)=>e<<t|i>>>32-t,B=(i,e,t)=>e<<t-32|i>>>64-t,W=(i,e,t)=>i<<t-32|e>>>64-t,z=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function ue(i){return new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4))}function qe(i){return new DataView(i.buffer,i.byteOffset,i.byteLength)}function Fe(i,e){return i<<32-e|i>>>e}const It=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function As(i){return i<<24&4278190080|i<<8&16711680|i>>>8&65280|i>>>24&255}function Gi(i){for(let e=0;e<i.length;e++)i[e]=As(i[e])}function vi(i){if(typeof i!="string")throw new Error("utf8ToBytes expected string, got "+typeof i);return new Uint8Array(new TextEncoder().encode(i))}function bi(i){return typeof i=="string"&&(i=vi(i)),wi(i),i}function hh(...i){let e=0;for(let s=0;s<i.length;s++){const r=i[s];wi(r),e+=r.length}const t=new Uint8Array(e);for(let s=0,r=0;s<i.length;s++){const o=i[s];t.set(o,r),r+=o.length}return t}class tr{clone(){return this._cloneInto()}}function xo(i){const e=s=>i().update(bi(s)).digest(),t=i();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>i(),e}function Wi(i=32){if(z&&typeof z.getRandomValues=="function")return z.getRandomValues(new Uint8Array(i));if(z&&typeof z.randomBytes=="function")return z.randomBytes(i);throw new Error("crypto.getRandomValues must be defined")}const Io=[],Po=[],So=[],lh=BigInt(0),Cs=BigInt(1),uh=BigInt(2),dh=BigInt(7),ph=BigInt(256),gh=BigInt(113);for(let i=0,e=Cs,t=1,s=0;i<24;i++){[t,s]=[s,(2*t+3*s)%5],Io.push(2*(5*s+t)),Po.push((i+1)*(i+2)/2%64);let r=lh;for(let o=0;o<7;o++)e=(e<<Cs^(e>>dh)*gh)%ph,e&uh&&(r^=Cs<<(Cs<<BigInt(o))-Cs);So.push(r)}const[fh,yh]=g(So,!0),Oo=(i,e,t)=>t>32?B(i,e,t):m(i,e,t),Ao=(i,e,t)=>t>32?W(i,e,t):I(i,e,t);function mh(i,e=24){const t=new Uint32Array(10);for(let s=24-e;s<24;s++){for(let a=0;a<10;a++)t[a]=i[a]^i[a+10]^i[a+20]^i[a+30]^i[a+40];for(let a=0;a<10;a+=2){const c=(a+8)%10,h=(a+2)%10,u=t[h],d=t[h+1],p=Oo(u,d,1)^t[c],f=Ao(u,d,1)^t[c+1];for(let v=0;v<50;v+=10)i[a+v]^=p,i[a+v+1]^=f}let r=i[2],o=i[3];for(let a=0;a<24;a++){const c=Po[a],h=Oo(r,o,c),u=Ao(r,o,c),d=Io[a];r=i[d],o=i[d+1],i[d]=h,i[d+1]=u}for(let a=0;a<50;a+=10){for(let c=0;c<10;c++)t[c]=i[a+c];for(let c=0;c<10;c++)i[a+c]^=~t[(c+2)%10]&t[(c+4)%10]}i[0]^=fh[s],i[1]^=yh[s]}t.fill(0)}class ir extends tr{constructor(e,t,s,r=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=s,this.enableXOF=r,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Oi(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=ue(this.state)}keccak(){It||Gi(this.state32),mh(this.state32,this.rounds),It||Gi(this.state32),this.posOut=0,this.pos=0}update(e){_i(this);const{blockLen:t,state:s}=this;e=bi(e);const r=e.length;for(let o=0;o<r;){const a=Math.min(t-this.pos,r-o);for(let c=0;c<a;c++)s[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:s,blockLen:r}=this;e[s]^=t,t&128&&s===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){_i(this,!1),wi(e),this.finish();const t=this.state,{blockLen:s}=this;for(let r=0,o=e.length;r<o;){this.posOut>=s&&this.keccak();const a=Math.min(s-this.posOut,o-r);e.set(t.subarray(this.posOut,this.posOut+a),r),this.posOut+=a,r+=a}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Oi(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(rn(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:s,outputLen:r,rounds:o,enableXOF:a}=this;return e||(e=new ir(t,s,r,a,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=s,e.outputLen=r,e.enableXOF=a,e.destroyed=this.destroyed,e}}const wh=(i,e,t)=>xo(()=>new ir(e,i,t)),_h=wh(1,136,256/8),vh="https://rpc.walletconnect.org/v1";function Co(i){const e=`Ethereum Signed Message:
${i.length}`,t=new TextEncoder().encode(e+i);return"0x"+ae.from(_h(t)).toString("hex")}async function bh(i,e,t,s,r,o){switch(t.t){case"eip191":return await Eh(i,e,t.s);case"eip1271":return await xh(i,e,t.s,s,r,o);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`)}}async function Eh(i,e,t){return(await(0,de.R)({hash:Co(e),signature:t})).toLowerCase()===i.toLowerCase()}async function xh(i,e,t,s,r,o){const a=Pe(s);if(!a.namespace||!a.reference)throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${s}`);try{const c="0x1626ba7e",h="0000000000000000000000000000000000000000000000000000000000000040",u="0000000000000000000000000000000000000000000000000000000000000041",d=t.substring(2),p=Co(e).substring(2),f=c+p+h+u+d,v=await fetch(`${o||vh}/?chainId=${s}&projectId=${r}`,{method:"POST",body:JSON.stringify({id:Ih(),jsonrpc:"2.0",method:"eth_call",params:[{to:i,data:f},"latest"]})}),{result:w}=await v.json();return w?w.slice(0,c.length).toLowerCase()===c.toLowerCase():!1}catch(c){return console.error("isValidEip1271Signature: ",c),!1}}function Ih(){return Date.now()+Math.floor(Math.random()*1e3)}function Ph(i){const e=atob(i),t=new Uint8Array(e.length);for(let a=0;a<e.length;a++)t[a]=e.charCodeAt(a);const s=t[0];if(s===0)throw new Error("No signatures found");const r=1+s*64;if(t.length<r)throw new Error("Transaction data too short for claimed signature count");if(t.length<100)throw new Error("Transaction too short");const o=ae.from(i,"base64").slice(1,65);return ot.default.encode(o)}var Sh=Object.defineProperty,Oh=Object.defineProperties,Ah=Object.getOwnPropertyDescriptors,Ro=Object.getOwnPropertySymbols,Ch=Object.prototype.hasOwnProperty,Rh=Object.prototype.propertyIsEnumerable,No=(i,e,t)=>e in i?Sh(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,sr=(i,e)=>{for(var t in e||(e={}))Ch.call(e,t)&&No(i,t,e[t]);if(Ro)for(var t of Ro(e))Rh.call(e,t)&&No(i,t,e[t]);return i},To=(i,e)=>Oh(i,Ah(e));const Nh="did:pkh:",nr=i=>i==null?void 0:i.split(":"),Th=i=>{const e=i&&nr(i);if(e)return i.includes(Nh)?e[3]:e[1]},rr=i=>{const e=i&&nr(i);if(e)return e[2]+":"+e[3]},an=i=>{const e=i&&nr(i);if(e)return e.pop()};async function $o(i){const{cacao:e,projectId:t}=i,{s,p:r}=e,o=jo(r,r.iss),a=an(r.iss);return await bh(a,o,s,rr(r.iss),t)}const jo=(i,e)=>{const t=`${i.domain} wants you to sign in with your Ethereum account:`,s=an(e);if(!i.aud&&!i.uri)throw new Error("Either `aud` or `uri` is required to construct the message");let r=i.statement||void 0;const o=`URI: ${i.aud||i.uri}`,a=`Version: ${i.version}`,c=`Chain ID: ${Th(e)}`,h=`Nonce: ${i.nonce}`,u=`Issued At: ${i.iat}`,d=i.exp?`Expiration Time: ${i.exp}`:void 0,p=i.nbf?`Not Before: ${i.nbf}`:void 0,f=i.requestId?`Request ID: ${i.requestId}`:void 0,v=i.resources?`Resources:${i.resources.map(b=>`
- ${b}`).join("")}`:void 0,w=Ji(i.resources);if(w){const b=Ci(w);r=Fo(r,b)}return[t,s,"",r,"",o,a,c,h,u,d,p,f,v].filter(b=>b!=null).join(`
`)};function Mw(i,e,t){return t.includes("did:pkh:")||(t=`did:pkh:${t}`),{h:{t:"caip122"},p:{iss:t,domain:i.domain,aud:i.aud,version:i.version,nonce:i.nonce,iat:i.iat,statement:i.statement,requestId:i.requestId,resources:i.resources,nbf:i.nbf,exp:i.exp},s:e}}function zw(i){var e;const{authPayload:t,chains:s,methods:r}=i,o=t.statement||"";if(!(s!=null&&s.length))return t;const a=t.chains,c=Qn(a,s);if(!(c!=null&&c.length))throw new Error("No supported chains");const h=$h(t.resources);if(!h)return t;ii(h);const u=jh(h,"eip155");let d=(t==null?void 0:t.resources)||[];if(u!=null&&u.length){const p=Dh(u),f=Qn(p,r);if(!(f!=null&&f.length))throw new Error(`Supported methods don't satisfy the requested: ${JSON.stringify(p)}, supported: ${JSON.stringify(r)}`);const v=Do("request",f,{chains:c}),w=Lh(h,"eip155",v);d=((e=t==null?void 0:t.resources)==null?void 0:e.slice(0,-1))||[],d.push(or(w))}return To(sr({},t),{statement:zh(o,Ji(d)),chains:c,resources:t!=null&&t.resources||d.length>0?d:void 0})}function $h(i){const e=Ji(i);if(e&&qo(e))return Ci(e)}function Hw(i,e){var t;return(t=i==null?void 0:i.att)==null?void 0:t.hasOwnProperty(e)}function jh(i,e){var t,s;return(t=i==null?void 0:i.att)!=null&&t[e]?Object.keys((s=i==null?void 0:i.att)==null?void 0:s[e]):[]}function Kw(i){return(i==null?void 0:i.map(e=>Object.keys(e)))||[]}function Dh(i){return(i==null?void 0:i.map(e=>{var t;return(t=e.split("/"))==null?void 0:t[1]}))||[]}function qh(i){return ae.from(JSON.stringify(i)).toString("base64")}function Fh(i){return JSON.parse(ae.from(i,"base64").toString("utf-8"))}function ii(i){if(!i)throw new Error("No recap provided, value is undefined");if(!i.att)throw new Error("No `att` property found");const e=Object.keys(i.att);if(!(e!=null&&e.length))throw new Error("No resources found in `att` property");e.forEach(t=>{const s=i.att[t];if(Array.isArray(s))throw new Error(`Resource must be an object: ${t}`);if(typeof s!="object")throw new Error(`Resource must be an object: ${t}`);if(!Object.keys(s).length)throw new Error(`Resource object is empty: ${t}`);Object.keys(s).forEach(r=>{const o=s[r];if(!Array.isArray(o))throw new Error(`Ability limits ${r} must be an array of objects, found: ${o}`);if(!o.length)throw new Error(`Value of ${r} is empty array, must be an array with objects`);o.forEach(a=>{if(typeof a!="object")throw new Error(`Ability limits (${r}) must be an array of objects, found: ${a}`)})})})}function kh(i,e,t,s={}){return t==null||t.sort((r,o)=>r.localeCompare(o)),{att:{[i]:Do(e,t,s)}}}function Lh(i,e,t){var s;i.att[e]=sr({},t);const r=(s=Object.keys(i.att))==null?void 0:s.sort((a,c)=>a.localeCompare(c)),o={att:{}};return r.reduce((a,c)=>(a.att[c]=i.att[c],a),o)}function Do(i,e,t={}){e=e==null?void 0:e.sort((r,o)=>r.localeCompare(o));const s=e.map(r=>({[`${i}/${r}`]:[t]}));return Object.assign({},...s)}function or(i){return ii(i),`urn:recap:${qh(i).replace(/=/g,"")}`}function Ci(i){const e=Fh(i.replace("urn:recap:",""));return ii(e),e}function Bh(i,e,t){const s=kh(i,e,t);return or(s)}function qo(i){return i&&i.includes("urn:recap:")}function Uh(i,e){const t=Ci(i),s=Ci(e),r=Mh(t,s);return or(r)}function Mh(i,e){ii(i),ii(e);const t=Object.keys(i.att).concat(Object.keys(e.att)).sort((r,o)=>r.localeCompare(o)),s={att:{}};return t.forEach(r=>{var o,a;Object.keys(((o=i.att)==null?void 0:o[r])||{}).concat(Object.keys(((a=e.att)==null?void 0:a[r])||{})).sort((c,h)=>c.localeCompare(h)).forEach(c=>{var h,u;s.att[r]=To(sr({},s.att[r]),{[c]:((h=i.att[r])==null?void 0:h[c])||((u=e.att[r])==null?void 0:u[c])})})}),s}function Fo(i="",e){ii(e);const t="I further authorize the stated URI to perform the following actions on my behalf: ";if(i.includes(t))return i;const s=[];let r=0;Object.keys(e.att).forEach(c=>{const h=Object.keys(e.att[c]).map(p=>({ability:p.split("/")[0],action:p.split("/")[1]}));h.sort((p,f)=>p.action.localeCompare(f.action));const u={};h.forEach(p=>{u[p.ability]||(u[p.ability]=[]),u[p.ability].push(p.action)});const d=Object.keys(u).map(p=>(r++,`(${r}) '${p}': '${u[p].join("', '")}' for '${c}'.`));s.push(d.join(", ").replace(".,","."))});const o=s.join(" "),a=`${t}${o}`;return`${i?i+" ":""}${a}`}function ko(i){var e;const t=Ci(i);ii(t);const s=(e=t.att)==null?void 0:e.eip155;return s?Object.keys(s).map(r=>r.split("/")[1]):[]}function Lo(i){const e=Ci(i);ii(e);const t=[];return Object.values(e.att).forEach(s=>{Object.values(s).forEach(r=>{var o;(o=r==null?void 0:r[0])!=null&&o.chains&&t.push(r[0].chains)})}),[...new Set(t.flat())]}function zh(i,e){if(!e)return i;const t=Ci(e);return ii(t),Fo(i,t)}function Ji(i){if(!i)return;const e=i==null?void 0:i[i.length-1];return qo(e)?e:void 0}function ar(i){if(!Number.isSafeInteger(i)||i<0)throw new Error("positive integer expected, got "+i)}function Bo(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function yt(i,...e){if(!Bo(i))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(i.length))throw new Error("Uint8Array expected of length "+e+", got length="+i.length)}function Uo(i,e=!0){if(i.destroyed)throw new Error("Hash instance has been destroyed");if(e&&i.finished)throw new Error("Hash#digest() has already been called")}function Hh(i,e){yt(i);const t=e.outputLen;if(i.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Mo(i){if(typeof i!="boolean")throw new Error(`boolean expected, not ${i}`)}const Ei=i=>new Uint32Array(i.buffer,i.byteOffset,Math.floor(i.byteLength/4)),Kh=i=>new DataView(i.buffer,i.byteOffset,i.byteLength);if(!(new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68))throw new Error("Non little-endian hardware is not supported");function Vh(i){if(typeof i!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(i))}function cr(i){if(typeof i=="string")i=Vh(i);else if(Bo(i))i=hr(i);else throw new Error("Uint8Array expected, got "+typeof i);return i}function Gh(i,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(i,e)}function Wh(i,e){if(i.length!==e.length)return!1;let t=0;for(let s=0;s<i.length;s++)t|=i[s]^e[s];return t===0}const Jh=(i,e)=>{function t(s,...r){if(yt(s),i.nonceLength!==void 0){const u=r[0];if(!u)throw new Error("nonce / iv required");i.varSizeNonce?yt(u):yt(u,i.nonceLength)}const o=i.tagLength;o&&r[1]!==void 0&&yt(r[1]);const a=e(s,...r),c=(u,d)=>{if(d!==void 0){if(u!==2)throw new Error("cipher output not supported");yt(d)}};let h=!1;return{encrypt(u,d){if(h)throw new Error("cannot encrypt() twice with same key + nonce");return h=!0,yt(u),c(a.encrypt.length,d),a.encrypt(u,d)},decrypt(u,d){if(yt(u),o&&u.length<o)throw new Error("invalid ciphertext length: smaller than tagLength="+o);return c(a.decrypt.length,d),a.decrypt(u,d)}}}return Object.assign(t,i),t};function zo(i,e,t=!0){if(e===void 0)return new Uint8Array(i);if(e.length!==i)throw new Error("invalid output length, expected "+i+", got: "+e.length);if(t&&!Zh(e))throw new Error("invalid output, must be aligned");return e}function Ho(i,e,t,s){if(typeof i.setBigUint64=="function")return i.setBigUint64(e,t,s);const r=BigInt(32),o=BigInt(4294967295),a=Number(t>>r&o),c=Number(t&o),h=s?4:0,u=s?0:4;i.setUint32(e+h,a,s),i.setUint32(e+u,c,s)}function Zh(i){return i.byteOffset%4===0}function hr(i){return Uint8Array.from(i)}function Zi(...i){for(let e=0;e<i.length;e++)i[e].fill(0)}const Ko=i=>Uint8Array.from(i.split("").map(e=>e.charCodeAt(0))),Yh=Ko("expand 16-byte k"),Qh=Ko("expand 32-byte k"),Xh=Ei(Yh),el=Ei(Qh);function ge(i,e){return i<<e|i>>>32-e}function lr(i){return i.byteOffset%4===0}const cn=64,tl=16,Vo=2**32-1,Go=new Uint32Array;function il(i,e,t,s,r,o,a,c){const h=r.length,u=new Uint8Array(cn),d=Ei(u),p=lr(r)&&lr(o),f=p?Ei(r):Go,v=p?Ei(o):Go;for(let w=0;w<h;a++){if(i(e,t,s,d,a,c),a>=Vo)throw new Error("arx: counter overflow");const b=Math.min(cn,h-w);if(p&&b===cn){const _=w/4;if(w%4!==0)throw new Error("arx: invalid block position");for(let x=0,E;x<tl;x++)E=_+x,v[E]=f[E]^d[x];w+=cn;continue}for(let _=0,x;_<b;_++)x=w+_,o[x]=r[x]^u[_];w+=b}}function sl(i,e){const{allowShortKeys:t,extendNonceFn:s,counterLength:r,counterRight:o,rounds:a}=Gh({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof i!="function")throw new Error("core must be a function");return ar(r),ar(a),Mo(o),Mo(t),(c,h,u,d,p=0)=>{yt(c),yt(h),yt(u);const f=u.length;if(d===void 0&&(d=new Uint8Array(f)),yt(d),ar(p),p<0||p>=Vo)throw new Error("arx: counter overflow");if(d.length<f)throw new Error(`arx: output (${d.length}) is shorter than data (${f})`);const v=[];let w=c.length,b,_;if(w===32)v.push(b=hr(c)),_=el;else if(w===16&&t)b=new Uint8Array(32),b.set(c),b.set(c,16),_=Xh,v.push(b);else throw new Error(`arx: invalid 32-byte key, got length=${w}`);lr(h)||v.push(h=hr(h));const x=Ei(b);if(s){if(h.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(_,x,Ei(h.subarray(0,16)),x),h=h.subarray(16)}const E=16-r;if(E!==h.length)throw new Error(`arx: nonce must be ${E} or 16 bytes`);if(E!==12){const T=new Uint8Array(12);T.set(h,o?0:12-h.length),h=T,v.push(h)}const R=Ei(h);return il(i,_,x,R,u,d,p,a),Zi(...v),d}}const et=(i,e)=>i[e++]&255|(i[e++]&255)<<8;class nl{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=cr(e),yt(e,32);const t=et(e,0),s=et(e,2),r=et(e,4),o=et(e,6),a=et(e,8),c=et(e,10),h=et(e,12),u=et(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|s<<3)&8191,this.r[2]=(s>>>10|r<<6)&7939,this.r[3]=(r>>>7|o<<9)&8191,this.r[4]=(o>>>4|a<<12)&255,this.r[5]=a>>>1&8190,this.r[6]=(a>>>14|c<<2)&8191,this.r[7]=(c>>>11|h<<5)&8065,this.r[8]=(h>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let d=0;d<8;d++)this.pad[d]=et(e,16+2*d)}process(e,t,s=!1){const r=s?0:2048,{h:o,r:a}=this,c=a[0],h=a[1],u=a[2],d=a[3],p=a[4],f=a[5],v=a[6],w=a[7],b=a[8],_=a[9],x=et(e,t+0),E=et(e,t+2),R=et(e,t+4),T=et(e,t+6),k=et(e,t+8),O=et(e,t+10),D=et(e,t+12),U=et(e,t+14);let P=o[0]+(x&8191),Z=o[1]+((x>>>13|E<<3)&8191),H=o[2]+((E>>>10|R<<6)&8191),V=o[3]+((R>>>7|T<<9)&8191),X=o[4]+((T>>>4|k<<12)&8191),A=o[5]+(k>>>1&8191),F=o[6]+((k>>>14|O<<2)&8191),q=o[7]+((O>>>11|D<<5)&8191),M=o[8]+((D>>>8|U<<8)&8191),K=o[9]+(U>>>5|r),j=0,Y=j+P*c+Z*(5*_)+H*(5*b)+V*(5*w)+X*(5*v);j=Y>>>13,Y&=8191,Y+=A*(5*f)+F*(5*p)+q*(5*d)+M*(5*u)+K*(5*h),j+=Y>>>13,Y&=8191;let re=j+P*h+Z*c+H*(5*_)+V*(5*b)+X*(5*w);j=re>>>13,re&=8191,re+=A*(5*v)+F*(5*f)+q*(5*p)+M*(5*d)+K*(5*u),j+=re>>>13,re&=8191;let oe=j+P*u+Z*h+H*c+V*(5*_)+X*(5*b);j=oe>>>13,oe&=8191,oe+=A*(5*w)+F*(5*v)+q*(5*f)+M*(5*p)+K*(5*d),j+=oe>>>13,oe&=8191;let Oe=j+P*d+Z*u+H*h+V*c+X*(5*_);j=Oe>>>13,Oe&=8191,Oe+=A*(5*b)+F*(5*w)+q*(5*v)+M*(5*f)+K*(5*p),j+=Oe>>>13,Oe&=8191;let me=j+P*p+Z*d+H*u+V*h+X*c;j=me>>>13,me&=8191,me+=A*(5*_)+F*(5*b)+q*(5*w)+M*(5*v)+K*(5*f),j+=me>>>13,me&=8191;let Be=j+P*f+Z*p+H*d+V*u+X*h;j=Be>>>13,Be&=8191,Be+=A*c+F*(5*_)+q*(5*b)+M*(5*w)+K*(5*v),j+=Be>>>13,Be&=8191;let Ye=j+P*v+Z*f+H*p+V*d+X*u;j=Ye>>>13,Ye&=8191,Ye+=A*h+F*c+q*(5*_)+M*(5*b)+K*(5*w),j+=Ye>>>13,Ye&=8191;let ct=j+P*w+Z*v+H*f+V*p+X*d;j=ct>>>13,ct&=8191,ct+=A*u+F*h+q*c+M*(5*_)+K*(5*b),j+=ct>>>13,ct&=8191;let Me=j+P*b+Z*w+H*v+V*f+X*p;j=Me>>>13,Me&=8191,Me+=A*d+F*u+q*h+M*c+K*(5*_),j+=Me>>>13,Me&=8191;let ze=j+P*_+Z*b+H*w+V*v+X*f;j=ze>>>13,ze&=8191,ze+=A*p+F*d+q*u+M*h+K*c,j+=ze>>>13,ze&=8191,j=(j<<2)+j|0,j=j+Y|0,Y=j&8191,j=j>>>13,re+=j,o[0]=Y,o[1]=re,o[2]=oe,o[3]=Oe,o[4]=me,o[5]=Be,o[6]=Ye,o[7]=ct,o[8]=Me,o[9]=ze}finalize(){const{h:e,pad:t}=this,s=new Uint16Array(10);let r=e[1]>>>13;e[1]&=8191;for(let c=2;c<10;c++)e[c]+=r,r=e[c]>>>13,e[c]&=8191;e[0]+=r*5,r=e[0]>>>13,e[0]&=8191,e[1]+=r,r=e[1]>>>13,e[1]&=8191,e[2]+=r,s[0]=e[0]+5,r=s[0]>>>13,s[0]&=8191;for(let c=1;c<10;c++)s[c]=e[c]+r,r=s[c]>>>13,s[c]&=8191;s[9]-=8192;let o=(r^1)-1;for(let c=0;c<10;c++)s[c]&=o;o=~o;for(let c=0;c<10;c++)e[c]=e[c]&o|s[c];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let a=e[0]+t[0];e[0]=a&65535;for(let c=1;c<8;c++)a=(e[c]+t[c]|0)+(a>>>16)|0,e[c]=a&65535;Zi(s)}update(e){Uo(this);const{buffer:t,blockLen:s}=this;e=cr(e);const r=e.length;for(let o=0;o<r;){const a=Math.min(s-this.pos,r-o);if(a===s){for(;s<=r-o;o+=s)this.process(e,o);continue}t.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){Zi(this.h,this.r,this.buffer,this.pad)}digestInto(e){Uo(this),Hh(e,this),this.finished=!0;const{buffer:t,h:s}=this;let{pos:r}=this;if(r){for(t[r++]=1;r<16;r++)t[r]=0;this.process(t,0,!0)}this.finalize();let o=0;for(let a=0;a<8;a++)e[o++]=s[a]>>>0,e[o++]=s[a]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}}function rl(i){const e=(s,r)=>i(r).update(cr(s)).digest(),t=i(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=s=>i(s),e}const ol=rl(i=>new nl(i));function al(i,e,t,s,r,o=20){let a=i[0],c=i[1],h=i[2],u=i[3],d=e[0],p=e[1],f=e[2],v=e[3],w=e[4],b=e[5],_=e[6],x=e[7],E=r,R=t[0],T=t[1],k=t[2],O=a,D=c,U=h,P=u,Z=d,H=p,V=f,X=v,A=w,F=b,q=_,M=x,K=E,j=R,Y=T,re=k;for(let Oe=0;Oe<o;Oe+=2)O=O+Z|0,K=ge(K^O,16),A=A+K|0,Z=ge(Z^A,12),O=O+Z|0,K=ge(K^O,8),A=A+K|0,Z=ge(Z^A,7),D=D+H|0,j=ge(j^D,16),F=F+j|0,H=ge(H^F,12),D=D+H|0,j=ge(j^D,8),F=F+j|0,H=ge(H^F,7),U=U+V|0,Y=ge(Y^U,16),q=q+Y|0,V=ge(V^q,12),U=U+V|0,Y=ge(Y^U,8),q=q+Y|0,V=ge(V^q,7),P=P+X|0,re=ge(re^P,16),M=M+re|0,X=ge(X^M,12),P=P+X|0,re=ge(re^P,8),M=M+re|0,X=ge(X^M,7),O=O+H|0,re=ge(re^O,16),q=q+re|0,H=ge(H^q,12),O=O+H|0,re=ge(re^O,8),q=q+re|0,H=ge(H^q,7),D=D+V|0,K=ge(K^D,16),M=M+K|0,V=ge(V^M,12),D=D+V|0,K=ge(K^D,8),M=M+K|0,V=ge(V^M,7),U=U+X|0,j=ge(j^U,16),A=A+j|0,X=ge(X^A,12),U=U+X|0,j=ge(j^U,8),A=A+j|0,X=ge(X^A,7),P=P+Z|0,Y=ge(Y^P,16),F=F+Y|0,Z=ge(Z^F,12),P=P+Z|0,Y=ge(Y^P,8),F=F+Y|0,Z=ge(Z^F,7);let oe=0;s[oe++]=a+O|0,s[oe++]=c+D|0,s[oe++]=h+U|0,s[oe++]=u+P|0,s[oe++]=d+Z|0,s[oe++]=p+H|0,s[oe++]=f+V|0,s[oe++]=v+X|0,s[oe++]=w+A|0,s[oe++]=b+F|0,s[oe++]=_+q|0,s[oe++]=x+M|0,s[oe++]=E+K|0,s[oe++]=R+j|0,s[oe++]=T+Y|0,s[oe++]=k+re|0}const cl=sl(al,{counterRight:!1,counterLength:4,allowShortKeys:!1}),hl=new Uint8Array(16),Wo=(i,e)=>{i.update(e);const t=e.length%16;t&&i.update(hl.subarray(t))},ll=new Uint8Array(32);function Jo(i,e,t,s,r){const o=i(e,t,ll),a=ol.create(o);r&&Wo(a,r),Wo(a,s);const c=new Uint8Array(16),h=Kh(c);Ho(h,0,BigInt(r?r.length:0),!0),Ho(h,8,BigInt(s.length),!0),a.update(c);const u=a.digest();return Zi(o,c),u}const ul=i=>(e,t,s)=>({encrypt(r,o){const a=r.length;o=zo(a+16,o,!1),o.set(r);const c=o.subarray(0,-16);i(e,t,c,c,1);const h=Jo(i,e,t,c,s);return o.set(h,a),Zi(h),o},decrypt(r,o){o=zo(r.length-16,o,!1);const a=r.subarray(0,-16),c=r.subarray(-16),h=Jo(i,e,t,a,s);if(!Wh(c,h))throw new Error("invalid tag");return o.set(r.subarray(0,-16)),i(e,t,o,o,1),Zi(h),o}}),Zo=Jh({blockSize:64,nonceLength:12,tagLength:16},ul(cl));class Yo extends tr{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,nn(e);const s=bi(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,o=new Uint8Array(r);o.set(s.length>r?e.create().update(s).digest():s);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return _i(this),this.iHash.update(e),this}digestInto(e){_i(this),wi(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:s,finished:r,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=r,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=t._cloneInto(e.oHash),e.iHash=s._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hn=(i,e,t)=>new Yo(i,e).update(t).digest();hn.create=(i,e)=>new Yo(i,e);function dl(i,e,t){return nn(i),t===void 0&&(t=new Uint8Array(i.outputLen)),hn(i,bi(t),bi(e))}const ur=new Uint8Array([0]),Qo=new Uint8Array;function pl(i,e,t,s=32){if(nn(i),Oi(s),s>255*i.outputLen)throw new Error("Length should be <= 255*HashLen");const r=Math.ceil(s/i.outputLen);t===void 0&&(t=Qo);const o=new Uint8Array(r*i.outputLen),a=hn.create(i,e),c=a._cloneInto(),h=new Uint8Array(a.outputLen);for(let u=0;u<r;u++)ur[0]=u+1,c.update(u===0?Qo:h).update(t).update(ur).digestInto(h),o.set(h,i.outputLen*u),a._cloneInto(c);return a.destroy(),c.destroy(),h.fill(0),ur.fill(0),o.slice(0,s)}const gl=(i,e,t,s,r)=>pl(i,dl(i,e,t),s,r);function fl(i,e,t,s){if(typeof i.setBigUint64=="function")return i.setBigUint64(e,t,s);const r=BigInt(32),o=BigInt(4294967295),a=Number(t>>r&o),c=Number(t&o),h=s?4:0,u=s?0:4;i.setUint32(e+h,a,s),i.setUint32(e+u,c,s)}function yl(i,e,t){return i&e^~i&t}function ml(i,e,t){return i&e^i&t^e&t}class wl extends tr{constructor(e,t,s,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=s,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=qe(this.buffer)}update(e){_i(this);const{view:t,buffer:s,blockLen:r}=this;e=bi(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(r-this.pos,o-a);if(c===r){const h=qe(e);for(;r<=o-a;a+=r)this.process(h,a);continue}s.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){_i(this),rn(e,this),this.finished=!0;const{buffer:t,view:s,blockLen:r,isLE:o}=this;let{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>r-a&&(this.process(s,0),a=0);for(let p=a;p<r;p++)t[p]=0;fl(s,r-8,BigInt(this.length*8),o),this.process(s,0);const c=qe(e),h=this.outputLen;if(h%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=h/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let p=0;p<u;p++)c.setUint32(4*p,d[p],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:s,length:r,finished:o,destroyed:a,pos:c}=this;return e.length=r,e.pos=c,e.finished=o,e.destroyed=a,r%t&&e.buffer.set(s),e}}const _l=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),xi=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ii=new Uint32Array(64);class vl extends wl{constructor(){super(64,32,8,!1),this.A=xi[0]|0,this.B=xi[1]|0,this.C=xi[2]|0,this.D=xi[3]|0,this.E=xi[4]|0,this.F=xi[5]|0,this.G=xi[6]|0,this.H=xi[7]|0}get(){const{A:e,B:t,C:s,D:r,E:o,F:a,G:c,H:h}=this;return[e,t,s,r,o,a,c,h]}set(e,t,s,r,o,a,c,h){this.A=e|0,this.B=t|0,this.C=s|0,this.D=r|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=h|0}process(e,t){for(let p=0;p<16;p++,t+=4)Ii[p]=e.getUint32(t,!1);for(let p=16;p<64;p++){const f=Ii[p-15],v=Ii[p-2],w=Fe(f,7)^Fe(f,18)^f>>>3,b=Fe(v,17)^Fe(v,19)^v>>>10;Ii[p]=b+Ii[p-7]+w+Ii[p-16]|0}let{A:s,B:r,C:o,D:a,E:c,F:h,G:u,H:d}=this;for(let p=0;p<64;p++){const f=Fe(c,6)^Fe(c,11)^Fe(c,25),v=d+f+yl(c,h,u)+_l[p]+Ii[p]|0,w=(Fe(s,2)^Fe(s,13)^Fe(s,22))+ml(s,r,o)|0;d=u,u=h,h=c,c=a+v|0,a=o,o=r,r=s,s=v+w|0}s=s+this.A|0,r=r+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,h=h+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(s,r,o,a,c,h,u,d)}roundClean(){Ii.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Rs=xo(()=>new vl);const ln=BigInt(0),un=BigInt(1),bl=BigInt(2);function Ri(i){return i instanceof Uint8Array||ArrayBuffer.isView(i)&&i.constructor.name==="Uint8Array"}function Ns(i){if(!Ri(i))throw new Error("Uint8Array expected")}function Yi(i,e){if(typeof e!="boolean")throw new Error(i+" boolean expected, got "+e)}const El=Array.from({length:256},(i,e)=>e.toString(16).padStart(2,"0"));function Qi(i){Ns(i);let e="";for(let t=0;t<i.length;t++)e+=El[i[t]];return e}function Xi(i){const e=i.toString(16);return e.length&1?"0"+e:e}function dr(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);return i===""?ln:BigInt("0x"+i)}const si={_0:48,_9:57,A:65,F:70,a:97,f:102};function Xo(i){if(i>=si._0&&i<=si._9)return i-si._0;if(i>=si.A&&i<=si.F)return i-(si.A-10);if(i>=si.a&&i<=si.f)return i-(si.a-10)}function es(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);const e=i.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const s=new Uint8Array(t);for(let r=0,o=0;r<t;r++,o+=2){const a=Xo(i.charCodeAt(o)),c=Xo(i.charCodeAt(o+1));if(a===void 0||c===void 0){const h=i[o]+i[o+1];throw new Error('hex string expected, got non-hex character "'+h+'" at index '+o)}s[r]=a*16+c}return s}function Ni(i){return dr(Qi(i))}function Ts(i){return Ns(i),dr(Qi(Uint8Array.from(i).reverse()))}function ts(i,e){return es(i.toString(16).padStart(e*2,"0"))}function dn(i,e){return ts(i,e).reverse()}function xl(i){return es(Xi(i))}function mt(i,e,t){let s;if(typeof e=="string")try{s=es(e)}catch(o){throw new Error(i+" must be hex string or Uint8Array, cause: "+o)}else if(Ri(e))s=Uint8Array.from(e);else throw new Error(i+" must be hex string or Uint8Array");const r=s.length;if(typeof t=="number"&&r!==t)throw new Error(i+" of length "+t+" expected, got "+r);return s}function $s(...i){let e=0;for(let s=0;s<i.length;s++){const r=i[s];Ns(r),e+=r.length}const t=new Uint8Array(e);for(let s=0,r=0;s<i.length;s++){const o=i[s];t.set(o,r),r+=o.length}return t}function Il(i,e){if(i.length!==e.length)return!1;let t=0;for(let s=0;s<i.length;s++)t|=i[s]^e[s];return t===0}function Pl(i){if(typeof i!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(i))}const pr=i=>typeof i=="bigint"&&ln<=i;function pn(i,e,t){return pr(i)&&pr(e)&&pr(t)&&e<=i&&i<t}function ni(i,e,t,s){if(!pn(e,t,s))throw new Error("expected valid "+i+": "+t+" <= n < "+s+", got "+e)}function ea(i){let e;for(e=0;i>ln;i>>=un,e+=1);return e}function Sl(i,e){return i>>BigInt(e)&un}function Ol(i,e,t){return i|(t?un:ln)<<BigInt(e)}const gr=i=>(bl<<BigInt(i-1))-un,fr=i=>new Uint8Array(i),ta=i=>Uint8Array.from(i);function ia(i,e,t){if(typeof i!="number"||i<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let s=fr(i),r=fr(i),o=0;const a=()=>{s.fill(1),r.fill(0),o=0},c=(...d)=>t(r,s,...d),h=(d=fr())=>{r=c(ta([0]),d),s=c(),d.length!==0&&(r=c(ta([1]),d),s=c())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const p=[];for(;d<e;){s=c();const f=s.slice();p.push(f),d+=s.length}return $s(...p)};return(d,p)=>{a(),h(d);let f;for(;!(f=p(u()));)h();return a(),f}}const Al={bigint:i=>typeof i=="bigint",function:i=>typeof i=="function",boolean:i=>typeof i=="boolean",string:i=>typeof i=="string",stringOrUint8Array:i=>typeof i=="string"||Ri(i),isSafeInteger:i=>Number.isSafeInteger(i),array:i=>Array.isArray(i),field:(i,e)=>e.Fp.isValid(i),hash:i=>typeof i=="function"&&Number.isSafeInteger(i.outputLen)};function is(i,e,t={}){const s=(r,o,a)=>{const c=Al[o];if(typeof c!="function")throw new Error("invalid validator function");const h=i[r];if(!(a&&h===void 0)&&!c(h,i))throw new Error("param "+String(r)+" is invalid. Expected "+o+", got "+h)};for(const[r,o]of Object.entries(e))s(r,o,!1);for(const[r,o]of Object.entries(t))s(r,o,!0);return i}const Cl=()=>{throw new Error("not implemented")};function yr(i){const e=new WeakMap;return(t,...s)=>{const r=e.get(t);if(r!==void 0)return r;const o=i(t,...s);return e.set(t,o),o}}var Rl=Object.freeze({__proto__:null,isBytes:Ri,abytes:Ns,abool:Yi,bytesToHex:Qi,numberToHexUnpadded:Xi,hexToNumber:dr,hexToBytes:es,bytesToNumberBE:Ni,bytesToNumberLE:Ts,numberToBytesBE:ts,numberToBytesLE:dn,numberToVarBytesBE:xl,ensureBytes:mt,concatBytes:$s,equalBytes:Il,utf8ToBytes:Pl,inRange:pn,aInRange:ni,bitLen:ea,bitGet:Sl,bitSet:Ol,bitMask:gr,createHmacDrbg:ia,validateObject:is,notImplemented:Cl,memoized:yr});const Ve=BigInt(0),je=BigInt(1),Ti=BigInt(2),Nl=BigInt(3),mr=BigInt(4),sa=BigInt(5),na=BigInt(8);function dt(i,e){const t=i%e;return t>=Ve?t:e+t}function ra(i,e,t){if(e<Ve)throw new Error("invalid exponent, negatives unsupported");if(t<=Ve)throw new Error("invalid modulus");if(t===je)return Ve;let s=je;for(;e>Ve;)e&je&&(s=s*i%t),i=i*i%t,e>>=je;return s}function jt(i,e,t){let s=i;for(;e-- >Ve;)s*=s,s%=t;return s}function wr(i,e){if(i===Ve)throw new Error("invert: expected non-zero number");if(e<=Ve)throw new Error("invert: expected positive modulus, got "+e);let t=dt(i,e),s=e,r=Ve,o=je;for(;t!==Ve;){const a=s/t,c=s%t,h=r-o*a;s=t,t=c,r=o,o=h}if(s!==je)throw new Error("invert: does not exist");return dt(r,e)}function Tl(i){const e=(i-je)/Ti;let t,s,r;for(t=i-je,s=0;t%Ti===Ve;t/=Ti,s++);for(r=Ti;r<i&&ra(r,e,i)!==i-je;r++)if(r>1e3)throw new Error("Cannot find square root: likely non-prime P");if(s===1){const a=(i+je)/mr;return function(c,h){const u=c.pow(h,a);if(!c.eql(c.sqr(u),h))throw new Error("Cannot find square root");return u}}const o=(t+je)/Ti;return function(a,c){if(a.pow(c,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let h=s,u=a.pow(a.mul(a.ONE,r),t),d=a.pow(c,o),p=a.pow(c,t);for(;!a.eql(p,a.ONE);){if(a.eql(p,a.ZERO))return a.ZERO;let f=1;for(let w=a.sqr(p);f<h&&!a.eql(w,a.ONE);f++)w=a.sqr(w);const v=a.pow(u,je<<BigInt(h-f-1));u=a.sqr(v),d=a.mul(d,v),p=a.mul(p,u),h=f}return d}}function $l(i){if(i%mr===Nl){const e=(i+je)/mr;return function(t,s){const r=t.pow(s,e);if(!t.eql(t.sqr(r),s))throw new Error("Cannot find square root");return r}}if(i%na===sa){const e=(i-sa)/na;return function(t,s){const r=t.mul(s,Ti),o=t.pow(r,e),a=t.mul(s,o),c=t.mul(t.mul(a,Ti),o),h=t.mul(a,t.sub(c,t.ONE));if(!t.eql(t.sqr(h),s))throw new Error("Cannot find square root");return h}}return Tl(i)}const jl=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Dl(i){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=jl.reduce((s,r)=>(s[r]="function",s),e);return is(i,t)}function ql(i,e,t){if(t<Ve)throw new Error("invalid exponent, negatives unsupported");if(t===Ve)return i.ONE;if(t===je)return e;let s=i.ONE,r=e;for(;t>Ve;)t&je&&(s=i.mul(s,r)),r=i.sqr(r),t>>=je;return s}function Fl(i,e){const t=new Array(e.length),s=e.reduce((o,a,c)=>i.is0(a)?o:(t[c]=o,i.mul(o,a)),i.ONE),r=i.inv(s);return e.reduceRight((o,a,c)=>i.is0(a)?o:(t[c]=i.mul(o,t[c]),i.mul(o,a)),r),t}function oa(i,e){const t=e!==void 0?e:i.toString(2).length,s=Math.ceil(t/8);return{nBitLength:t,nByteLength:s}}function aa(i,e,t=!1,s={}){if(i<=Ve)throw new Error("invalid field: expected ORDER > 0, got "+i);const{nBitLength:r,nByteLength:o}=oa(i,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const c=Object.freeze({ORDER:i,isLE:t,BITS:r,BYTES:o,MASK:gr(r),ZERO:Ve,ONE:je,create:h=>dt(h,i),isValid:h=>{if(typeof h!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof h);return Ve<=h&&h<i},is0:h=>h===Ve,isOdd:h=>(h&je)===je,neg:h=>dt(-h,i),eql:(h,u)=>h===u,sqr:h=>dt(h*h,i),add:(h,u)=>dt(h+u,i),sub:(h,u)=>dt(h-u,i),mul:(h,u)=>dt(h*u,i),pow:(h,u)=>ql(c,h,u),div:(h,u)=>dt(h*wr(u,i),i),sqrN:h=>h*h,addN:(h,u)=>h+u,subN:(h,u)=>h-u,mulN:(h,u)=>h*u,inv:h=>wr(h,i),sqrt:s.sqrt||(h=>(a||(a=$l(i)),a(c,h))),invertBatch:h=>Fl(c,h),cmov:(h,u,d)=>d?u:h,toBytes:h=>t?dn(h,o):ts(h,o),fromBytes:h=>{if(h.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+h.length);return t?Ts(h):Ni(h)}});return Object.freeze(c)}function ca(i){if(typeof i!="bigint")throw new Error("field order must be bigint");const e=i.toString(2).length;return Math.ceil(e/8)}function ha(i){const e=ca(i);return e+Math.ceil(e/2)}function kl(i,e,t=!1){const s=i.length,r=ca(e),o=ha(e);if(s<16||s<o||s>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+s);const a=t?Ts(i):Ni(i),c=dt(a,e-je)+je;return t?dn(c,r):ts(c,r)}const la=BigInt(0),gn=BigInt(1);function _r(i,e){const t=e.negate();return i?t:e}function ua(i,e){if(!Number.isSafeInteger(i)||i<=0||i>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+i)}function vr(i,e){ua(i,e);const t=Math.ceil(e/i)+1,s=2**(i-1);return{windows:t,windowSize:s}}function Ll(i,e){if(!Array.isArray(i))throw new Error("array expected");i.forEach((t,s)=>{if(!(t instanceof e))throw new Error("invalid point at index "+s)})}function Bl(i,e){if(!Array.isArray(i))throw new Error("array of scalars expected");i.forEach((t,s)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+s)})}const br=new WeakMap,da=new WeakMap;function Er(i){return da.get(i)||1}function Ul(i,e){return{constTimeNegate:_r,hasPrecomputes(t){return Er(t)!==1},unsafeLadder(t,s,r=i.ZERO){let o=t;for(;s>la;)s&gn&&(r=r.add(o)),o=o.double(),s>>=gn;return r},precomputeWindow(t,s){const{windows:r,windowSize:o}=vr(s,e),a=[];let c=t,h=c;for(let u=0;u<r;u++){h=c,a.push(h);for(let d=1;d<o;d++)h=h.add(c),a.push(h);c=h.double()}return a},wNAF(t,s,r){const{windows:o,windowSize:a}=vr(t,e);let c=i.ZERO,h=i.BASE;const u=BigInt(2**t-1),d=2**t,p=BigInt(t);for(let f=0;f<o;f++){const v=f*a;let w=Number(r&u);r>>=p,w>a&&(w-=d,r+=gn);const b=v,_=v+Math.abs(w)-1,x=f%2!==0,E=w<0;w===0?h=h.add(_r(x,s[b])):c=c.add(_r(E,s[_]))}return{p:c,f:h}},wNAFUnsafe(t,s,r,o=i.ZERO){const{windows:a,windowSize:c}=vr(t,e),h=BigInt(2**t-1),u=2**t,d=BigInt(t);for(let p=0;p<a;p++){const f=p*c;if(r===la)break;let v=Number(r&h);if(r>>=d,v>c&&(v-=u,r+=gn),v===0)continue;let w=s[f+Math.abs(v)-1];v<0&&(w=w.negate()),o=o.add(w)}return o},getPrecomputes(t,s,r){let o=br.get(s);return o||(o=this.precomputeWindow(s,t),t!==1&&br.set(s,r(o))),o},wNAFCached(t,s,r){const o=Er(t);return this.wNAF(o,this.getPrecomputes(o,t,r),s)},wNAFCachedUnsafe(t,s,r,o){const a=Er(t);return a===1?this.unsafeLadder(t,s,o):this.wNAFUnsafe(a,this.getPrecomputes(a,t,r),s,o)},setWindowSize(t,s){ua(s,e),da.set(t,s),br.delete(t)}}}function Ml(i,e,t,s){if(Ll(t,i),Bl(s,e),t.length!==s.length)throw new Error("arrays of points and scalars must have equal length");const r=i.ZERO,o=ea(BigInt(t.length)),a=o>12?o-3:o>4?o-2:o?2:1,c=(1<<a)-1,h=new Array(c+1).fill(r),u=Math.floor((e.BITS-1)/a)*a;let d=r;for(let p=u;p>=0;p-=a){h.fill(r);for(let v=0;v<s.length;v++){const w=s[v],b=Number(w>>BigInt(p)&BigInt(c));h[b]=h[b].add(t[v])}let f=r;for(let v=h.length-1,w=r;v>0;v--)w=w.add(h[v]),f=f.add(w);if(d=d.add(f),p!==0)for(let v=0;v<a;v++)d=d.double()}return d}function pa(i){return Dl(i.Fp),is(i,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...oa(i.n,i.nBitLength),...i,p:i.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const ss=BigInt(0),xr=BigInt(1);function zl(i){return is(i,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...i})}function Hl(i){const e=zl(i),{P:t}=e,s=E=>dt(E,t),r=e.montgomeryBits,o=Math.ceil(r/8),a=e.nByteLength,c=e.adjustScalarBytes||(E=>E),h=e.powPminus2||(E=>ra(E,t-BigInt(2),t));function u(E,R,T){const k=s(E*(R-T));return R=s(R-k),T=s(T+k),[R,T]}const d=(e.a-BigInt(2))/BigInt(4);function p(E,R){ni("u",E,ss,t),ni("scalar",R,ss,t);const T=R,k=E;let O=xr,D=ss,U=E,P=xr,Z=ss,H;for(let X=BigInt(r-1);X>=ss;X--){const A=T>>X&xr;Z^=A,H=u(Z,O,U),O=H[0],U=H[1],H=u(Z,D,P),D=H[0],P=H[1],Z=A;const F=O+D,q=s(F*F),M=O-D,K=s(M*M),j=q-K,Y=U+P,re=U-P,oe=s(re*F),Oe=s(Y*M),me=oe+Oe,Be=oe-Oe;U=s(me*me),P=s(k*s(Be*Be)),O=s(q*K),D=s(j*(q+s(d*j)))}H=u(Z,O,U),O=H[0],U=H[1],H=u(Z,D,P),D=H[0],P=H[1];const V=h(D);return s(O*V)}function f(E){return dn(s(E),o)}function v(E){const R=mt("u coordinate",E,o);return a===32&&(R[31]&=127),Ts(R)}function w(E){const R=mt("scalar",E),T=R.length;if(T!==o&&T!==a){let k=""+o+" or "+a;throw new Error("invalid scalar, expected "+k+" bytes, got "+T)}return Ts(c(R))}function b(E,R){const T=v(R),k=w(E),O=p(T,k);if(O===ss)throw new Error("invalid private or public key received");return f(O)}const _=f(e.Gu);function x(E){return b(E,_)}return{scalarMult:b,scalarMultBase:x,getSharedSecret:(E,R)=>b(E,R),getPublicKey:E=>x(E),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:_}}const Ir=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const Kl=BigInt(1),ga=BigInt(2),Vl=BigInt(3),Gl=BigInt(5);BigInt(8);function Wl(i){const e=BigInt(10),t=BigInt(20),s=BigInt(40),r=BigInt(80),o=Ir,a=i*i%o*i%o,c=jt(a,ga,o)*a%o,h=jt(c,Kl,o)*i%o,u=jt(h,Gl,o)*h%o,d=jt(u,e,o)*u%o,p=jt(d,t,o)*d%o,f=jt(p,s,o)*p%o,v=jt(f,r,o)*f%o,w=jt(v,r,o)*f%o,b=jt(w,e,o)*u%o;return{pow_p_5_8:jt(b,ga,o)*i%o,b2:a}}function Jl(i){return i[0]&=248,i[31]&=127,i[31]|=64,i}const Pr=Hl({P:Ir,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:i=>{const e=Ir,{pow_p_5_8:t,b2:s}=Wl(i);return dt(jt(t,Vl,e)*s,e)},adjustScalarBytes:Jl,randomBytes:Wi});function fa(i){i.lowS!==void 0&&Yi("lowS",i.lowS),i.prehash!==void 0&&Yi("prehash",i.prehash)}function Zl(i){const e=pa(i);is(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:s,a:r}=e;if(t){if(!s.eql(r,s.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Yl,hexToBytes:Ql}=Rl;class Xl extends Error{constructor(e=""){super(e)}}const ri={Err:Xl,_tlv:{encode:(i,e)=>{const{Err:t}=ri;if(i<0||i>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const s=e.length/2,r=Xi(s);if(r.length/2&128)throw new t("tlv.encode: long form length too big");const o=s>127?Xi(r.length/2|128):"";return Xi(i)+o+r+e},decode(i,e){const{Err:t}=ri;let s=0;if(i<0||i>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[s++]!==i)throw new t("tlv.decode: wrong tlv");const r=e[s++],o=!!(r&128);let a=0;if(!o)a=r;else{const h=r&127;if(!h)throw new t("tlv.decode(long): indefinite length not supported");if(h>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(s,s+h);if(u.length!==h)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const d of u)a=a<<8|d;if(s+=h,a<128)throw new t("tlv.decode(long): not minimal encoding")}const c=e.subarray(s,s+a);if(c.length!==a)throw new t("tlv.decode: wrong value length");return{v:c,l:e.subarray(s+a)}}},_int:{encode(i){const{Err:e}=ri;if(i<oi)throw new e("integer: negative integers are not allowed");let t=Xi(i);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(i){const{Err:e}=ri;if(i[0]&128)throw new e("invalid signature integer: negative");if(i[0]===0&&!(i[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Yl(i)}},toSig(i){const{Err:e,_int:t,_tlv:s}=ri,r=typeof i=="string"?Ql(i):i;Ns(r);const{v:o,l:a}=s.decode(48,r);if(a.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:h}=s.decode(2,o),{v:u,l:d}=s.decode(2,h);if(d.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(c),s:t.decode(u)}},hexFromSig(i){const{_tlv:e,_int:t}=ri,s=e.encode(2,t.encode(i.r)),r=e.encode(2,t.encode(i.s)),o=s+r;return e.encode(48,o)}},oi=BigInt(0),Ge=BigInt(1);BigInt(2);const ya=BigInt(3);BigInt(4);function eu(i){const e=Zl(i),{Fp:t}=e,s=aa(e.n,e.nBitLength),r=e.toBytes||((b,_,x)=>{const E=_.toAffine();return $s(Uint8Array.from([4]),t.toBytes(E.x),t.toBytes(E.y))}),o=e.fromBytes||(b=>{const _=b.subarray(1),x=t.fromBytes(_.subarray(0,t.BYTES)),E=t.fromBytes(_.subarray(t.BYTES,2*t.BYTES));return{x,y:E}});function a(b){const{a:_,b:x}=e,E=t.sqr(b),R=t.mul(E,b);return t.add(t.add(R,t.mul(b,_)),x)}if(!t.eql(t.sqr(e.Gy),a(e.Gx)))throw new Error("bad generator point: equation left != right");function c(b){return pn(b,Ge,e.n)}function h(b){const{allowedPrivateKeyLengths:_,nByteLength:x,wrapPrivateKey:E,n:R}=e;if(_&&typeof b!="bigint"){if(Ri(b)&&(b=Qi(b)),typeof b!="string"||!_.includes(b.length))throw new Error("invalid private key");b=b.padStart(x*2,"0")}let T;try{T=typeof b=="bigint"?b:Ni(mt("private key",b,x))}catch{throw new Error("invalid private key, expected hex or "+x+" bytes, got "+typeof b)}return E&&(T=dt(T,R)),ni("private key",T,Ge,R),T}function u(b){if(!(b instanceof f))throw new Error("ProjectivePoint expected")}const d=yr((b,_)=>{const{px:x,py:E,pz:R}=b;if(t.eql(R,t.ONE))return{x,y:E};const T=b.is0();_==null&&(_=T?t.ONE:t.inv(R));const k=t.mul(x,_),O=t.mul(E,_),D=t.mul(R,_);if(T)return{x:t.ZERO,y:t.ZERO};if(!t.eql(D,t.ONE))throw new Error("invZ was invalid");return{x:k,y:O}}),p=yr(b=>{if(b.is0()){if(e.allowInfinityPoint&&!t.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:_,y:x}=b.toAffine();if(!t.isValid(_)||!t.isValid(x))throw new Error("bad point: x or y not FE");const E=t.sqr(x),R=a(_);if(!t.eql(E,R))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class f{constructor(_,x,E){if(this.px=_,this.py=x,this.pz=E,_==null||!t.isValid(_))throw new Error("x required");if(x==null||!t.isValid(x))throw new Error("y required");if(E==null||!t.isValid(E))throw new Error("z required");Object.freeze(this)}static fromAffine(_){const{x,y:E}=_||{};if(!_||!t.isValid(x)||!t.isValid(E))throw new Error("invalid affine point");if(_ instanceof f)throw new Error("projective point not allowed");const R=T=>t.eql(T,t.ZERO);return R(x)&&R(E)?f.ZERO:new f(x,E,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(_){const x=t.invertBatch(_.map(E=>E.pz));return _.map((E,R)=>E.toAffine(x[R])).map(f.fromAffine)}static fromHex(_){const x=f.fromAffine(o(mt("pointHex",_)));return x.assertValidity(),x}static fromPrivateKey(_){return f.BASE.multiply(h(_))}static msm(_,x){return Ml(f,s,_,x)}_setWindowSize(_){w.setWindowSize(this,_)}assertValidity(){p(this)}hasEvenY(){const{y:_}=this.toAffine();if(t.isOdd)return!t.isOdd(_);throw new Error("Field doesn't support isOdd")}equals(_){u(_);const{px:x,py:E,pz:R}=this,{px:T,py:k,pz:O}=_,D=t.eql(t.mul(x,O),t.mul(T,R)),U=t.eql(t.mul(E,O),t.mul(k,R));return D&&U}negate(){return new f(this.px,t.neg(this.py),this.pz)}double(){const{a:_,b:x}=e,E=t.mul(x,ya),{px:R,py:T,pz:k}=this;let O=t.ZERO,D=t.ZERO,U=t.ZERO,P=t.mul(R,R),Z=t.mul(T,T),H=t.mul(k,k),V=t.mul(R,T);return V=t.add(V,V),U=t.mul(R,k),U=t.add(U,U),O=t.mul(_,U),D=t.mul(E,H),D=t.add(O,D),O=t.sub(Z,D),D=t.add(Z,D),D=t.mul(O,D),O=t.mul(V,O),U=t.mul(E,U),H=t.mul(_,H),V=t.sub(P,H),V=t.mul(_,V),V=t.add(V,U),U=t.add(P,P),P=t.add(U,P),P=t.add(P,H),P=t.mul(P,V),D=t.add(D,P),H=t.mul(T,k),H=t.add(H,H),P=t.mul(H,V),O=t.sub(O,P),U=t.mul(H,Z),U=t.add(U,U),U=t.add(U,U),new f(O,D,U)}add(_){u(_);const{px:x,py:E,pz:R}=this,{px:T,py:k,pz:O}=_;let D=t.ZERO,U=t.ZERO,P=t.ZERO;const Z=e.a,H=t.mul(e.b,ya);let V=t.mul(x,T),X=t.mul(E,k),A=t.mul(R,O),F=t.add(x,E),q=t.add(T,k);F=t.mul(F,q),q=t.add(V,X),F=t.sub(F,q),q=t.add(x,R);let M=t.add(T,O);return q=t.mul(q,M),M=t.add(V,A),q=t.sub(q,M),M=t.add(E,R),D=t.add(k,O),M=t.mul(M,D),D=t.add(X,A),M=t.sub(M,D),P=t.mul(Z,q),D=t.mul(H,A),P=t.add(D,P),D=t.sub(X,P),P=t.add(X,P),U=t.mul(D,P),X=t.add(V,V),X=t.add(X,V),A=t.mul(Z,A),q=t.mul(H,q),X=t.add(X,A),A=t.sub(V,A),A=t.mul(Z,A),q=t.add(q,A),V=t.mul(X,q),U=t.add(U,V),V=t.mul(M,q),D=t.mul(F,D),D=t.sub(D,V),V=t.mul(F,X),P=t.mul(M,P),P=t.add(P,V),new f(D,U,P)}subtract(_){return this.add(_.negate())}is0(){return this.equals(f.ZERO)}wNAF(_){return w.wNAFCached(this,_,f.normalizeZ)}multiplyUnsafe(_){const{endo:x,n:E}=e;ni("scalar",_,oi,E);const R=f.ZERO;if(_===oi)return R;if(this.is0()||_===Ge)return this;if(!x||w.hasPrecomputes(this))return w.wNAFCachedUnsafe(this,_,f.normalizeZ);let{k1neg:T,k1:k,k2neg:O,k2:D}=x.splitScalar(_),U=R,P=R,Z=this;for(;k>oi||D>oi;)k&Ge&&(U=U.add(Z)),D&Ge&&(P=P.add(Z)),Z=Z.double(),k>>=Ge,D>>=Ge;return T&&(U=U.negate()),O&&(P=P.negate()),P=new f(t.mul(P.px,x.beta),P.py,P.pz),U.add(P)}multiply(_){const{endo:x,n:E}=e;ni("scalar",_,Ge,E);let R,T;if(x){const{k1neg:k,k1:O,k2neg:D,k2:U}=x.splitScalar(_);let{p:P,f:Z}=this.wNAF(O),{p:H,f:V}=this.wNAF(U);P=w.constTimeNegate(k,P),H=w.constTimeNegate(D,H),H=new f(t.mul(H.px,x.beta),H.py,H.pz),R=P.add(H),T=Z.add(V)}else{const{p:k,f:O}=this.wNAF(_);R=k,T=O}return f.normalizeZ([R,T])[0]}multiplyAndAddUnsafe(_,x,E){const R=f.BASE,T=(O,D)=>D===oi||D===Ge||!O.equals(R)?O.multiplyUnsafe(D):O.multiply(D),k=T(this,x).add(T(_,E));return k.is0()?void 0:k}toAffine(_){return d(this,_)}isTorsionFree(){const{h:_,isTorsionFree:x}=e;if(_===Ge)return!0;if(x)return x(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:_,clearCofactor:x}=e;return _===Ge?this:x?x(f,this):this.multiplyUnsafe(e.h)}toRawBytes(_=!0){return Yi("isCompressed",_),this.assertValidity(),r(f,this,_)}toHex(_=!0){return Yi("isCompressed",_),Qi(this.toRawBytes(_))}}f.BASE=new f(e.Gx,e.Gy,t.ONE),f.ZERO=new f(t.ZERO,t.ONE,t.ZERO);const v=e.nBitLength,w=Ul(f,e.endo?Math.ceil(v/2):v);return{CURVE:e,ProjectivePoint:f,normPrivateKeyToScalar:h,weierstrassEquation:a,isWithinCurveOrder:c}}function tu(i){const e=pa(i);return is(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function iu(i){const e=tu(i),{Fp:t,n:s}=e,r=t.BYTES+1,o=2*t.BYTES+1;function a(A){return dt(A,s)}function c(A){return wr(A,s)}const{ProjectivePoint:h,normPrivateKeyToScalar:u,weierstrassEquation:d,isWithinCurveOrder:p}=eu({...e,toBytes(A,F,q){const M=F.toAffine(),K=t.toBytes(M.x),j=$s;return Yi("isCompressed",q),q?j(Uint8Array.from([F.hasEvenY()?2:3]),K):j(Uint8Array.from([4]),K,t.toBytes(M.y))},fromBytes(A){const F=A.length,q=A[0],M=A.subarray(1);if(F===r&&(q===2||q===3)){const K=Ni(M);if(!pn(K,Ge,t.ORDER))throw new Error("Point is not on curve");const j=d(K);let Y;try{Y=t.sqrt(j)}catch(oe){const Oe=oe instanceof Error?": "+oe.message:"";throw new Error("Point is not on curve"+Oe)}const re=(Y&Ge)===Ge;return(q&1)===1!==re&&(Y=t.neg(Y)),{x:K,y:Y}}else if(F===o&&q===4){const K=t.fromBytes(M.subarray(0,t.BYTES)),j=t.fromBytes(M.subarray(t.BYTES,2*t.BYTES));return{x:K,y:j}}else{const K=r,j=o;throw new Error("invalid Point, expected length of "+K+", or uncompressed "+j+", got "+F)}}}),f=A=>Qi(ts(A,e.nByteLength));function v(A){const F=s>>Ge;return A>F}function w(A){return v(A)?a(-A):A}const b=(A,F,q)=>Ni(A.slice(F,q));class _{constructor(F,q,M){this.r=F,this.s=q,this.recovery=M,this.assertValidity()}static fromCompact(F){const q=e.nByteLength;return F=mt("compactSignature",F,q*2),new _(b(F,0,q),b(F,q,2*q))}static fromDER(F){const{r:q,s:M}=ri.toSig(mt("DER",F));return new _(q,M)}assertValidity(){ni("r",this.r,Ge,s),ni("s",this.s,Ge,s)}addRecoveryBit(F){return new _(this.r,this.s,F)}recoverPublicKey(F){const{r:q,s:M,recovery:K}=this,j=O(mt("msgHash",F));if(K==null||![0,1,2,3].includes(K))throw new Error("recovery id invalid");const Y=K===2||K===3?q+e.n:q;if(Y>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const re=K&1?"03":"02",oe=h.fromHex(re+f(Y)),Oe=c(Y),me=a(-j*Oe),Be=a(M*Oe),Ye=h.BASE.multiplyAndAddUnsafe(oe,me,Be);if(!Ye)throw new Error("point at infinify");return Ye.assertValidity(),Ye}hasHighS(){return v(this.s)}normalizeS(){return this.hasHighS()?new _(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return es(this.toDERHex())}toDERHex(){return ri.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return es(this.toCompactHex())}toCompactHex(){return f(this.r)+f(this.s)}}const x={isValidPrivateKey(A){try{return u(A),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const A=ha(e.n);return kl(e.randomBytes(A),e.n)},precompute(A=8,F=h.BASE){return F._setWindowSize(A),F.multiply(BigInt(3)),F}};function E(A,F=!0){return h.fromPrivateKey(A).toRawBytes(F)}function R(A){const F=Ri(A),q=typeof A=="string",M=(F||q)&&A.length;return F?M===r||M===o:q?M===2*r||M===2*o:A instanceof h}function T(A,F,q=!0){if(R(A))throw new Error("first arg must be private key");if(!R(F))throw new Error("second arg must be public key");return h.fromHex(F).multiply(u(A)).toRawBytes(q)}const k=e.bits2int||function(A){if(A.length>8192)throw new Error("input is too large");const F=Ni(A),q=A.length*8-e.nBitLength;return q>0?F>>BigInt(q):F},O=e.bits2int_modN||function(A){return a(k(A))},D=gr(e.nBitLength);function U(A){return ni("num < 2^"+e.nBitLength,A,oi,D),ts(A,e.nByteLength)}function P(A,F,q=Z){if(["recovered","canonical"].some(Me=>Me in q))throw new Error("sign() legacy options not supported");const{hash:M,randomBytes:K}=e;let{lowS:j,prehash:Y,extraEntropy:re}=q;j==null&&(j=!0),A=mt("msgHash",A),fa(q),Y&&(A=mt("prehashed msgHash",M(A)));const oe=O(A),Oe=u(F),me=[U(Oe),U(oe)];if(re!=null&&re!==!1){const Me=re===!0?K(t.BYTES):re;me.push(mt("extraEntropy",Me))}const Be=$s(...me),Ye=oe;function ct(Me){const ze=k(Me);if(!p(ze))return;const Mi=c(ze),hi=h.BASE.multiply(ze).toAffine(),Qt=a(hi.x);if(Qt===oi)return;const li=a(Mi*a(Ye+Qt*Oe));if(li===oi)return;let ui=(hi.x===Qt?0:2)|Number(hi.y&Ge),qn=li;return j&&v(li)&&(qn=w(li),ui^=1),new _(Qt,qn,ui)}return{seed:Be,k2sig:ct}}const Z={lowS:e.lowS,prehash:!1},H={lowS:e.lowS,prehash:!1};function V(A,F,q=Z){const{seed:M,k2sig:K}=P(A,F,q),j=e;return ia(j.hash.outputLen,j.nByteLength,j.hmac)(M,K)}h.BASE._setWindowSize(8);function X(A,F,q,M=H){var li;const K=A;F=mt("msgHash",F),q=mt("publicKey",q);const{lowS:j,prehash:Y,format:re}=M;if(fa(M),"strict"in M)throw new Error("options.strict was renamed to lowS");if(re!==void 0&&re!=="compact"&&re!=="der")throw new Error("format must be compact or der");const oe=typeof K=="string"||Ri(K),Oe=!oe&&!re&&typeof K=="object"&&K!==null&&typeof K.r=="bigint"&&typeof K.s=="bigint";if(!oe&&!Oe)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let me,Be;try{if(Oe&&(me=new _(K.r,K.s)),oe){try{re!=="compact"&&(me=_.fromDER(K))}catch(ui){if(!(ui instanceof ri.Err))throw ui}!me&&re!=="der"&&(me=_.fromCompact(K))}Be=h.fromHex(q)}catch{return!1}if(!me||j&&me.hasHighS())return!1;Y&&(F=e.hash(F));const{r:Ye,s:ct}=me,Me=O(F),ze=c(ct),Mi=a(Me*ze),hi=a(Ye*ze),Qt=(li=h.BASE.multiplyAndAddUnsafe(Be,Mi,hi))==null?void 0:li.toAffine();return Qt?a(Qt.x)===Ye:!1}return{CURVE:e,getPublicKey:E,getSharedSecret:T,sign:V,verify:X,ProjectivePoint:h,Signature:_,utils:x}}function su(i){return{hash:i,hmac:(e,...t)=>hn(i,e,hh(...t)),randomBytes:Wi}}function nu(i,e){const t=s=>iu({...i,...su(s)});return{...t(e),create:t}}const ma=aa(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),ru=ma.create(BigInt("-3")),ou=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),au=nu({a:ru,b:ou,Fp:ma,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},Rs),wa="base10",lt="base16",Dt="base64pad",Pi="base64url",js="utf8",_a=0,ai=1,Ds=2,cu=0,va=1,qs=12,Sr=32;function hu(){const i=Pr.utils.randomPrivateKey(),e=Pr.getPublicKey(i);return{privateKey:(0,te.BB)(i,lt),publicKey:(0,te.BB)(e,lt)}}function Or(){const i=Wi(Sr);return(0,te.BB)(i,lt)}function lu(i,e){const t=Pr.getSharedSecret((0,te.mL)(i,lt),(0,te.mL)(e,lt)),s=gl(Rs,t,void 0,void 0,Sr);return(0,te.BB)(s,lt)}function fn(i){const e=Rs((0,te.mL)(i,lt));return(0,te.BB)(e,lt)}function Gt(i){const e=Rs((0,te.mL)(i,js));return(0,te.BB)(e,lt)}function ba(i){return(0,te.mL)(`${i}`,wa)}function $i(i){return Number((0,te.BB)(i,wa))}function Ea(i){return i.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function xa(i){const e=i.replace(/-/g,"+").replace(/_/g,"/"),t=(4-e.length%4)%4;return e+"=".repeat(t)}function uu(i){const e=ba(typeof i.type<"u"?i.type:_a);if($i(e)===ai&&typeof i.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");const t=typeof i.senderPublicKey<"u"?(0,te.mL)(i.senderPublicKey,lt):void 0,s=typeof i.iv<"u"?(0,te.mL)(i.iv,lt):Wi(qs),r=(0,te.mL)(i.symKey,lt),o=Zo(r,s).encrypt((0,te.mL)(i.message,js)),a=Ia({type:e,sealed:o,iv:s,senderPublicKey:t});return i.encoding===Pi?Ea(a):a}function du(i){const e=(0,te.mL)(i.symKey,lt),{sealed:t,iv:s}=Fs({encoded:i.encoded,encoding:i.encoding}),r=Zo(e,s).decrypt(t);if(r===null)throw new Error("Failed to decrypt");return(0,te.BB)(r,js)}function pu(i,e){const t=ba(Ds),s=Wi(qs),r=(0,te.mL)(i,js),o=Ia({type:t,sealed:r,iv:s});return e===Pi?Ea(o):o}function gu(i,e){const{sealed:t}=Fs({encoded:i,encoding:e});return(0,te.BB)(t,js)}function Ia(i){if($i(i.type)===Ds)return(0,te.BB)((0,te.zo)([i.type,i.sealed]),Dt);if($i(i.type)===ai){if(typeof i.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");return(0,te.BB)((0,te.zo)([i.type,i.senderPublicKey,i.iv,i.sealed]),Dt)}return(0,te.BB)((0,te.zo)([i.type,i.iv,i.sealed]),Dt)}function Fs(i){const e=(i.encoding||Dt)===Pi?xa(i.encoded):i.encoded,t=(0,te.mL)(e,Dt),s=t.slice(cu,va),r=va;if($i(s)===ai){const h=r+Sr,u=h+qs,d=t.slice(r,h),p=t.slice(h,u),f=t.slice(u);return{type:s,sealed:f,iv:p,senderPublicKey:d}}if($i(s)===Ds){const h=t.slice(r),u=Wi(qs);return{type:s,sealed:h,iv:u}}const o=r+qs,a=t.slice(r,o),c=t.slice(o);return{type:s,sealed:c,iv:a}}function fu(i,e){const t=Fs({encoded:i,encoding:e==null?void 0:e.encoding});return Pa({type:$i(t.type),senderPublicKey:typeof t.senderPublicKey<"u"?(0,te.BB)(t.senderPublicKey,lt):void 0,receiverPublicKey:e==null?void 0:e.receiverPublicKey})}function Pa(i){const e=(i==null?void 0:i.type)||_a;if(e===ai){if(typeof(i==null?void 0:i.senderPublicKey)>"u")throw new Error("missing sender public key");if(typeof(i==null?void 0:i.receiverPublicKey)>"u")throw new Error("missing receiver public key")}return{type:e,senderPublicKey:i==null?void 0:i.senderPublicKey,receiverPublicKey:i==null?void 0:i.receiverPublicKey}}function Sa(i){return i.type===ai&&typeof i.senderPublicKey=="string"&&typeof i.receiverPublicKey=="string"}function Oa(i){return i.type===Ds}function yu(i){const e=ae.from(i.x,"base64"),t=ae.from(i.y,"base64");return(0,te.zo)([new Uint8Array([4]),e,t])}function mu(i,e){const[t,s,r]=i.split("."),o=ae.from(xa(r),"base64");if(o.length!==64)throw new Error("Invalid signature length");const a=o.slice(0,32),c=o.slice(32,64),h=`${t}.${s}`,u=Rs(h),d=yu(e);if(!au.verify((0,te.zo)([a,c]),u,d))throw new Error("Invalid signature");return(0,He.xp)(i).payload}const wu="irn";function yn(i){return(i==null?void 0:i.relay)||{protocol:wu}}function ks(i){const e=Nt.iO[i];if(typeof e>"u")throw new Error(`Relay Protocol not supported: ${i}`);return e}function _u(i,e="-"){const t={},s="relay"+e;return Object.keys(i).forEach(r=>{if(r.startsWith(s)){const o=r.replace(s,""),a=i[r];t[o]=a}}),t}function Aa(i){if(!i.includes("wc:")){const u=er(i);u!=null&&u.includes("wc:")&&(i=u)}i=i.includes("wc://")?i.replace("wc://",""):i,i=i.includes("wc:")?i.replace("wc:",""):i;const e=i.indexOf(":"),t=i.indexOf("?")!==-1?i.indexOf("?"):void 0,s=i.substring(0,e),r=i.substring(e+1,t).split("@"),o=typeof t<"u"?i.substring(t):"",a=new URLSearchParams(o),c={};a.forEach((u,d)=>{c[d]=u});const h=typeof c.methods=="string"?c.methods.split(","):void 0;return{protocol:s,topic:vu(r[0]),version:parseInt(r[1],10),symKey:c.symKey,relay:_u(c),methods:h,expiryTimestamp:c.expiryTimestamp?parseInt(c.expiryTimestamp,10):void 0}}function vu(i){return i.startsWith("//")?i.substring(2):i}function bu(i,e="-"){const t="relay",s={};return Object.keys(i).forEach(r=>{const o=r,a=t+e+o;i[o]&&(s[a]=i[o])}),s}function Ca(i){const e=new URLSearchParams,t=bu(i.relay);Object.keys(t).sort().forEach(r=>{e.set(r,t[r])}),e.set("symKey",i.symKey),i.expiryTimestamp&&e.set("expiryTimestamp",i.expiryTimestamp.toString()),i.methods&&e.set("methods",i.methods.join(","));const s=e.toString();return`${i.protocol}:${i.topic}@${i.version}?${s}`}function mn(i,e,t){return`${i}?wc_ev=${t}&topic=${e}`}var Eu=Object.defineProperty,xu=Object.defineProperties,Iu=Object.getOwnPropertyDescriptors,Ra=Object.getOwnPropertySymbols,Pu=Object.prototype.hasOwnProperty,Su=Object.prototype.propertyIsEnumerable,Na=(i,e,t)=>e in i?Eu(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ou=(i,e)=>{for(var t in e||(e={}))Pu.call(e,t)&&Na(i,t,e[t]);if(Ra)for(var t of Ra(e))Su.call(e,t)&&Na(i,t,e[t]);return i},Au=(i,e)=>xu(i,Iu(e));function ns(i){const e=[];return i.forEach(t=>{const[s,r]=t.split(":");e.push(`${s}:${r}`)}),e}function Cu(i){const e=[];return Object.values(i).forEach(t=>{e.push(...ns(t.accounts))}),e}function Ru(i,e){const t=[];return Object.values(i).forEach(s=>{ns(s.accounts).includes(e)&&t.push(...s.methods)}),t}function Nu(i,e){const t=[];return Object.values(i).forEach(s=>{ns(s.accounts).includes(e)&&t.push(...s.events)}),t}function Gw(i,e){const t=bn(i,e);if(t)throw new Error(t.message);const s={};for(const[r,o]of Object.entries(i))s[r]={methods:o.methods,events:o.events,chains:o.accounts.map(a=>`${a.split(":")[0]}:${a.split(":")[1]}`)};return s}function Ww(i){const{proposal:{requiredNamespaces:e,optionalNamespaces:t={}},supportedNamespaces:s}=i,r=_n(e),o=_n(t),a={};Object.keys(s).forEach(u=>{const d=s[u].chains,p=s[u].methods,f=s[u].events,v=s[u].accounts;d.forEach(w=>{if(!v.some(b=>b.includes(w)))throw new Error(`No accounts provided for chain ${w} in namespace ${u}`)}),a[u]={chains:d,methods:p,events:f,accounts:v}});const c=Cr(e,a,"approve()");if(c)throw new Error(c.message);const h={};return!Object.keys(e).length&&!Object.keys(t).length?a:(Object.keys(r).forEach(u=>{const d=s[u].chains.filter(w=>{var b,_;return(_=(b=r[u])==null?void 0:b.chains)==null?void 0:_.includes(w)}),p=s[u].methods.filter(w=>{var b,_;return(_=(b=r[u])==null?void 0:b.methods)==null?void 0:_.includes(w)}),f=s[u].events.filter(w=>{var b,_;return(_=(b=r[u])==null?void 0:b.events)==null?void 0:_.includes(w)}),v=d.map(w=>s[u].accounts.filter(b=>b.includes(`${w}:`))).flat();h[u]={chains:d,methods:p,events:f,accounts:v}}),Object.keys(o).forEach(u=>{var d,p,f,v,w,b;if(!s[u])return;const _=(p=(d=o[u])==null?void 0:d.chains)==null?void 0:p.filter(T=>s[u].chains.includes(T)),x=s[u].methods.filter(T=>{var k,O;return(O=(k=o[u])==null?void 0:k.methods)==null?void 0:O.includes(T)}),E=s[u].events.filter(T=>{var k,O;return(O=(k=o[u])==null?void 0:k.events)==null?void 0:O.includes(T)}),R=_==null?void 0:_.map(T=>s[u].accounts.filter(k=>k.includes(`${T}:`))).flat();h[u]={chains:Ue((f=h[u])==null?void 0:f.chains,_),methods:Ue((v=h[u])==null?void 0:v.methods,x),events:Ue((w=h[u])==null?void 0:w.events,E),accounts:Ue((b=h[u])==null?void 0:b.accounts,R)}}),h)}function wn(i){return i.includes(":")}function rs(i){return wn(i)?i.split(":")[0]:i}function _n(i){var e,t,s;const r={};if(!Si(i))return r;for(const[o,a]of Object.entries(i)){const c=wn(o)?[o]:a.chains,h=a.methods||[],u=a.events||[],d=rs(o);r[d]=Au(Ou({},r[d]),{chains:Ue(c,(e=r[d])==null?void 0:e.chains),methods:Ue(h,(t=r[d])==null?void 0:t.methods),events:Ue(u,(s=r[d])==null?void 0:s.events)})}return r}function Tu(i){const e={};return i==null||i.forEach(t=>{var s;const[r,o]=t.split(":");e[r]||(e[r]={accounts:[],chains:[],events:[],methods:[]}),e[r].accounts.push(t),(s=e[r].chains)==null||s.push(`${r}:${o}`)}),e}function Ta(i,e){e=e.map(s=>s.replace("did:pkh:",""));const t=Tu(e);for(const[s,r]of Object.entries(t))r.methods?r.methods=Ue(r.methods,i):r.methods=i,r.events=["chainChanged","accountsChanged"];return t}function $u(i,e){var t,s,r,o,a,c;const h=_n(i),u=_n(e),d={},p=Object.keys(h).concat(Object.keys(u));for(const f of p)d[f]={chains:Ue((t=h[f])==null?void 0:t.chains,(s=u[f])==null?void 0:s.chains),methods:Ue((r=h[f])==null?void 0:r.methods,(o=u[f])==null?void 0:o.methods),events:Ue((a=h[f])==null?void 0:a.events,(c=u[f])==null?void 0:c.events)};return d}const ju={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},Du={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function L(i,e){const{message:t,code:s}=Du[i];return{message:e?`${t} ${e}`:t,code:s}}function _e(i,e){const{message:t,code:s}=ju[i];return{message:e?`${t} ${e}`:t,code:s}}function qt(i,e){return Array.isArray(i)?typeof e<"u"&&i.length?i.every(e):!0:!1}function Si(i){return Object.getPrototypeOf(i)===Object.prototype&&Object.keys(i).length}function tt(i){return typeof i>"u"}function ke(i,e){return e&&tt(i)?!0:typeof i=="string"&&!!i.trim().length}function Ar(i,e){return e&&tt(i)?!0:typeof i=="number"&&!isNaN(i)}function qu(i,e){const{requiredNamespaces:t}=e,s=Object.keys(i.namespaces),r=Object.keys(t);let o=!0;return mi(r,s)?(s.forEach(a=>{const{accounts:c,methods:h,events:u}=i.namespaces[a],d=ns(c),p=t[a];(!mi(zt(a,p),d)||!mi(p.methods,h)||!mi(p.events,u))&&(o=!1)}),o):!1}function vn(i){return ke(i,!1)&&i.includes(":")?i.split(":").length===2:!1}function Fu(i){if(ke(i,!1)&&i.includes(":")){const e=i.split(":");if(e.length===3){const t=e[0]+":"+e[1];return!!e[2]&&vn(t)}}return!1}function ku(i){function e(t){try{return typeof new URL(t)<"u"}catch{return!1}}try{if(ke(i,!1)){if(e(i))return!0;const t=er(i);return e(t)}}catch{}return!1}function Lu(i){var e;return(e=i==null?void 0:i.proposer)==null?void 0:e.publicKey}function Bu(i){return i==null?void 0:i.topic}function Uu(i,e){let t=null;return ke(i==null?void 0:i.publicKey,!1)||(t=L("MISSING_OR_INVALID",`${e} controller public key should be a string`)),t}function $a(i){let e=!0;return qt(i)?i.length&&(e=i.every(t=>ke(t,!1))):e=!1,e}function Mu(i,e,t){let s=null;return qt(e)&&e.length?e.forEach(r=>{s||vn(r)||(s=_e("UNSUPPORTED_CHAINS",`${t}, chain ${r} should be a string and conform to "namespace:chainId" format`))}):vn(i)||(s=_e("UNSUPPORTED_CHAINS",`${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),s}function zu(i,e,t){let s=null;return Object.entries(i).forEach(([r,o])=>{if(s)return;const a=Mu(r,zt(r,o),`${e} ${t}`);a&&(s=a)}),s}function Hu(i,e){let t=null;return qt(i)?i.forEach(s=>{t||Fu(s)||(t=_e("UNSUPPORTED_ACCOUNTS",`${e}, account ${s} should be a string and conform to "namespace:chainId:address" format`))}):t=_e("UNSUPPORTED_ACCOUNTS",`${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),t}function Ku(i,e){let t=null;return Object.values(i).forEach(s=>{if(t)return;const r=Hu(s==null?void 0:s.accounts,`${e} namespace`);r&&(t=r)}),t}function Vu(i,e){let t=null;return $a(i==null?void 0:i.methods)?$a(i==null?void 0:i.events)||(t=_e("UNSUPPORTED_EVENTS",`${e}, events should be an array of strings or empty array for no events`)):t=_e("UNSUPPORTED_METHODS",`${e}, methods should be an array of strings or empty array for no methods`),t}function ja(i,e){let t=null;return Object.values(i).forEach(s=>{if(t)return;const r=Vu(s,`${e}, namespace`);r&&(t=r)}),t}function Gu(i,e,t){let s=null;if(i&&Si(i)){const r=ja(i,e);r&&(s=r);const o=zu(i,e,t);o&&(s=o)}else s=L("MISSING_OR_INVALID",`${e}, ${t} should be an object with data`);return s}function bn(i,e){let t=null;if(i&&Si(i)){const s=ja(i,e);s&&(t=s);const r=Ku(i,e);r&&(t=r)}else t=L("MISSING_OR_INVALID",`${e}, namespaces should be an object with data`);return t}function Da(i){return ke(i.protocol,!0)}function Wu(i,e){let t=!1;return e&&!i?t=!0:i&&qt(i)&&i.length&&i.forEach(s=>{t=Da(s)}),t}function Ju(i){return typeof i=="number"}function pt(i){return typeof i<"u"&&typeof i!==null}function Zu(i){return!(!i||typeof i!="object"||!i.code||!Ar(i.code,!1)||!i.message||!ke(i.message,!1))}function Yu(i){return!(tt(i)||!ke(i.method,!1))}function Qu(i){return!(tt(i)||tt(i.result)&&tt(i.error)||!Ar(i.id,!1)||!ke(i.jsonrpc,!1))}function Xu(i){return!(tt(i)||!ke(i.name,!1))}function qa(i,e){return!(!vn(e)||!Cu(i).includes(e))}function ed(i,e,t){return ke(t,!1)?Ru(i,e).includes(t):!1}function td(i,e,t){return ke(t,!1)?Nu(i,e).includes(t):!1}function Cr(i,e,t){let s=null;const r=id(i),o=sd(e),a=Object.keys(r),c=Object.keys(o),h=Fa(Object.keys(i)),u=Fa(Object.keys(e)),d=h.filter(p=>!u.includes(p));return d.length&&(s=L("NON_CONFORMING_NAMESPACES",`${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d.toString()}
      Received: ${Object.keys(e).toString()}`)),mi(a,c)||(s=L("NON_CONFORMING_NAMESPACES",`${t} namespaces chains don't satisfy required namespaces.
      Required: ${a.toString()}
      Approved: ${c.toString()}`)),Object.keys(e).forEach(p=>{if(!p.includes(":")||s)return;const f=ns(e[p].accounts);f.includes(p)||(s=L("NON_CONFORMING_NAMESPACES",`${t} namespaces accounts don't satisfy namespace accounts for ${p}
        Required: ${p}
        Approved: ${f.toString()}`))}),a.forEach(p=>{s||(mi(r[p].methods,o[p].methods)?mi(r[p].events,o[p].events)||(s=L("NON_CONFORMING_NAMESPACES",`${t} namespaces events don't satisfy namespace events for ${p}`)):s=L("NON_CONFORMING_NAMESPACES",`${t} namespaces methods don't satisfy namespace methods for ${p}`))}),s}function id(i){const e={};return Object.keys(i).forEach(t=>{var s;t.includes(":")?e[t]=i[t]:(s=i[t].chains)==null||s.forEach(r=>{e[r]={methods:i[t].methods,events:i[t].events}})}),e}function Fa(i){return[...new Set(i.map(e=>e.includes(":")?e.split(":")[0]:e))]}function sd(i){const e={};return Object.keys(i).forEach(t=>{if(t.includes(":"))e[t]=i[t];else{const s=ns(i[t].accounts);s==null||s.forEach(r=>{e[r]={accounts:i[t].accounts.filter(o=>o.includes(`${r}:`)),methods:i[t].methods,events:i[t].events}})}}),e}function nd(i,e){return Ar(i,!1)&&i<=e.max&&i>=e.min}function ka(){const i=yi();return new Promise(e=>{switch(i){case Xe.browser:e(rd());break;case Xe.reactNative:e(od());break;case Xe.node:e(ad());break;default:e(!0)}})}function rd(){return fi()&&(navigator==null?void 0:navigator.onLine)}async function od(){if(Kt()&&typeof $.g<"u"&&$.g!=null&&$.g.NetInfo){const i=await($.g==null?void 0:$.g.NetInfo.fetch());return i==null?void 0:i.isConnected}return!0}function ad(){return!0}function cd(i){switch(yi()){case Xe.browser:hd(i);break;case Xe.reactNative:ld(i);break;case Xe.node:break}}function hd(i){!Kt()&&fi()&&(window.addEventListener("online",()=>i(!0)),window.addEventListener("offline",()=>i(!1)))}function ld(i){var e;Kt()&&typeof $.g<"u"&&$.g!=null&&$.g.NetInfo&&((e=$.g)==null||e.NetInfo.addEventListener(t=>i(t==null?void 0:t.isConnected)))}function ud(){var i;return fi()&&(0,Te.getDocument)()?((i=(0,Te.getDocument)())==null?void 0:i.visibilityState)==="visible":!0}const Rr={};class Ls{static get(e){return Rr[e]}static set(e,t){Rr[e]=t}static delete(e){delete Rr[e]}}var ji=$(19994),dd=$(32021),ce=$(56526),os=$(36900),pd=Object.defineProperty,gd=(i,e,t)=>e in i?pd(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,La=(i,e,t)=>gd(i,typeof e!="symbol"?e+"":e,t);class fd extends os.q{constructor(e){super(),this.opts=e,La(this,"protocol","wc"),La(this,"version",2)}}class Jw{constructor(e,t,s){this.core=e,this.logger=t}}var yd=Object.defineProperty,md=(i,e,t)=>e in i?yd(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,wd=(i,e,t)=>md(i,typeof e!="symbol"?e+"":e,t);class _d extends os.q{constructor(e,t){super(),this.core=e,this.logger=t,wd(this,"records",new Map)}}class vd{constructor(e,t){this.logger=e,this.core=t}}class bd extends os.q{constructor(e,t){super(),this.relayer=e,this.logger=t}}class Ed extends os.q{constructor(e){super()}}class xd{constructor(e,t,s,r){this.core=e,this.logger=t,this.name=s}}var Id=Object.defineProperty,Pd=(i,e,t)=>e in i?Id(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Sd=(i,e,t)=>Pd(i,typeof e!="symbol"?e+"":e,t);class Zw{constructor(){Sd(this,"map",new Map)}}class Od extends os.q{constructor(e,t){super(),this.relayer=e,this.logger=t}}class Yw{constructor(e,t){this.core=e,this.logger=t}}class Ad extends os.q{constructor(e,t){super(),this.core=e,this.logger=t}}class Qw{constructor(e,t){this.logger=e,this.core=t}}class Cd{constructor(e,t,s){this.core=e,this.logger=t,this.store=s}}class Rd{constructor(e,t){this.projectId=e,this.logger=t}}class Nd{constructor(e,t,s){this.core=e,this.logger=t,this.telemetryEnabled=s}}var Td=Object.defineProperty,$d=(i,e,t)=>e in i?Td(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ba=(i,e,t)=>$d(i,typeof e!="symbol"?e+"":e,t);class Xw extends null{constructor(){super()}}class jd{constructor(e){this.opts=e,Ba(this,"protocol","wc"),Ba(this,"version",2)}}class e_ extends null{constructor(){super()}}class Dd{constructor(e){this.client=e}}var Nr=$(41926),Pt=$(56390),J=$(23700),qd=$(85452),Tr=$(55872).Buffer,Fd=$(14224);const Ua="wc",Ma=2,En="core",Wt=`${Ua}@2:${En}:`,kd={name:En,logger:"error"},Ld={database:":memory:"},Bd="crypto",za="client_ed25519_seed",Ud=C.ONE_DAY,Md="keychain",zd="0.3",Hd="messages",Kd="0.3",Ha=C.SIX_HOURS,Vd="publisher",Ka="irn",Gd="error",Va="wss://relay.walletconnect.org",Wd="relayer",We={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},Jd="_subscription",St={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},Zd=.1,t_={database:":memory:"},$r="2.21.1",i_=1e4,Re={link_mode:"link_mode",relay:"relay"},xn={inbound:"inbound",outbound:"outbound"},Yd="0.3",Qd="WALLETCONNECT_CLIENT_ID",Ga="WALLETCONNECT_LINK_MODE_APPS",wt={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},s_=null,Xd="subscription",ep="0.3",n_=C.FIVE_SECONDS*1e3,tp="pairing",ip="0.3",r_=null,Bs={wc_pairingDelete:{req:{ttl:C.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:C.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:C.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:C.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:C.ONE_DAY,prompt:!1,tag:0},res:{ttl:C.ONE_DAY,prompt:!1,tag:0}}},Di={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},Ft={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},sp="history",np="0.3",rp="expirer",Ot={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},op="0.3",o_=null,ap="verify-api",cp="https://verify.walletconnect.com",Wa="https://verify.walletconnect.org",Us=Wa,hp=`${Us}/v3`,lp=[cp,Wa],up="echo",dp="https://echo.walletconnect.com",a_="event-client",Jt={pairing_started:"pairing_started",pairing_uri_validation_success:"pairing_uri_validation_success",pairing_uri_not_expired:"pairing_uri_not_expired",store_new_pairing:"store_new_pairing",subscribing_pairing_topic:"subscribing_pairing_topic",subscribe_pairing_topic_success:"subscribe_pairing_topic_success",existing_pairing:"existing_pairing",pairing_not_expired:"pairing_not_expired",emit_inactive_pairing:"emit_inactive_pairing",emit_session_proposal:"emit_session_proposal",subscribing_to_pairing_topic:"subscribing_to_pairing_topic"},ci={no_wss_connection:"no_wss_connection",no_internet_connection:"no_internet_connection",malformed_pairing_uri:"malformed_pairing_uri",active_pairing_already_exists:"active_pairing_already_exists",subscribe_pairing_topic_failure:"subscribe_pairing_topic_failure",pairing_expired:"pairing_expired",proposal_expired:"proposal_expired",proposal_listener_not_found:"proposal_listener_not_found"},Lt={session_approve_started:"session_approve_started",proposal_not_expired:"proposal_not_expired",session_namespaces_validation_success:"session_namespaces_validation_success",create_session_topic:"create_session_topic",subscribing_session_topic:"subscribing_session_topic",subscribe_session_topic_success:"subscribe_session_topic_success",publishing_session_approve:"publishing_session_approve",session_approve_publish_success:"session_approve_publish_success",store_session:"store_session",publishing_session_settle:"publishing_session_settle",session_settle_publish_success:"session_settle_publish_success"},qi={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",proposal_expired:"proposal_expired",subscribe_session_topic_failure:"subscribe_session_topic_failure",session_approve_publish_failure:"session_approve_publish_failure",session_settle_publish_failure:"session_settle_publish_failure",session_approve_namespace_validation_failure:"session_approve_namespace_validation_failure",proposal_not_found:"proposal_not_found"},Fi={authenticated_session_approve_started:"authenticated_session_approve_started",authenticated_session_not_expired:"authenticated_session_not_expired",chains_caip2_compliant:"chains_caip2_compliant",chains_evm_compliant:"chains_evm_compliant",create_authenticated_session_topic:"create_authenticated_session_topic",cacaos_verified:"cacaos_verified",store_authenticated_session:"store_authenticated_session",subscribing_authenticated_session_topic:"subscribing_authenticated_session_topic",subscribe_authenticated_session_topic_success:"subscribe_authenticated_session_topic_success",publishing_authenticated_session_approve:"publishing_authenticated_session_approve",authenticated_session_approve_publish_success:"authenticated_session_approve_publish_success"},Ms={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",missing_session_authenticate_request:"missing_session_authenticate_request",session_authenticate_request_expired:"session_authenticate_request_expired",chains_caip2_compliant_failure:"chains_caip2_compliant_failure",chains_evm_compliant_failure:"chains_evm_compliant_failure",invalid_cacao:"invalid_cacao",subscribe_authenticated_session_topic_failure:"subscribe_authenticated_session_topic_failure",authenticated_session_approve_publish_failure:"authenticated_session_approve_publish_failure",authenticated_session_pending_request_not_found:"authenticated_session_pending_request_not_found"},pp=.1,gp="event-client",fp=86400,yp="https://pulse.walletconnect.org/batch";function mp(i,e){if(i.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),s=0;s<t.length;s++)t[s]=255;for(var r=0;r<i.length;r++){var o=i.charAt(r),a=o.charCodeAt(0);if(t[a]!==255)throw new TypeError(o+" is ambiguous");t[a]=r}var c=i.length,h=i.charAt(0),u=Math.log(c)/Math.log(256),d=Math.log(256)/Math.log(c);function p(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var b=0,_=0,x=0,E=w.length;x!==E&&w[x]===0;)x++,b++;for(var R=(E-x)*d+1>>>0,T=new Uint8Array(R);x!==E;){for(var k=w[x],O=0,D=R-1;(k!==0||O<_)&&D!==-1;D--,O++)k+=256*T[D]>>>0,T[D]=k%c>>>0,k=k/c>>>0;if(k!==0)throw new Error("Non-zero carry");_=O,x++}for(var U=R-_;U!==R&&T[U]===0;)U++;for(var P=h.repeat(b);U<R;++U)P+=i.charAt(T[U]);return P}function f(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var b=0;if(w[b]!==" "){for(var _=0,x=0;w[b]===h;)_++,b++;for(var E=(w.length-b)*u+1>>>0,R=new Uint8Array(E);w[b];){var T=t[w.charCodeAt(b)];if(T===255)return;for(var k=0,O=E-1;(T!==0||k<x)&&O!==-1;O--,k++)T+=c*R[O]>>>0,R[O]=T%256>>>0,T=T/256>>>0;if(T!==0)throw new Error("Non-zero carry");x=k,b++}if(w[b]!==" "){for(var D=E-x;D!==E&&R[D]===0;)D++;for(var U=new Uint8Array(_+(E-D)),P=_;D!==E;)U[P++]=R[D++];return U}}}function v(w){var b=f(w);if(b)return b;throw new Error(`Non-${e} character`)}return{encode:p,decodeUnsafe:f,decode:v}}var wp=mp,_p=wp;const Ja=i=>{if(i instanceof Uint8Array&&i.constructor.name==="Uint8Array")return i;if(i instanceof ArrayBuffer)return new Uint8Array(i);if(ArrayBuffer.isView(i))return new Uint8Array(i.buffer,i.byteOffset,i.byteLength);throw new Error("Unknown type, must be binary type")},vp=i=>new TextEncoder().encode(i),bp=i=>new TextDecoder().decode(i);class Ep{constructor(e,t,s){this.name=e,this.prefix=t,this.baseEncode=s}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class xp{constructor(e,t,s){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=s}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Za(this,e)}}class Ip{constructor(e){this.decoders=e}or(e){return Za(this,e)}decode(e){const t=e[0],s=this.decoders[t];if(s)return s.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Za=(i,e)=>new Ip({...i.decoders||{[i.prefix]:i},...e.decoders||{[e.prefix]:e}});class Pp{constructor(e,t,s,r){this.name=e,this.prefix=t,this.baseEncode=s,this.baseDecode=r,this.encoder=new Ep(e,t,s),this.decoder=new xp(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const In=({name:i,prefix:e,encode:t,decode:s})=>new Pp(i,e,t,s),zs=({prefix:i,name:e,alphabet:t})=>{const{encode:s,decode:r}=_p(t,e);return In({prefix:i,name:e,encode:s,decode:o=>Ja(r(o))})},Sp=(i,e,t,s)=>{const r={};for(let d=0;d<e.length;++d)r[e[d]]=d;let o=i.length;for(;i[o-1]==="=";)--o;const a=new Uint8Array(o*t/8|0);let c=0,h=0,u=0;for(let d=0;d<o;++d){const p=r[i[d]];if(p===void 0)throw new SyntaxError(`Non-${s} character`);h=h<<t|p,c+=t,c>=8&&(c-=8,a[u++]=255&h>>c)}if(c>=t||255&h<<8-c)throw new SyntaxError("Unexpected end of data");return a},Op=(i,e,t)=>{const s=e[e.length-1]==="=",r=(1<<t)-1;let o="",a=0,c=0;for(let h=0;h<i.length;++h)for(c=c<<8|i[h],a+=8;a>t;)a-=t,o+=e[r&c>>a];if(a&&(o+=e[r&c<<t-a]),s)for(;o.length*t&7;)o+="=";return o},it=({name:i,prefix:e,bitsPerChar:t,alphabet:s})=>In({prefix:e,name:i,encode(r){return Op(r,s,t)},decode(r){return Sp(r,s,t,i)}}),Ap=In({prefix:"\0",name:"identity",encode:i=>bp(i),decode:i=>vp(i)});var Cp=Object.freeze({__proto__:null,identity:Ap});const Rp=it({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Np=Object.freeze({__proto__:null,base2:Rp});const Tp=it({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var $p=Object.freeze({__proto__:null,base8:Tp});const jp=zs({prefix:"9",name:"base10",alphabet:"0123456789"});var Dp=Object.freeze({__proto__:null,base10:jp});const qp=it({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Fp=it({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var kp=Object.freeze({__proto__:null,base16:qp,base16upper:Fp});const Lp=it({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Bp=it({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Up=it({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Mp=it({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),zp=it({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Hp=it({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Kp=it({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Vp=it({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Gp=it({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Wp=Object.freeze({__proto__:null,base32:Lp,base32upper:Bp,base32pad:Up,base32padupper:Mp,base32hex:zp,base32hexupper:Hp,base32hexpad:Kp,base32hexpadupper:Vp,base32z:Gp});const Jp=zs({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Zp=zs({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Yp=Object.freeze({__proto__:null,base36:Jp,base36upper:Zp});const Qp=zs({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Xp=zs({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var eg=Object.freeze({__proto__:null,base58btc:Qp,base58flickr:Xp});const tg=it({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ig=it({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),sg=it({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ng=it({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var rg=Object.freeze({__proto__:null,base64:tg,base64pad:ig,base64url:sg,base64urlpad:ng});const Ya=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),og=Ya.reduce((i,e,t)=>(i[t]=e,i),[]),ag=Ya.reduce((i,e,t)=>(i[e.codePointAt(0)]=t,i),[]);function cg(i){return i.reduce((e,t)=>(e+=og[t],e),"")}function hg(i){const e=[];for(const t of i){const s=ag[t.codePointAt(0)];if(s===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const lg=In({prefix:"\u{1F680}",name:"base256emoji",encode:cg,decode:hg});var ug=Object.freeze({__proto__:null,base256emoji:lg}),dg=Xa,Qa=128,pg=127,gg=~pg,fg=Math.pow(2,31);function Xa(i,e,t){e=e||[],t=t||0;for(var s=t;i>=fg;)e[t++]=i&255|Qa,i/=128;for(;i&gg;)e[t++]=i&255|Qa,i>>>=7;return e[t]=i|0,Xa.bytes=t-s+1,e}var yg=jr,mg=128,ec=127;function jr(i,s){var t=0,s=s||0,r=0,o=s,a,c=i.length;do{if(o>=c)throw jr.bytes=0,new RangeError("Could not decode varint");a=i[o++],t+=r<28?(a&ec)<<r:(a&ec)*Math.pow(2,r),r+=7}while(a>=mg);return jr.bytes=o-s,t}var wg=Math.pow(2,7),_g=Math.pow(2,14),vg=Math.pow(2,21),bg=Math.pow(2,28),Eg=Math.pow(2,35),xg=Math.pow(2,42),Ig=Math.pow(2,49),Pg=Math.pow(2,56),Sg=Math.pow(2,63),Og=function(i){return i<wg?1:i<_g?2:i<vg?3:i<bg?4:i<Eg?5:i<xg?6:i<Ig?7:i<Pg?8:i<Sg?9:10},Ag={encode:dg,decode:yg,encodingLength:Og},tc=Ag;const ic=(i,e,t=0)=>(tc.encode(i,e,t),e),sc=i=>tc.encodingLength(i),Dr=(i,e)=>{const t=e.byteLength,s=sc(i),r=s+sc(t),o=new Uint8Array(r+t);return ic(i,o,0),ic(t,o,s),o.set(e,r),new Cg(i,t,e,o)};class Cg{constructor(e,t,s,r){this.code=e,this.size=t,this.digest=s,this.bytes=r}}const nc=({name:i,code:e,encode:t})=>new Rg(i,e,t);class Rg{constructor(e,t,s){this.name=e,this.code=t,this.encode=s}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?Dr(this.code,t):t.then(s=>Dr(this.code,s))}else throw Error("Unknown type, must be binary type")}}const rc=i=>async e=>new Uint8Array(await crypto.subtle.digest(i,e)),Ng=nc({name:"sha2-256",code:18,encode:rc("SHA-256")}),Tg=nc({name:"sha2-512",code:19,encode:rc("SHA-512")});var $g=Object.freeze({__proto__:null,sha256:Ng,sha512:Tg});const oc=0,jg="identity",ac=Ja;var Dg=Object.freeze({__proto__:null,identity:{code:oc,name:jg,encode:ac,digest:i=>Dr(oc,ac(i))}});new TextEncoder,new TextDecoder;const cc={...Cp,...Np,...$p,...Dp,...kp,...Wp,...Yp,...eg,...rg,...ug};({...$g,...Dg});function qg(i=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(i):new Uint8Array(i)}function hc(i,e,t,s){return{name:i,prefix:e,encoder:{name:i,prefix:e,encode:t},decoder:{decode:s}}}const lc=hc("utf8","u",i=>"u"+new TextDecoder("utf8").decode(i),i=>new TextEncoder().encode(i.substring(1))),qr=hc("ascii","a",i=>{let e="a";for(let t=0;t<i.length;t++)e+=String.fromCharCode(i[t]);return e},i=>{i=i.substring(1);const e=qg(i.length);for(let t=0;t<i.length;t++)e[t]=i.charCodeAt(t);return e}),Fg={utf8:lc,"utf-8":lc,hex:cc.base16,latin1:qr,ascii:qr,binary:qr,...cc};function kg(i,e="utf8"){const t=Fg[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(i,"utf8"):t.decoder.decode(`${t.prefix}${i}`)}var Lg=Object.defineProperty,Bg=(i,e,t)=>e in i?Lg(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Zt=(i,e,t)=>Bg(i,typeof e!="symbol"?e+"":e,t);class Ug{constructor(e,t){this.core=e,this.logger=t,Zt(this,"keychain",new Map),Zt(this,"name",Md),Zt(this,"version",zd),Zt(this,"initialized",!1),Zt(this,"storagePrefix",Wt),Zt(this,"init",async()=>{if(!this.initialized){const s=await this.getKeyChain();typeof s<"u"&&(this.keychain=s),this.initialized=!0}}),Zt(this,"has",s=>(this.isInitialized(),this.keychain.has(s))),Zt(this,"set",async(s,r)=>{this.isInitialized(),this.keychain.set(s,r),await this.persist()}),Zt(this,"get",s=>{this.isInitialized();const r=this.keychain.get(s);if(typeof r>"u"){const{message:o}=L("NO_MATCHING_KEY",`${this.name}: ${s}`);throw new Error(o)}return r}),Zt(this,"del",async s=>{this.isInitialized(),this.keychain.delete(s),await this.persist()}),this.core=e,this.logger=(0,ce.Ep)(t,this.name)}get context(){return(0,ce.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,xt(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?Ki(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}}var Mg=Object.defineProperty,zg=(i,e,t)=>e in i?Mg(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,st=(i,e,t)=>zg(i,typeof e!="symbol"?e+"":e,t);class Hg{constructor(e,t,s){this.core=e,this.logger=t,st(this,"name",Bd),st(this,"keychain"),st(this,"randomSessionIdentifier",Or()),st(this,"initialized",!1),st(this,"init",async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)}),st(this,"hasKeys",r=>(this.isInitialized(),this.keychain.has(r))),st(this,"getClientId",async()=>{this.isInitialized();const r=await this.getClientSeed(),o=He.Au(r);return He.bG(o.publicKey)}),st(this,"generateKeyPair",()=>{this.isInitialized();const r=hu();return this.setPrivateKey(r.publicKey,r.privateKey)}),st(this,"signJWT",async r=>{this.isInitialized();const o=await this.getClientSeed(),a=He.Au(o),c=this.randomSessionIdentifier,h=Ud;return await He.vf(c,r,h,a)}),st(this,"generateSharedKey",(r,o,a)=>{this.isInitialized();const c=this.getPrivateKey(r),h=lu(c,o);return this.setSymKey(h,a)}),st(this,"setSymKey",async(r,o)=>{this.isInitialized();const a=o||fn(r);return await this.keychain.set(a,r),a}),st(this,"deleteKeyPair",async r=>{this.isInitialized(),await this.keychain.del(r)}),st(this,"deleteSymKey",async r=>{this.isInitialized(),await this.keychain.del(r)}),st(this,"encode",async(r,o,a)=>{this.isInitialized();const c=Pa(a),h=(0,Nr.u)(o);if(Oa(c))return pu(h,a==null?void 0:a.encoding);if(Sa(c)){const f=c.senderPublicKey,v=c.receiverPublicKey;r=await this.generateSharedKey(f,v)}const u=this.getSymKey(r),{type:d,senderPublicKey:p}=c;return uu({type:d,symKey:u,message:h,senderPublicKey:p,encoding:a==null?void 0:a.encoding})}),st(this,"decode",async(r,o,a)=>{this.isInitialized();const c=fu(o,a);if(Oa(c)){const h=gu(o,a==null?void 0:a.encoding);return(0,Nr.D)(h)}if(Sa(c)){const h=c.receiverPublicKey,u=c.senderPublicKey;r=await this.generateSharedKey(h,u)}try{const h=this.getSymKey(r),u=du({symKey:h,encoded:o,encoding:a==null?void 0:a.encoding});return(0,Nr.D)(u)}catch(h){this.logger.error(`Failed to decode message from topic: '${r}', clientId: '${await this.getClientId()}'`),this.logger.error(h)}}),st(this,"getPayloadType",(r,o=Dt)=>{const a=Fs({encoded:r,encoding:o});return $i(a.type)}),st(this,"getPayloadSenderPublicKey",(r,o=Dt)=>{const a=Fs({encoded:r,encoding:o});return a.senderPublicKey?(0,te.BB)(a.senderPublicKey,lt):void 0}),this.core=e,this.logger=(0,ce.Ep)(t,this.name),this.keychain=s||new Ug(this.core,this.logger)}get context(){return(0,ce.Fd)(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(za)}catch{e=Or(),await this.keychain.set(za,e)}return kg(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}}var Kg=Object.defineProperty,Vg=Object.defineProperties,Gg=Object.getOwnPropertyDescriptors,uc=Object.getOwnPropertySymbols,Wg=Object.prototype.hasOwnProperty,Jg=Object.prototype.propertyIsEnumerable,Fr=(i,e,t)=>e in i?Kg(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Zg=(i,e)=>{for(var t in e||(e={}))Wg.call(e,t)&&Fr(i,t,e[t]);if(uc)for(var t of uc(e))Jg.call(e,t)&&Fr(i,t,e[t]);return i},Yg=(i,e)=>Vg(i,Gg(e)),_t=(i,e,t)=>Fr(i,typeof e!="symbol"?e+"":e,t);class Qg extends vd{constructor(e,t){super(e,t),this.logger=e,this.core=t,_t(this,"messages",new Map),_t(this,"messagesWithoutClientAck",new Map),_t(this,"name",Hd),_t(this,"version",Kd),_t(this,"initialized",!1),_t(this,"storagePrefix",Wt),_t(this,"init",async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const s=await this.getRelayerMessages();typeof s<"u"&&(this.messages=s);const r=await this.getRelayerMessagesWithoutClientAck();typeof r<"u"&&(this.messagesWithoutClientAck=r),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(s){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(s)}finally{this.initialized=!0}}}),_t(this,"set",async(s,r,o)=>{this.isInitialized();const a=Gt(r);let c=this.messages.get(s);if(typeof c>"u"&&(c={}),typeof c[a]<"u")return a;if(c[a]=r,this.messages.set(s,c),o===xn.inbound){const h=this.messagesWithoutClientAck.get(s)||{};this.messagesWithoutClientAck.set(s,Yg(Zg({},h),{[a]:r}))}return await this.persist(),a}),_t(this,"get",s=>{this.isInitialized();let r=this.messages.get(s);return typeof r>"u"&&(r={}),r}),_t(this,"getWithoutAck",s=>{this.isInitialized();const r={};for(const o of s){const a=this.messagesWithoutClientAck.get(o)||{};r[o]=Object.values(a)}return r}),_t(this,"has",(s,r)=>{this.isInitialized();const o=this.get(s),a=Gt(r);return typeof o[a]<"u"}),_t(this,"ack",async(s,r)=>{this.isInitialized();const o=this.messagesWithoutClientAck.get(s);if(typeof o>"u")return;const a=Gt(r);delete o[a],Object.keys(o).length===0?this.messagesWithoutClientAck.delete(s):this.messagesWithoutClientAck.set(s,o),await this.persist()}),_t(this,"del",async s=>{this.isInitialized(),this.messages.delete(s),this.messagesWithoutClientAck.delete(s),await this.persist()}),this.logger=(0,ce.Ep)(e,this.name),this.core=t}get context(){return(0,ce.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get storageKeyWithoutClientAck(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name+"_withoutClientAck"}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,xt(e))}async setRelayerMessagesWithoutClientAck(e){await this.core.storage.setItem(this.storageKeyWithoutClientAck,xt(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?Ki(e):void 0}async getRelayerMessagesWithoutClientAck(){const e=await this.core.storage.getItem(this.storageKeyWithoutClientAck);return typeof e<"u"?Ki(e):void 0}async persist(){await this.setRelayerMessages(this.messages),await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck)}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}}var Xg=Object.defineProperty,ef=Object.defineProperties,tf=Object.getOwnPropertyDescriptors,dc=Object.getOwnPropertySymbols,sf=Object.prototype.hasOwnProperty,nf=Object.prototype.propertyIsEnumerable,kr=(i,e,t)=>e in i?Xg(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Pn=(i,e)=>{for(var t in e||(e={}))sf.call(e,t)&&kr(i,t,e[t]);if(dc)for(var t of dc(e))nf.call(e,t)&&kr(i,t,e[t]);return i},Lr=(i,e)=>ef(i,tf(e)),Bt=(i,e,t)=>kr(i,typeof e!="symbol"?e+"":e,t);class rf extends bd{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,Bt(this,"events",new xe.EventEmitter),Bt(this,"name",Vd),Bt(this,"queue",new Map),Bt(this,"publishTimeout",(0,C.toMiliseconds)(C.ONE_MINUTE)),Bt(this,"initialPublishTimeout",(0,C.toMiliseconds)(C.ONE_SECOND*15)),Bt(this,"needsTransportRestart",!1),Bt(this,"publish",async(s,r,o)=>{var a;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:s,message:r,opts:o}});const c=(o==null?void 0:o.ttl)||Ha,h=yn(o),u=(o==null?void 0:o.prompt)||!1,d=(o==null?void 0:o.tag)||0,p=(o==null?void 0:o.id)||(0,J.getBigIntRpcId)().toString(),f={topic:s,message:r,opts:{ttl:c,relay:h,prompt:u,tag:d,id:p,attestation:o==null?void 0:o.attestation,tvf:o==null?void 0:o.tvf}},v=`Failed to publish payload, please try again. id:${p} tag:${d}`;try{const w=new Promise(async b=>{const _=({id:E})=>{f.opts.id===E&&(this.removeRequestFromQueue(E),this.relayer.events.removeListener(We.publish,_),b(f))};this.relayer.events.on(We.publish,_);const x=Vt(new Promise((E,R)=>{this.rpcPublish({topic:s,message:r,ttl:c,prompt:u,tag:d,id:p,attestation:o==null?void 0:o.attestation,tvf:o==null?void 0:o.tvf}).then(E).catch(T=>{this.logger.warn(T,T==null?void 0:T.message),R(T)})}),this.initialPublishTimeout,`Failed initial publish, retrying.... id:${p} tag:${d}`);try{await x,this.events.removeListener(We.publish,_)}catch(E){this.queue.set(p,Lr(Pn({},f),{attempt:1})),this.logger.warn(E,E==null?void 0:E.message)}});this.logger.trace({type:"method",method:"publish",params:{id:p,topic:s,message:r,opts:o}}),await Vt(w,this.publishTimeout,v)}catch(w){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(w),(a=o==null?void 0:o.internal)!=null&&a.throwOnFailedPublish)throw w}finally{this.queue.delete(p)}}),Bt(this,"on",(s,r)=>{this.events.on(s,r)}),Bt(this,"once",(s,r)=>{this.events.once(s,r)}),Bt(this,"off",(s,r)=>{this.events.off(s,r)}),Bt(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),this.relayer=e,this.logger=(0,ce.Ep)(t,this.name),this.registerEventListeners()}get context(){return(0,ce.Fd)(this.logger)}async rpcPublish(e){var t,s,r,o;const{topic:a,message:c,ttl:h=Ha,prompt:u,tag:d,id:p,attestation:f,tvf:v}=e,w={method:ks(yn().protocol).publish,params:Pn({topic:a,message:c,ttl:h,prompt:u,tag:d,attestation:f},v),id:p};tt((t=w.params)==null?void 0:t.prompt)&&((s=w.params)==null||delete s.prompt),tt((r=w.params)==null?void 0:r.tag)&&((o=w.params)==null||delete o.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:w});const b=await this.relayer.request(w);return this.relayer.events.emit(We.publish,e),this.logger.debug("Successfully Published Payload"),b}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async(e,t)=>{const s=e.attempt+1;this.queue.set(t,Lr(Pn({},e),{attempt:s}));const{topic:r,message:o,opts:a,attestation:c}=e;this.logger.warn({},`Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${s}`),await this.rpcPublish(Lr(Pn({},e),{topic:r,message:o,ttl:a.ttl,prompt:a.prompt,tag:a.tag,id:a.id,attestation:c,tvf:a.tvf})),this.logger.warn({},`Publisher: queue->published: ${e.opts.id}`)})}registerEventListeners(){this.relayer.core.heartbeat.on(ji.Lx.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(We.connection_stalled);return}this.checkQueue()}),this.relayer.on(We.message_ack,e=>{this.removeRequestFromQueue(e.id.toString())})}}var of=Object.defineProperty,af=(i,e,t)=>e in i?of(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,as=(i,e,t)=>af(i,typeof e!="symbol"?e+"":e,t);class cf{constructor(){as(this,"map",new Map),as(this,"set",(e,t)=>{const s=this.get(e);this.exists(e,t)||this.map.set(e,[...s,t])}),as(this,"get",e=>this.map.get(e)||[]),as(this,"exists",(e,t)=>this.get(e).includes(t)),as(this,"delete",(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const s=this.get(e);if(!this.exists(e,t))return;const r=s.filter(o=>o!==t);if(!r.length){this.map.delete(e);return}this.map.set(e,r)}),as(this,"clear",()=>{this.map.clear()})}get topics(){return Array.from(this.map.keys())}}var hf=Object.defineProperty,lf=Object.defineProperties,uf=Object.getOwnPropertyDescriptors,pc=Object.getOwnPropertySymbols,df=Object.prototype.hasOwnProperty,pf=Object.prototype.propertyIsEnumerable,Br=(i,e,t)=>e in i?hf(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Hs=(i,e)=>{for(var t in e||(e={}))df.call(e,t)&&Br(i,t,e[t]);if(pc)for(var t of pc(e))pf.call(e,t)&&Br(i,t,e[t]);return i},Ur=(i,e)=>lf(i,uf(e)),be=(i,e,t)=>Br(i,typeof e!="symbol"?e+"":e,t);class gf extends Od{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,be(this,"subscriptions",new Map),be(this,"topicMap",new cf),be(this,"events",new xe.EventEmitter),be(this,"name",Xd),be(this,"version",ep),be(this,"pending",new Map),be(this,"cached",[]),be(this,"initialized",!1),be(this,"storagePrefix",Wt),be(this,"subscribeTimeout",(0,C.toMiliseconds)(C.ONE_MINUTE)),be(this,"initialSubscribeTimeout",(0,C.toMiliseconds)(C.ONE_SECOND*15)),be(this,"clientId"),be(this,"batchSubscribeTopicsLimit",500),be(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),await this.restore()),this.initialized=!0}),be(this,"subscribe",async(s,r)=>{this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:r}});try{const o=yn(r),a={topic:s,relay:o,transportType:r==null?void 0:r.transportType};this.pending.set(s,a);const c=await this.rpcSubscribe(s,o,r);return typeof c=="string"&&(this.onSubscribe(c,a),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:r}})),c}catch(o){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(o),o}}),be(this,"unsubscribe",async(s,r)=>{this.isInitialized(),typeof(r==null?void 0:r.id)<"u"?await this.unsubscribeById(s,r.id,r):await this.unsubscribeByTopic(s,r)}),be(this,"isSubscribed",s=>new Promise(r=>{r(this.topicMap.topics.includes(s))})),be(this,"isKnownTopic",s=>new Promise(r=>{r(this.topicMap.topics.includes(s)||this.pending.has(s)||this.cached.some(o=>o.topic===s))})),be(this,"on",(s,r)=>{this.events.on(s,r)}),be(this,"once",(s,r)=>{this.events.once(s,r)}),be(this,"off",(s,r)=>{this.events.off(s,r)}),be(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),be(this,"start",async()=>{await this.onConnect()}),be(this,"stop",async()=>{await this.onDisconnect()}),be(this,"restart",async()=>{await this.restore(),await this.onRestart()}),be(this,"checkPending",async()=>{if(this.pending.size===0&&(!this.initialized||!this.relayer.connected))return;const s=[];this.pending.forEach(r=>{s.push(r)}),await this.batchSubscribe(s)}),be(this,"registerEventListeners",()=>{this.relayer.core.heartbeat.on(ji.Lx.pulse,async()=>{await this.checkPending()}),this.events.on(wt.created,async s=>{const r=wt.created;this.logger.info(`Emitting ${r}`),this.logger.debug({type:"event",event:r,data:s}),await this.persist()}),this.events.on(wt.deleted,async s=>{const r=wt.deleted;this.logger.info(`Emitting ${r}`),this.logger.debug({type:"event",event:r,data:s}),await this.persist()})}),this.relayer=e,this.logger=(0,ce.Ep)(t,this.name),this.clientId=""}get context(){return(0,ce.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}get hasAnyTopics(){return this.topicMap.topics.length>0||this.pending.size>0||this.cached.length>0||this.subscriptions.size>0}hasSubscription(e,t){let s=!1;try{s=this.getSubscription(e).topic===t}catch{}return s}reset(){this.cached=[],this.initialized=!0}onDisable(){this.values.length>0&&(this.cached=this.values),this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const s=this.topicMap.get(e);await Promise.all(s.map(async r=>await this.unsubscribeById(e,r,t)))}async unsubscribeById(e,t,s){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}});try{const r=yn(s);await this.restartToComplete({topic:e,id:t,relay:r}),await this.rpcUnsubscribe(e,t,r);const o=_e("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,o),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}})}catch(r){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(r),r}}async rpcSubscribe(e,t,s){var r;(!s||(s==null?void 0:s.transportType)===Re.relay)&&await this.restartToComplete({topic:e,id:e,relay:t});const o={method:ks(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:o});const a=(r=s==null?void 0:s.internal)==null?void 0:r.throwOnFailedPublish;try{const c=await this.getSubscriptionId(e);if((s==null?void 0:s.transportType)===Re.link_mode)return setTimeout(()=>{(this.relayer.connected||this.relayer.connecting)&&this.relayer.request(o).catch(d=>this.logger.warn(d))},(0,C.toMiliseconds)(C.ONE_SECOND)),c;const h=new Promise(async d=>{const p=f=>{f.topic===e&&(this.events.removeListener(wt.created,p),d(f.id))};this.events.on(wt.created,p);try{const f=await Vt(new Promise((v,w)=>{this.relayer.request(o).catch(b=>{this.logger.warn(b,b==null?void 0:b.message),w(b)}).then(v)}),this.initialSubscribeTimeout,`Subscribing to ${e} failed, please try again`);this.events.removeListener(wt.created,p),d(f)}catch{}}),u=await Vt(h,this.subscribeTimeout,`Subscribing to ${e} failed, please try again`);if(!u&&a)throw new Error(`Subscribing to ${e} failed, please try again`);return u?c:null}catch(c){if(this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(We.connection_stalled),a)throw c}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,s={method:ks(t.protocol).batchSubscribe,params:{topics:e.map(r=>r.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});try{await await Vt(new Promise(r=>{this.relayer.request(s).catch(o=>this.logger.warn(o)).then(r)}),this.subscribeTimeout,"rpcBatchSubscribe failed, please try again")}catch{this.relayer.events.emit(We.connection_stalled)}}async rpcBatchFetchMessages(e){if(!e.length)return;const t=e[0].relay,s={method:ks(t.protocol).batchFetchMessages,params:{topics:e.map(o=>o.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});let r;try{r=await await Vt(new Promise((o,a)=>{this.relayer.request(s).catch(c=>{this.logger.warn(c),a(c)}).then(o)}),this.subscribeTimeout,"rpcBatchFetchMessages failed, please try again")}catch{this.relayer.events.emit(We.connection_stalled)}return r}rpcUnsubscribe(e,t,s){const r={method:ks(s.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:r}),this.relayer.request(r)}onSubscribe(e,t){this.setSubscription(e,Ur(Hs({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,Hs({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,s){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,s),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,Hs({},t)),this.topicMap.set(t.topic,e),this.events.emit(wt.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:s}=L("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const s=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(s.topic,e),this.events.emit(wt.deleted,Ur(Hs({},s),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(wt.sync)}async onRestart(){if(this.cached.length){const e=[...this.cached],t=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let s=0;s<t;s++){const r=e.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(r)}}this.events.emit(wt.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=L("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){e.length&&(await this.rpcBatchSubscribe(e),this.onBatchSubscribe(await Promise.all(e.map(async t=>Ur(Hs({},t),{id:await this.getSubscriptionId(t.topic)})))))}async batchFetchMessages(e){if(!e.length)return;this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);const t=await this.rpcBatchFetchMessages(e);t&&t.messages&&(await sn((0,C.toMiliseconds)(C.ONE_SECOND)),await this.relayer.handleBatchMessageEvents(t.messages))}async onConnect(){await this.restart(),this.reset()}onDisconnect(){this.onDisable()}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(e){!this.relayer.connected&&!this.relayer.connecting&&(this.cached.push(e),await this.relayer.transportOpen())}async getClientId(){return this.clientId||(this.clientId=await this.relayer.core.crypto.getClientId()),this.clientId}async getSubscriptionId(e){return Gt(e+await this.getClientId())}}var ff=Object.defineProperty,gc=Object.getOwnPropertySymbols,yf=Object.prototype.hasOwnProperty,mf=Object.prototype.propertyIsEnumerable,Mr=(i,e,t)=>e in i?ff(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,fc=(i,e)=>{for(var t in e||(e={}))yf.call(e,t)&&Mr(i,t,e[t]);if(gc)for(var t of gc(e))mf.call(e,t)&&Mr(i,t,e[t]);return i},fe=(i,e,t)=>Mr(i,typeof e!="symbol"?e+"":e,t);class wf extends Ed{constructor(e){super(e),fe(this,"protocol","wc"),fe(this,"version",2),fe(this,"core"),fe(this,"logger"),fe(this,"events",new xe.EventEmitter),fe(this,"provider"),fe(this,"messages"),fe(this,"subscriber"),fe(this,"publisher"),fe(this,"name",Wd),fe(this,"transportExplicitlyClosed",!1),fe(this,"initialized",!1),fe(this,"connectionAttemptInProgress",!1),fe(this,"relayUrl"),fe(this,"projectId"),fe(this,"packageName"),fe(this,"bundleId"),fe(this,"hasExperiencedNetworkDisruption",!1),fe(this,"pingTimeout"),fe(this,"heartBeatTimeout",(0,C.toMiliseconds)(C.THIRTY_SECONDS+C.FIVE_SECONDS)),fe(this,"reconnectTimeout"),fe(this,"connectPromise"),fe(this,"reconnectInProgress",!1),fe(this,"requestsInFlight",[]),fe(this,"connectTimeout",(0,C.toMiliseconds)(C.ONE_SECOND*15)),fe(this,"request",async t=>{var s,r;this.logger.debug("Publishing Request Payload");const o=t.id||(0,J.getBigIntRpcId)().toString();await this.toEstablishConnection();try{this.logger.trace({id:o,method:t.method,topic:(s=t.params)==null?void 0:s.topic},"relayer.request - publishing...");const a=`${o}:${((r=t.params)==null?void 0:r.tag)||""}`;this.requestsInFlight.push(a);const c=await this.provider.request(t);return this.requestsInFlight=this.requestsInFlight.filter(h=>h!==a),c}catch(a){throw this.logger.debug(`Failed to Publish Request: ${o}`),a}}),fe(this,"resetPingTimeout",()=>{Hi()&&(clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout(()=>{var t,s,r,o;try{this.logger.debug({},"pingTimeout: Connection stalled, terminating..."),(o=(r=(s=(t=this.provider)==null?void 0:t.connection)==null?void 0:s.socket)==null?void 0:r.terminate)==null||o.call(r)}catch(a){this.logger.warn(a,a==null?void 0:a.message)}},this.heartBeatTimeout))}),fe(this,"onPayloadHandler",t=>{this.onProviderPayload(t),this.resetPingTimeout()}),fe(this,"onConnectHandler",()=>{this.logger.warn({},"Relayer connected \u{1F6DC}"),this.startPingTimeout(),this.events.emit(We.connect)}),fe(this,"onDisconnectHandler",()=>{this.logger.warn({},"Relayer disconnected \u{1F6D1}"),this.requestsInFlight=[],this.onProviderDisconnect()}),fe(this,"onProviderErrorHandler",t=>{this.logger.fatal(`Fatal socket error: ${t.message}`),this.events.emit(We.error,t),this.logger.fatal("Fatal socket error received, closing transport"),this.transportClose()}),fe(this,"registerProviderListeners",()=>{this.provider.on(St.payload,this.onPayloadHandler),this.provider.on(St.connect,this.onConnectHandler),this.provider.on(St.disconnect,this.onDisconnectHandler),this.provider.on(St.error,this.onProviderErrorHandler)}),this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?(0,ce.Ep)(e.logger,this.name):(0,ce.gw)((0,ce.jI)({level:e.logger||Gd})),this.messages=new Qg(this.logger,e.core),this.subscriber=new gf(this,this.logger),this.publisher=new rf(this,this.logger),this.relayUrl=(e==null?void 0:e.relayUrl)||Va,this.projectId=e.projectId,Bn()?this.packageName=Js():Un()&&(this.bundleId=Js()),this.provider={}}async init(){if(this.logger.trace("Initialized"),this.registerEventListeners(),await Promise.all([this.messages.init(),this.subscriber.init()]),this.initialized=!0,this.subscriber.hasAnyTopics)try{await this.transportOpen()}catch(e){this.logger.warn(e,e==null?void 0:e.message)}}get context(){return(0,ce.Fd)(this.logger)}get connected(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===1||!1}get connecting(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===0||this.connectPromise!==void 0||!1}async publish(e,t,s){this.isInitialized(),await this.publisher.publish(e,t,s),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now(),transportType:Re.relay},xn.outbound)}async subscribe(e,t){var s,r,o;this.isInitialized(),(!(t!=null&&t.transportType)||(t==null?void 0:t.transportType)==="relay")&&await this.toEstablishConnection();const a=typeof((s=t==null?void 0:t.internal)==null?void 0:s.throwOnFailedPublish)>"u"?!0:(r=t==null?void 0:t.internal)==null?void 0:r.throwOnFailedPublish;let c=((o=this.subscriber.topicMap.get(e))==null?void 0:o[0])||"",h;const u=d=>{d.topic===e&&(this.subscriber.off(wt.created,u),h())};return await Promise.all([new Promise(d=>{h=d,this.subscriber.on(wt.created,u)}),new Promise(async(d,p)=>{c=await this.subscriber.subscribe(e,fc({internal:{throwOnFailedPublish:a}},t)).catch(f=>{a&&p(f)})||c,d()})]),c}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){this.provider.disconnect&&(this.hasExperiencedNetworkDisruption||this.connected)?await Vt(this.provider.disconnect(),2e3,"provider.disconnect()").catch(()=>this.onProviderDisconnect()):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){if(!this.subscriber.hasAnyTopics){this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");return}if(this.connectPromise?(this.logger.debug({},"Waiting for existing connection attempt to resolve..."),await this.connectPromise,this.logger.debug({},"Existing connection attempt resolved")):(this.connectPromise=new Promise(async(t,s)=>{await this.connect(e).then(t).catch(s).finally(()=>{this.connectPromise=void 0})}),await this.connectPromise),!this.connected)throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`)}async restartTransport(e){this.logger.debug({},"Restarting transport..."),!this.connectionAttemptInProgress&&(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await ka())throw new Error("No internet connection detected. Please restart your network and try again.")}async handleBatchMessageEvents(e){if((e==null?void 0:e.length)===0){this.logger.trace("Batch message events is empty. Ignoring...");return}const t=e.sort((s,r)=>s.publishedAt-r.publishedAt);this.logger.debug(`Batch of ${t.length} message events sorted`);for(const s of t)try{await this.onMessageEvent(s)}catch(r){this.logger.warn(r,"Error while processing batch message event: "+(r==null?void 0:r.message))}this.logger.trace(`Batch of ${t.length} message events processed`)}async onLinkMessageEvent(e,t){const{topic:s}=e;if(!t.sessionExists){const r=Ne(C.FIVE_MINUTES),o={topic:s,expiry:r,relay:{protocol:"irn"},active:!1};await this.core.pairing.pairings.set(s,o)}this.events.emit(We.message,e),await this.recordMessageEvent(e,xn.inbound)}async connect(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect()),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;let t=1;for(;t<6;){try{if(this.transportExplicitlyClosed)break;this.logger.debug({},`Connecting to ${this.relayUrl}, attempt: ${t}...`),await this.createProvider(),await new Promise(async(s,r)=>{const o=()=>{r(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(St.disconnect,o),await Vt(new Promise((a,c)=>{this.provider.connect().then(a).catch(c)}),this.connectTimeout,`Socket stalled when trying to connect to ${this.relayUrl}`).catch(a=>{r(a)}).finally(()=>{this.provider.off(St.disconnect,o),clearTimeout(this.reconnectTimeout)}),await new Promise(async(a,c)=>{const h=()=>{c(new Error("Connection interrupted while trying to subscribe"))};this.provider.once(St.disconnect,h),await this.subscriber.start().then(a).catch(c).finally(()=>{this.provider.off(St.disconnect,h)})}),this.hasExperiencedNetworkDisruption=!1,s()})}catch(s){await this.subscriber.stop();const r=s;this.logger.warn({},r.message),this.hasExperiencedNetworkDisruption=!0}finally{this.connectionAttemptInProgress=!1}if(this.connected){this.logger.debug({},`Connected to ${this.relayUrl} successfully on attempt: ${t}`);break}await new Promise(s=>setTimeout(s,(0,C.toMiliseconds)(t*1))),t++}}startPingTimeout(){var e,t,s,r,o;if(Hi())try{(t=(e=this.provider)==null?void 0:e.connection)!=null&&t.socket&&((o=(r=(s=this.provider)==null?void 0:s.connection)==null?void 0:r.socket)==null||o.on("ping",()=>{this.resetPingTimeout()})),this.resetPingTimeout()}catch(a){this.logger.warn(a,a==null?void 0:a.message)}}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new Pt.r(new qd.Z(go({sdkVersion:$r,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId,packageName:this.packageName}))),this.registerProviderListeners()}async recordMessageEvent(e,t){const{topic:s,message:r}=e;await this.messages.set(s,r,t)}async shouldIgnoreMessageEvent(e){const{topic:t,message:s}=e;if(!s||s.length===0)return this.logger.warn(`Ignoring invalid/empty message: ${s}`),!0;if(!await this.subscriber.isKnownTopic(t))return this.logger.warn(`Ignoring message for unknown topic ${t}`),!0;const r=this.messages.has(t,s);return r&&this.logger.warn(`Ignoring duplicate message: ${s}`),r}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),(0,J.isJsonRpcRequest)(e)){if(!e.method.endsWith(Jd))return;const t=e.params,{topic:s,message:r,publishedAt:o,attestation:a}=t.data,c={topic:s,message:r,publishedAt:o,transportType:Re.relay,attestation:a};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(fc({type:"event",event:t.id},c)),this.events.emit(t.id,c),await this.acknowledgePayload(e),await this.onMessageEvent(c)}else(0,J.isJsonRpcResponse)(e)&&this.events.emit(We.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(await this.recordMessageEvent(e,xn.inbound),this.events.emit(We.message,e))}async acknowledgePayload(e){const t=(0,J.formatJsonRpcResult)(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(St.payload,this.onPayloadHandler),this.provider.off(St.connect,this.onConnectHandler),this.provider.off(St.disconnect,this.onDisconnectHandler),this.provider.off(St.error,this.onProviderErrorHandler),clearTimeout(this.pingTimeout)}async registerEventListeners(){let e=await ka();cd(async t=>{e!==t&&(e=t,t?await this.transportOpen().catch(s=>this.logger.error(s,s==null?void 0:s.message)):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))}),this.core.heartbeat.on(ji.Lx.pulse,async()=>{if(!this.transportExplicitlyClosed&&!this.connected&&ud())try{await this.confirmOnlineStateOrThrow(),await this.transportOpen()}catch(t){this.logger.warn(t,t==null?void 0:t.message)}})}async onProviderDisconnect(){clearTimeout(this.pingTimeout),this.events.emit(We.disconnect),this.connectionAttemptInProgress=!1,!this.reconnectInProgress&&(this.reconnectInProgress=!0,await this.subscriber.stop(),this.subscriber.hasAnyTopics&&(this.transportExplicitlyClosed||(this.reconnectTimeout=setTimeout(async()=>{await this.transportOpen().catch(e=>this.logger.error(e,e==null?void 0:e.message)),this.reconnectTimeout=void 0,this.reconnectInProgress=!1},(0,C.toMiliseconds)(Zd)))))}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(await this.confirmOnlineStateOrThrow(),!this.connected){if(this.connectPromise){await this.connectPromise;return}await this.connect()}}}function _f(){}function yc(i){if(!i||typeof i!="object")return!1;const e=Object.getPrototypeOf(i);return e===null||e===Object.prototype||Object.getPrototypeOf(e)===null?Object.prototype.toString.call(i)==="[object Object]":!1}function mc(i){return Object.getOwnPropertySymbols(i).filter(e=>Object.prototype.propertyIsEnumerable.call(i,e))}function wc(i){return i==null?i===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(i)}const vf="[object RegExp]",bf="[object String]",Ef="[object Number]",xf="[object Boolean]",_c="[object Arguments]",If="[object Symbol]",Pf="[object Date]",Sf="[object Map]",Of="[object Set]",Af="[object Array]",Cf="[object Function]",Rf="[object ArrayBuffer]",zr="[object Object]",Nf="[object Error]",Tf="[object DataView]",$f="[object Uint8Array]",jf="[object Uint8ClampedArray]",Df="[object Uint16Array]",qf="[object Uint32Array]",Ff="[object BigUint64Array]",kf="[object Int8Array]",Lf="[object Int16Array]",Bf="[object Int32Array]",Uf="[object BigInt64Array]",Mf="[object Float32Array]",zf="[object Float64Array]";function Hf(i,e){return i===e||Number.isNaN(i)&&Number.isNaN(e)}function Kf(i,e,t){return Ks(i,e,void 0,void 0,void 0,void 0,t)}function Ks(i,e,t,s,r,o,a){const c=a(i,e,t,s,r,o);if(c!==void 0)return c;if(typeof i==typeof e)switch(typeof i){case"bigint":case"string":case"boolean":case"symbol":case"undefined":return i===e;case"number":return i===e||Object.is(i,e);case"function":return i===e;case"object":return Vs(i,e,o,a)}return Vs(i,e,o,a)}function Vs(i,e,t,s){if(Object.is(i,e))return!0;let r=wc(i),o=wc(e);if(r===_c&&(r=zr),o===_c&&(o=zr),r!==o)return!1;switch(r){case bf:return i.toString()===e.toString();case Ef:{const h=i.valueOf(),u=e.valueOf();return Hf(h,u)}case xf:case Pf:case If:return Object.is(i.valueOf(),e.valueOf());case vf:return i.source===e.source&&i.flags===e.flags;case Cf:return i===e}t=t??new Map;const a=t.get(i),c=t.get(e);if(a!=null&&c!=null)return a===e;t.set(i,e),t.set(e,i);try{switch(r){case Sf:{if(i.size!==e.size)return!1;for(const[h,u]of i.entries())if(!e.has(h)||!Ks(u,e.get(h),h,i,e,t,s))return!1;return!0}case Of:{if(i.size!==e.size)return!1;const h=Array.from(i.values()),u=Array.from(e.values());for(let d=0;d<h.length;d++){const p=h[d],f=u.findIndex(v=>Ks(p,v,void 0,i,e,t,s));if(f===-1)return!1;u.splice(f,1)}return!0}case Af:case $f:case jf:case Df:case qf:case Ff:case kf:case Lf:case Bf:case Uf:case Mf:case zf:{if(typeof Tr<"u"&&Tr.isBuffer(i)!==Tr.isBuffer(e)||i.length!==e.length)return!1;for(let h=0;h<i.length;h++)if(!Ks(i[h],e[h],h,i,e,t,s))return!1;return!0}case Rf:return i.byteLength!==e.byteLength?!1:Vs(new Uint8Array(i),new Uint8Array(e),t,s);case Tf:return i.byteLength!==e.byteLength||i.byteOffset!==e.byteOffset?!1:Vs(new Uint8Array(i),new Uint8Array(e),t,s);case Nf:return i.name===e.name&&i.message===e.message;case zr:{if(!(Vs(i.constructor,e.constructor,t,s)||yc(i)&&yc(e)))return!1;const h=[...Object.keys(i),...mc(i)],u=[...Object.keys(e),...mc(e)];if(h.length!==u.length)return!1;for(let d=0;d<h.length;d++){const p=h[d],f=i[p];if(!Object.hasOwn(e,p))return!1;const v=e[p];if(!Ks(f,v,p,i,e,t,s))return!1}return!0}default:return!1}}finally{t.delete(i),t.delete(e)}}function Vf(i,e){return Kf(i,e,_f)}var Gf=Object.defineProperty,vc=Object.getOwnPropertySymbols,Wf=Object.prototype.hasOwnProperty,Jf=Object.prototype.propertyIsEnumerable,Hr=(i,e,t)=>e in i?Gf(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,bc=(i,e)=>{for(var t in e||(e={}))Wf.call(e,t)&&Hr(i,t,e[t]);if(vc)for(var t of vc(e))Jf.call(e,t)&&Hr(i,t,e[t]);return i},gt=(i,e,t)=>Hr(i,typeof e!="symbol"?e+"":e,t);class ki extends xd{constructor(e,t,s,r=Wt,o=void 0){super(e,t,s,r),this.core=e,this.logger=t,this.name=s,gt(this,"map",new Map),gt(this,"version",Yd),gt(this,"cached",[]),gt(this,"initialized",!1),gt(this,"getKey"),gt(this,"storagePrefix",Wt),gt(this,"recentlyDeleted",[]),gt(this,"recentlyDeletedLimit",200),gt(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(a=>{this.getKey&&a!==null&&!tt(a)?this.map.set(this.getKey(a),a):Lu(a)?this.map.set(a.id,a):Bu(a)&&this.map.set(a.topic,a)}),this.cached=[],this.initialized=!0)}),gt(this,"set",async(a,c)=>{this.isInitialized(),this.map.has(a)?await this.update(a,c):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:a,value:c}),this.map.set(a,c),await this.persist())}),gt(this,"get",a=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:a}),this.getData(a))),gt(this,"getAll",a=>(this.isInitialized(),a?this.values.filter(c=>Object.keys(a).every(h=>Vf(c[h],a[h]))):this.values)),gt(this,"update",async(a,c)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:a,update:c});const h=bc(bc({},this.getData(a)),c);this.map.set(a,h),await this.persist()}),gt(this,"delete",async(a,c)=>{this.isInitialized(),this.map.has(a)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:a,reason:c}),this.map.delete(a),this.addToRecentlyDeleted(a),await this.persist())}),this.logger=(0,ce.Ep)(t,this.name),this.storagePrefix=r,this.getKey=o}get context(){return(0,ce.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:r}=L("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(r),new Error(r)}const{message:s}=L("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(s),new Error(s)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=L("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}}var Zf=Object.defineProperty,Yf=(i,e,t)=>e in i?Zf(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,he=(i,e,t)=>Yf(i,typeof e!="symbol"?e+"":e,t);class Qf{constructor(e,t){this.core=e,this.logger=t,he(this,"name",tp),he(this,"version",ip),he(this,"events",new(Ie())),he(this,"pairings"),he(this,"initialized",!1),he(this,"storagePrefix",Wt),he(this,"ignoredPayloadTypes",[ai]),he(this,"registeredMethods",[]),he(this,"init",async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))}),he(this,"register",({methods:s})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...s])]}),he(this,"create",async s=>{this.isInitialized();const r=Or(),o=await this.core.crypto.setSymKey(r),a=Ne(C.FIVE_MINUTES),c={protocol:Ka},h={topic:o,expiry:a,relay:c,active:!1,methods:s==null?void 0:s.methods},u=Ca({protocol:this.core.protocol,version:this.core.version,topic:o,symKey:r,relay:c,expiryTimestamp:a,methods:s==null?void 0:s.methods});return this.events.emit(Di.create,h),this.core.expirer.set(o,a),await this.pairings.set(o,h),await this.core.relayer.subscribe(o,{transportType:s==null?void 0:s.transportType}),{topic:o,uri:u}}),he(this,"pair",async s=>{this.isInitialized();const r=this.core.eventClient.createEvent({properties:{topic:s==null?void 0:s.uri,trace:[Jt.pairing_started]}});this.isValidPair(s,r);const{topic:o,symKey:a,relay:c,expiryTimestamp:h,methods:u}=Aa(s.uri);r.props.properties.topic=o,r.addTrace(Jt.pairing_uri_validation_success),r.addTrace(Jt.pairing_uri_not_expired);let d;if(this.pairings.keys.includes(o)){if(d=this.pairings.get(o),r.addTrace(Jt.existing_pairing),d.active)throw r.setError(ci.active_pairing_already_exists),new Error(`Pairing already exists: ${o}. Please try again with a new connection URI.`);r.addTrace(Jt.pairing_not_expired)}const p=h||Ne(C.FIVE_MINUTES),f={topic:o,relay:c,expiry:p,active:!1,methods:u};this.core.expirer.set(o,p),await this.pairings.set(o,f),r.addTrace(Jt.store_new_pairing),s.activatePairing&&await this.activate({topic:o}),this.events.emit(Di.create,f),r.addTrace(Jt.emit_inactive_pairing),this.core.crypto.keychain.has(o)||await this.core.crypto.setSymKey(a,o),r.addTrace(Jt.subscribing_pairing_topic);try{await this.core.relayer.confirmOnlineStateOrThrow()}catch{r.setError(ci.no_internet_connection)}try{await this.core.relayer.subscribe(o,{relay:c})}catch(v){throw r.setError(ci.subscribe_pairing_topic_failure),v}return r.addTrace(Jt.subscribe_pairing_topic_success),f}),he(this,"activate",async({topic:s})=>{this.isInitialized();const r=Ne(C.FIVE_MINUTES);this.core.expirer.set(s,r),await this.pairings.update(s,{active:!0,expiry:r})}),he(this,"ping",async s=>{this.isInitialized(),await this.isValidPing(s),this.logger.warn("ping() is deprecated and will be removed in the next major release.");const{topic:r}=s;if(this.pairings.keys.includes(r)){const o=await this.sendRequest(r,"wc_pairingPing",{}),{done:a,resolve:c,reject:h}=ti();this.events.once(pe("pairing_ping",o),({error:u})=>{u?h(u):c()}),await a()}}),he(this,"updateExpiry",async({topic:s,expiry:r})=>{this.isInitialized(),await this.pairings.update(s,{expiry:r})}),he(this,"updateMetadata",async({topic:s,metadata:r})=>{this.isInitialized(),await this.pairings.update(s,{peerMetadata:r})}),he(this,"getPairings",()=>(this.isInitialized(),this.pairings.values)),he(this,"disconnect",async s=>{this.isInitialized(),await this.isValidDisconnect(s);const{topic:r}=s;this.pairings.keys.includes(r)&&(await this.sendRequest(r,"wc_pairingDelete",_e("USER_DISCONNECTED")),await this.deletePairing(r))}),he(this,"formatUriFromPairing",s=>{this.isInitialized();const{topic:r,relay:o,expiry:a,methods:c}=s,h=this.core.crypto.keychain.get(r);return Ca({protocol:this.core.protocol,version:this.core.version,topic:r,symKey:h,relay:o,expiryTimestamp:a,methods:c})}),he(this,"sendRequest",async(s,r,o)=>{const a=(0,J.formatJsonRpcRequest)(r,o),c=await this.core.crypto.encode(s,a),h=Bs[r].req;return this.core.history.set(s,a),this.core.relayer.publish(s,c,h),a.id}),he(this,"sendResult",async(s,r,o)=>{const a=(0,J.formatJsonRpcResult)(s,o),c=await this.core.crypto.encode(r,a),h=(await this.core.history.get(r,s)).request.method,u=Bs[h].res;await this.core.relayer.publish(r,c,u),await this.core.history.resolve(a)}),he(this,"sendError",async(s,r,o)=>{const a=(0,J.formatJsonRpcError)(s,o),c=await this.core.crypto.encode(r,a),h=(await this.core.history.get(r,s)).request.method,u=Bs[h]?Bs[h].res:Bs.unregistered_method.res;await this.core.relayer.publish(r,c,u),await this.core.history.resolve(a)}),he(this,"deletePairing",async(s,r)=>{await this.core.relayer.unsubscribe(s),await Promise.all([this.pairings.delete(s,_e("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(s),r?Promise.resolve():this.core.expirer.del(s)])}),he(this,"cleanup",async()=>{const s=this.pairings.getAll().filter(r=>$t(r.expiry));await Promise.all(s.map(r=>this.deletePairing(r.topic)))}),he(this,"onRelayEventRequest",async s=>{const{topic:r,payload:o}=s;switch(o.method){case"wc_pairingPing":return await this.onPairingPingRequest(r,o);case"wc_pairingDelete":return await this.onPairingDeleteRequest(r,o);default:return await this.onUnknownRpcMethodRequest(r,o)}}),he(this,"onRelayEventResponse",async s=>{const{topic:r,payload:o}=s,a=(await this.core.history.get(r,o.id)).request.method;switch(a){case"wc_pairingPing":return this.onPairingPingResponse(r,o);default:return this.onUnknownRpcMethodResponse(a)}}),he(this,"onPairingPingRequest",async(s,r)=>{const{id:o}=r;try{this.isValidPing({topic:s}),await this.sendResult(o,s,!0),this.events.emit(Di.ping,{id:o,topic:s})}catch(a){await this.sendError(o,s,a),this.logger.error(a)}}),he(this,"onPairingPingResponse",(s,r)=>{const{id:o}=r;setTimeout(()=>{(0,J.isJsonRpcResult)(r)?this.events.emit(pe("pairing_ping",o),{}):(0,J.isJsonRpcError)(r)&&this.events.emit(pe("pairing_ping",o),{error:r.error})},500)}),he(this,"onPairingDeleteRequest",async(s,r)=>{const{id:o}=r;try{this.isValidDisconnect({topic:s}),await this.deletePairing(s),this.events.emit(Di.delete,{id:o,topic:s})}catch(a){await this.sendError(o,s,a),this.logger.error(a)}}),he(this,"onUnknownRpcMethodRequest",async(s,r)=>{const{id:o,method:a}=r;try{if(this.registeredMethods.includes(a))return;const c=_e("WC_METHOD_UNSUPPORTED",a);await this.sendError(o,s,c),this.logger.error(c)}catch(c){await this.sendError(o,s,c),this.logger.error(c)}}),he(this,"onUnknownRpcMethodResponse",s=>{this.registeredMethods.includes(s)||this.logger.error(_e("WC_METHOD_UNSUPPORTED",s))}),he(this,"isValidPair",(s,r)=>{var o;if(!pt(s)){const{message:c}=L("MISSING_OR_INVALID",`pair() params: ${s}`);throw r.setError(ci.malformed_pairing_uri),new Error(c)}if(!ku(s.uri)){const{message:c}=L("MISSING_OR_INVALID",`pair() uri: ${s.uri}`);throw r.setError(ci.malformed_pairing_uri),new Error(c)}const a=Aa(s==null?void 0:s.uri);if(!((o=a==null?void 0:a.relay)!=null&&o.protocol)){const{message:c}=L("MISSING_OR_INVALID","pair() uri#relay-protocol");throw r.setError(ci.malformed_pairing_uri),new Error(c)}if(!(a!=null&&a.symKey)){const{message:c}=L("MISSING_OR_INVALID","pair() uri#symKey");throw r.setError(ci.malformed_pairing_uri),new Error(c)}if(a!=null&&a.expiryTimestamp&&(0,C.toMiliseconds)(a==null?void 0:a.expiryTimestamp)<Date.now()){r.setError(ci.pairing_expired);const{message:c}=L("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(c)}}),he(this,"isValidPing",async s=>{if(!pt(s)){const{message:o}=L("MISSING_OR_INVALID",`ping() params: ${s}`);throw new Error(o)}const{topic:r}=s;await this.isValidPairingTopic(r)}),he(this,"isValidDisconnect",async s=>{if(!pt(s)){const{message:o}=L("MISSING_OR_INVALID",`disconnect() params: ${s}`);throw new Error(o)}const{topic:r}=s;await this.isValidPairingTopic(r)}),he(this,"isValidPairingTopic",async s=>{if(!ke(s,!1)){const{message:r}=L("MISSING_OR_INVALID",`pairing topic should be a string: ${s}`);throw new Error(r)}if(!this.pairings.keys.includes(s)){const{message:r}=L("NO_MATCHING_KEY",`pairing topic doesn't exist: ${s}`);throw new Error(r)}if($t(this.pairings.get(s).expiry)){await this.deletePairing(s);const{message:r}=L("EXPIRED",`pairing topic: ${s}`);throw new Error(r)}}),this.core=e,this.logger=(0,ce.Ep)(t,this.name),this.pairings=new ki(this.core,this.logger,this.name,this.storagePrefix)}get context(){return(0,ce.Fd)(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(We.message,async e=>{const{topic:t,message:s,transportType:r}=e;if(this.pairings.keys.includes(t)&&r!==Re.link_mode&&!this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s)))try{const o=await this.core.crypto.decode(t,s);(0,J.isJsonRpcRequest)(o)?(this.core.history.set(t,o),await this.onRelayEventRequest({topic:t,payload:o})):(0,J.isJsonRpcResponse)(o)&&(await this.core.history.resolve(o),await this.onRelayEventResponse({topic:t,payload:o}),this.core.history.delete(t,o.id)),await this.core.relayer.messages.ack(t,s)}catch(o){this.logger.error(o)}})}registerExpirerEvents(){this.core.expirer.on(Ot.expired,async e=>{const{topic:t}=Xs(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(Di.expire,{topic:t}))})}}var Xf=Object.defineProperty,ey=(i,e,t)=>e in i?Xf(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,nt=(i,e,t)=>ey(i,typeof e!="symbol"?e+"":e,t);class ty extends _d{constructor(e,t){super(e,t),this.core=e,this.logger=t,nt(this,"records",new Map),nt(this,"events",new xe.EventEmitter),nt(this,"name",sp),nt(this,"version",np),nt(this,"cached",[]),nt(this,"initialized",!1),nt(this,"storagePrefix",Wt),nt(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.records.set(s.id,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),nt(this,"set",(s,r,o)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:s,request:r,chainId:o}),this.records.has(r.id))return;const a={id:r.id,topic:s,request:{method:r.method,params:r.params||null},chainId:o,expiry:Ne(C.THIRTY_DAYS)};this.records.set(a.id,a),this.persist(),this.events.emit(Ft.created,a)}),nt(this,"resolve",async s=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:s}),!this.records.has(s.id))return;const r=await this.getRecord(s.id);typeof r.response>"u"&&(r.response=(0,J.isJsonRpcError)(s)?{error:s.error}:{result:s.result},this.records.set(r.id,r),this.persist(),this.events.emit(Ft.updated,r))}),nt(this,"get",async(s,r)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:s,id:r}),await this.getRecord(r))),nt(this,"delete",(s,r)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:r}),this.values.forEach(o=>{if(o.topic===s){if(typeof r<"u"&&o.id!==r)return;this.records.delete(o.id),this.events.emit(Ft.deleted,o)}}),this.persist()}),nt(this,"exists",async(s,r)=>(this.isInitialized(),this.records.has(r)?(await this.getRecord(r)).topic===s:!1)),nt(this,"on",(s,r)=>{this.events.on(s,r)}),nt(this,"once",(s,r)=>{this.events.once(s,r)}),nt(this,"off",(s,r)=>{this.events.off(s,r)}),nt(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),this.logger=(0,ce.Ep)(t,this.name)}get context(){return(0,ce.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const s={topic:t.topic,request:(0,J.formatJsonRpcRequest)(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(s)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:s}=L("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(Ft.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=L("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(Ft.created,e=>{const t=Ft.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(Ft.updated,e=>{const t=Ft.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(Ft.deleted,e=>{const t=Ft.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.core.heartbeat.on(ji.Lx.pulse,()=>{this.cleanup()})}cleanup(){try{this.isInitialized();let e=!1;this.records.forEach(t=>{(0,C.toMiliseconds)(t.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${t.id}`),this.records.delete(t.id),this.events.emit(Ft.deleted,t,!1),e=!0)}),e&&this.persist()}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}}var iy=Object.defineProperty,sy=(i,e,t)=>e in i?iy(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,at=(i,e,t)=>sy(i,typeof e!="symbol"?e+"":e,t);class ny extends Ad{constructor(e,t){super(e,t),this.core=e,this.logger=t,at(this,"expirations",new Map),at(this,"events",new xe.EventEmitter),at(this,"name",rp),at(this,"version",op),at(this,"cached",[]),at(this,"initialized",!1),at(this,"storagePrefix",Wt),at(this,"init",async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.expirations.set(s.target,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)}),at(this,"has",s=>{try{const r=this.formatTarget(s);return typeof this.getExpiration(r)<"u"}catch{return!1}}),at(this,"set",(s,r)=>{this.isInitialized();const o=this.formatTarget(s),a={target:o,expiry:r};this.expirations.set(o,a),this.checkExpiry(o,a),this.events.emit(Ot.created,{target:o,expiration:a})}),at(this,"get",s=>{this.isInitialized();const r=this.formatTarget(s);return this.getExpiration(r)}),at(this,"del",s=>{if(this.isInitialized(),this.has(s)){const r=this.formatTarget(s),o=this.getExpiration(r);this.expirations.delete(r),this.events.emit(Ot.deleted,{target:r,expiration:o})}}),at(this,"on",(s,r)=>{this.events.on(s,r)}),at(this,"once",(s,r)=>{this.events.once(s,r)}),at(this,"off",(s,r)=>{this.events.off(s,r)}),at(this,"removeListener",(s,r)=>{this.events.removeListener(s,r)}),this.logger=(0,ce.Ep)(t,this.name)}get context(){return(0,ce.Fd)(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return Jn(e);if(typeof e=="number")return Zn(e);const{message:t}=L("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(Ot.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=L("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:s}=L("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(s),new Error(s)}return t}checkExpiry(e,t){const{expiry:s}=t;(0,C.toMiliseconds)(s)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(Ot.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(ji.Lx.pulse,()=>this.checkExpirations()),this.events.on(Ot.created,e=>{const t=Ot.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(Ot.expired,e=>{const t=Ot.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(Ot.deleted,e=>{const t=Ot.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}}var ry=Object.defineProperty,oy=(i,e,t)=>e in i?ry(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Le=(i,e,t)=>oy(i,typeof e!="symbol"?e+"":e,t);class ay extends Cd{constructor(e,t,s){super(e,t,s),this.core=e,this.logger=t,this.store=s,Le(this,"name",ap),Le(this,"abortController"),Le(this,"isDevEnv"),Le(this,"verifyUrlV3",hp),Le(this,"storagePrefix",Wt),Le(this,"version",Ma),Le(this,"publicKey"),Le(this,"fetchPromise"),Le(this,"init",async()=>{var r;this.isDevEnv||(this.publicKey=await this.store.getItem(this.storeKey),this.publicKey&&(0,C.toMiliseconds)((r=this.publicKey)==null?void 0:r.expiresAt)<Date.now()&&(this.logger.debug("verify v2 public key expired"),await this.removePublicKey()))}),Le(this,"register",async r=>{if(!fi()||this.isDevEnv)return;const o=window.location.origin,{id:a,decryptedId:c}=r,h=`${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${o}&id=${a}&decryptedId=${c}`;try{const u=(0,Te.getDocument)(),d=this.startAbortTimer(C.ONE_SECOND*5),p=await new Promise((f,v)=>{const w=()=>{window.removeEventListener("message",_),u.body.removeChild(b),v("attestation aborted")};this.abortController.signal.addEventListener("abort",w);const b=u.createElement("iframe");b.src=h,b.style.display="none",b.addEventListener("error",w,{signal:this.abortController.signal});const _=x=>{if(x.data&&typeof x.data=="string")try{const E=JSON.parse(x.data);if(E.type==="verify_attestation"){if((0,He.xp)(E.attestation).payload.id!==a)return;clearInterval(d),u.body.removeChild(b),this.abortController.signal.removeEventListener("abort",w),window.removeEventListener("message",_),f(E.attestation===null?"":E.attestation)}}catch(E){this.logger.warn(E)}};u.body.appendChild(b),window.addEventListener("message",_,{signal:this.abortController.signal})});return this.logger.debug("jwt attestation",p),p}catch(u){this.logger.warn(u)}return""}),Le(this,"resolve",async r=>{if(this.isDevEnv)return"";const{attestationId:o,hash:a,encryptedId:c}=r;if(o===""){this.logger.debug("resolve: attestationId is empty, skipping");return}if(o){if((0,He.xp)(o).payload.id!==c)return;const u=await this.isValidJwtAttestation(o);if(u){if(!u.isVerified){this.logger.warn("resolve: jwt attestation: origin url not verified");return}return u}}if(!a)return;const h=this.getVerifyUrl(r==null?void 0:r.verifyUrl);return this.fetchAttestation(a,h)}),Le(this,"fetchAttestation",async(r,o)=>{this.logger.debug(`resolving attestation: ${r} from url: ${o}`);const a=this.startAbortTimer(C.ONE_SECOND*5),c=await fetch(`${o}/attestation/${r}?v2Supported=true`,{signal:this.abortController.signal});return clearTimeout(a),c.status===200?await c.json():void 0}),Le(this,"getVerifyUrl",r=>{let o=r||Us;return lp.includes(o)||(this.logger.info(`verify url: ${o}, not included in trusted list, assigning default: ${Us}`),o=Us),o}),Le(this,"fetchPublicKey",async()=>{try{this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);const r=this.startAbortTimer(C.FIVE_SECONDS),o=await fetch(`${this.verifyUrlV3}/public-key`,{signal:this.abortController.signal});return clearTimeout(r),await o.json()}catch(r){this.logger.warn(r)}}),Le(this,"persistPublicKey",async r=>{this.logger.debug("persisting public key to local storage",r),await this.store.setItem(this.storeKey,r),this.publicKey=r}),Le(this,"removePublicKey",async()=>{this.logger.debug("removing verify v2 public key from storage"),await this.store.removeItem(this.storeKey),this.publicKey=void 0}),Le(this,"isValidJwtAttestation",async r=>{const o=await this.getPublicKey();try{if(o)return this.validateAttestation(r,o)}catch(c){this.logger.error(c),this.logger.warn("error validating attestation")}const a=await this.fetchAndPersistPublicKey();try{if(a)return this.validateAttestation(r,a)}catch(c){this.logger.error(c),this.logger.warn("error validating attestation")}}),Le(this,"getPublicKey",async()=>this.publicKey?this.publicKey:await this.fetchAndPersistPublicKey()),Le(this,"fetchAndPersistPublicKey",async()=>{if(this.fetchPromise)return await this.fetchPromise,this.publicKey;this.fetchPromise=new Promise(async o=>{const a=await this.fetchPublicKey();a&&(await this.persistPublicKey(a),o(a))});const r=await this.fetchPromise;return this.fetchPromise=void 0,r}),Le(this,"validateAttestation",(r,o)=>{const a=mu(r,o.publicKey),c={hasExpired:(0,C.toMiliseconds)(a.exp)<Date.now(),payload:a};if(c.hasExpired)throw this.logger.warn("resolve: jwt attestation expired"),new Error("JWT attestation expired");return{origin:c.payload.origin,isScam:c.payload.isScam,isVerified:c.payload.isVerified}}),this.logger=(0,ce.Ep)(t,this.name),this.abortController=new AbortController,this.isDevEnv=tn(),this.init()}get storeKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//verify:public:key"}get context(){return(0,ce.Fd)(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),(0,C.toMiliseconds)(e))}}var cy=Object.defineProperty,hy=(i,e,t)=>e in i?cy(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ec=(i,e,t)=>hy(i,typeof e!="symbol"?e+"":e,t);class ly extends Rd{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,Ec(this,"context",up),Ec(this,"registerDeviceToken",async s=>{const{clientId:r,token:o,notificationType:a,enableEncrypted:c=!1}=s,h=`${dp}/${this.projectId}/clients`;await fetch(h,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:r,type:a,token:o,always_raw:c})})}),this.logger=(0,ce.Ep)(t,this.context)}}var uy=Object.defineProperty,xc=Object.getOwnPropertySymbols,dy=Object.prototype.hasOwnProperty,py=Object.prototype.propertyIsEnumerable,Kr=(i,e,t)=>e in i?uy(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Gs=(i,e)=>{for(var t in e||(e={}))dy.call(e,t)&&Kr(i,t,e[t]);if(xc)for(var t of xc(e))py.call(e,t)&&Kr(i,t,e[t]);return i},Je=(i,e,t)=>Kr(i,typeof e!="symbol"?e+"":e,t);class gy extends Nd{constructor(e,t,s=!0){super(e,t,s),this.core=e,this.logger=t,Je(this,"context",gp),Je(this,"storagePrefix",Wt),Je(this,"storageVersion",pp),Je(this,"events",new Map),Je(this,"shouldPersist",!1),Je(this,"init",async()=>{if(!tn())try{const r={eventId:en(),timestamp:Date.now(),domain:this.getAppDomain(),props:{event:"INIT",type:"",properties:{client_id:await this.core.crypto.getClientId(),user_agent:Kn(this.core.relayer.protocol,this.core.relayer.version,$r)}}};await this.sendEvent([r])}catch(r){this.logger.warn(r)}}),Je(this,"createEvent",r=>{const{event:o="ERROR",type:a="",properties:{topic:c,trace:h}}=r,u=en(),d=this.core.projectId||"",p=Date.now(),f=Gs({eventId:u,timestamp:p,props:{event:o,type:a,properties:{topic:c,trace:h}},bundleId:d,domain:this.getAppDomain()},this.setMethods(u));return this.telemetryEnabled&&(this.events.set(u,f),this.shouldPersist=!0),f}),Je(this,"getEvent",r=>{const{eventId:o,topic:a}=r;if(o)return this.events.get(o);const c=Array.from(this.events.values()).find(h=>h.props.properties.topic===a);if(c)return Gs(Gs({},c),this.setMethods(c.eventId))}),Je(this,"deleteEvent",r=>{const{eventId:o}=r;this.events.delete(o),this.shouldPersist=!0}),Je(this,"setEventListeners",()=>{this.core.heartbeat.on(ji.Lx.pulse,async()=>{this.shouldPersist&&await this.persist(),this.events.forEach(r=>{(0,C.fromMiliseconds)(Date.now())-(0,C.fromMiliseconds)(r.timestamp)>fp&&(this.events.delete(r.eventId),this.shouldPersist=!0)})})}),Je(this,"setMethods",r=>({addTrace:o=>this.addTrace(r,o),setError:o=>this.setError(r,o)})),Je(this,"addTrace",(r,o)=>{const a=this.events.get(r);a&&(a.props.properties.trace.push(o),this.events.set(r,a),this.shouldPersist=!0)}),Je(this,"setError",(r,o)=>{const a=this.events.get(r);a&&(a.props.type=o,a.timestamp=Date.now(),this.events.set(r,a),this.shouldPersist=!0)}),Je(this,"persist",async()=>{await this.core.storage.setItem(this.storageKey,Array.from(this.events.values())),this.shouldPersist=!1}),Je(this,"restore",async()=>{try{const r=await this.core.storage.getItem(this.storageKey)||[];if(!r.length)return;r.forEach(o=>{this.events.set(o.eventId,Gs(Gs({},o),this.setMethods(o.eventId)))})}catch(r){this.logger.warn(r)}}),Je(this,"submit",async()=>{if(!this.telemetryEnabled||this.events.size===0)return;const r=[];for(const[o,a]of this.events)a.props.type&&r.push(a);if(r.length!==0)try{if((await this.sendEvent(r)).ok)for(const o of r)this.events.delete(o.eventId),this.shouldPersist=!0}catch(o){this.logger.warn(o)}}),Je(this,"sendEvent",async r=>{const o=this.getAppDomain()?"":"&sp=desktop";return await fetch(`${yp}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${$r}${o}`,{method:"POST",body:JSON.stringify(r)})}),Je(this,"getAppDomain",()=>Ss().url),this.logger=(0,ce.Ep)(t,this.context),this.telemetryEnabled=s,s?this.restore().then(async()=>{await this.submit(),this.setEventListeners()}):this.persist()}get storageKey(){return this.storagePrefix+this.storageVersion+this.core.customStoragePrefix+"//"+this.context}}var fy=Object.defineProperty,Ic=Object.getOwnPropertySymbols,yy=Object.prototype.hasOwnProperty,my=Object.prototype.propertyIsEnumerable,Vr=(i,e,t)=>e in i?fy(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Pc=(i,e)=>{for(var t in e||(e={}))yy.call(e,t)&&Vr(i,t,e[t]);if(Ic)for(var t of Ic(e))my.call(e,t)&&Vr(i,t,e[t]);return i},Se=(i,e,t)=>Vr(i,typeof e!="symbol"?e+"":e,t);class Gr extends fd{constructor(e){var t;super(e),Se(this,"protocol",Ua),Se(this,"version",Ma),Se(this,"name",En),Se(this,"relayUrl"),Se(this,"projectId"),Se(this,"customStoragePrefix"),Se(this,"events",new xe.EventEmitter),Se(this,"logger"),Se(this,"heartbeat"),Se(this,"relayer"),Se(this,"crypto"),Se(this,"storage"),Se(this,"history"),Se(this,"expirer"),Se(this,"pairing"),Se(this,"verify"),Se(this,"echoClient"),Se(this,"linkModeSupportedApps"),Se(this,"eventClient"),Se(this,"initialized",!1),Se(this,"logChunkController"),Se(this,"on",(c,h)=>this.events.on(c,h)),Se(this,"once",(c,h)=>this.events.once(c,h)),Se(this,"off",(c,h)=>this.events.off(c,h)),Se(this,"removeListener",(c,h)=>this.events.removeListener(c,h)),Se(this,"dispatchEnvelope",({topic:c,message:h,sessionExists:u})=>{if(!c||!h)return;const d={topic:c,message:h,publishedAt:Date.now(),transportType:Re.link_mode};this.relayer.onLinkMessageEvent(d,{sessionExists:u})});const s=this.getGlobalCore(e==null?void 0:e.customStoragePrefix);if(s)try{return this.customStoragePrefix=s.customStoragePrefix,this.logger=s.logger,this.heartbeat=s.heartbeat,this.crypto=s.crypto,this.history=s.history,this.expirer=s.expirer,this.storage=s.storage,this.relayer=s.relayer,this.pairing=s.pairing,this.verify=s.verify,this.echoClient=s.echoClient,this.linkModeSupportedApps=s.linkModeSupportedApps,this.eventClient=s.eventClient,this.initialized=s.initialized,this.logChunkController=s.logChunkController,s}catch(c){console.warn("Failed to copy global core",c)}this.projectId=e==null?void 0:e.projectId,this.relayUrl=(e==null?void 0:e.relayUrl)||Va,this.customStoragePrefix=e!=null&&e.customStoragePrefix?`:${e.customStoragePrefix}`:"";const r=(0,ce.jI)({level:typeof(e==null?void 0:e.logger)=="string"&&e.logger?e.logger:kd.logger,name:En}),{logger:o,chunkLoggerController:a}=(0,ce.Rt)({opts:r,maxSizeInBytes:e==null?void 0:e.maxLogBlobSizeInBytes,loggerOverride:e==null?void 0:e.logger});this.logChunkController=a,(t=this.logChunkController)!=null&&t.downloadLogsBlobInBrowser&&(window.downloadLogsBlobInBrowser=async()=>{var c,h;(c=this.logChunkController)!=null&&c.downloadLogsBlobInBrowser&&((h=this.logChunkController)==null||h.downloadLogsBlobInBrowser({clientId:await this.crypto.getClientId()}))}),this.logger=(0,ce.Ep)(o,this.name),this.heartbeat=new ji.C$,this.crypto=new Hg(this,this.logger,e==null?void 0:e.keychain),this.history=new ty(this,this.logger),this.expirer=new ny(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new dd.Z(Pc(Pc({},Ld),e==null?void 0:e.storageOptions)),this.relayer=new wf({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new Qf(this,this.logger),this.verify=new ay(this,this.logger,this.storage),this.echoClient=new ly(this.projectId||"",this.logger),this.linkModeSupportedApps=[],this.eventClient=new gy(this,this.logger,e==null?void 0:e.telemetryEnabled),this.setGlobalCore(this)}static async init(e){const t=new Gr(e);await t.initialize();const s=await t.crypto.getClientId();return await t.storage.setItem(Qd,s),t}get context(){return(0,ce.Fd)(this.logger)}async start(){this.initialized||await this.initialize()}async getLogsBlob(){var e;return(e=this.logChunkController)==null?void 0:e.logsToBlob({clientId:await this.crypto.getClientId()})}async addLinkModeSupportedApp(e){this.linkModeSupportedApps.includes(e)||(this.linkModeSupportedApps.push(e),await this.storage.setItem(Ga,this.linkModeSupportedApps))}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.linkModeSupportedApps=await this.storage.getItem(Ga)||[],this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}getGlobalCore(e=""){try{if(this.isGlobalCoreDisabled())return;const t=`_walletConnectCore_${e}`,s=`${t}_count`;return globalThis[s]=(globalThis[s]||0)+1,globalThis[s]>1&&console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[s]} times.`),globalThis[t]}catch(t){console.warn("Failed to get global WalletConnect core",t);return}}setGlobalCore(e){var t;try{if(this.isGlobalCoreDisabled())return;const s=`_walletConnectCore_${((t=e.opts)==null?void 0:t.customStoragePrefix)||""}`;globalThis[s]=e}catch(s){console.warn("Failed to set global WalletConnect core",s)}}isGlobalCoreDisabled(){try{return typeof Fd<"u"&&{NODE_ENV:"production",PUBLIC_PATH:"/"}.DISABLE_GLOBAL_CORE==="true"}catch{return!0}}}const wy=Gr,Sc="wc",Oc=2,Ac="client",Wr=`${Sc}@${Oc}:${Ac}:`,Jr={name:Ac,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"},l_={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire",session_connect:"session_connect"},u_={database:":memory:"},Cc="WALLETCONNECT_DEEPLINK_CHOICE",d_={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},p_="history",g_="0.3",_y="proposal",f_=null,Rc="Proposal expired",vy="session",cs=C.SEVEN_DAYS,by="engine",Ze={wc_sessionPropose:{req:{ttl:C.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:C.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:C.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:C.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:C.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:C.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:C.ONE_DAY,prompt:!1,tag:1104},res:{ttl:C.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:C.ONE_DAY,prompt:!1,tag:1106},res:{ttl:C.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:C.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:C.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:C.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:C.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:C.ONE_DAY,prompt:!1,tag:1112},res:{ttl:C.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:C.ONE_DAY,prompt:!1,tag:1114},res:{ttl:C.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:C.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:C.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:C.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:C.FIVE_MINUTES,prompt:!1,tag:1119}}},Zr={min:C.FIVE_MINUTES,max:C.SEVEN_DAYS},Yt={idle:"IDLE",active:"ACTIVE"},Nc={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"}},Ey="request",xy=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],Iy="wc",y_=1.5,Py="auth",Sy="authKeys",Oy="pairingTopics",Ay="requests",Sn=`${Iy}@${1.5}:${Py}:`,An=`${Sn}:PUB_KEY`;var Cy=Object.defineProperty,Ry=Object.defineProperties,Ny=Object.getOwnPropertyDescriptors,Tc=Object.getOwnPropertySymbols,Ty=Object.prototype.hasOwnProperty,$y=Object.prototype.propertyIsEnumerable,Yr=(i,e,t)=>e in i?Cy(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ee=(i,e)=>{for(var t in e||(e={}))Ty.call(e,t)&&Yr(i,t,e[t]);if(Tc)for(var t of Tc(e))$y.call(e,t)&&Yr(i,t,e[t]);return i},ut=(i,e)=>Ry(i,Ny(e)),S=(i,e,t)=>Yr(i,typeof e!="symbol"?e+"":e,t);class jy extends Dd{constructor(e){super(e),S(this,"name",by),S(this,"events",new(Ie())),S(this,"initialized",!1),S(this,"requestQueue",{state:Yt.idle,queue:[]}),S(this,"sessionRequestQueue",{state:Yt.idle,queue:[]}),S(this,"requestQueueDelay",C.ONE_SECOND),S(this,"expectedPairingMethodMap",new Map),S(this,"recentlyDeletedMap",new Map),S(this,"recentlyDeletedLimit",200),S(this,"relayMessageCache",[]),S(this,"pendingSessions",new Map),S(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(Ze)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},(0,C.toMiliseconds)(this.requestQueueDelay)))}),S(this,"connect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const s=ut(Ee({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(s),s.optionalNamespaces=$u(s.requiredNamespaces,s.optionalNamespaces),s.requiredNamespaces={};const{pairingTopic:r,requiredNamespaces:o,optionalNamespaces:a,sessionProperties:c,scopedProperties:h,relays:u}=s;let d=r,p,f=!1;try{if(d){const O=this.client.core.pairing.pairings.get(d);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),f=O.active}}catch(O){throw this.client.logger.error(`connect() -> pairing.get(${d}) failed`),O}if(!d||!f){const{topic:O,uri:D}=await this.client.core.pairing.create();d=O,p=D}if(!d){const{message:O}=L("NO_MATCHING_KEY",`connect() pairing topic: ${d}`);throw new Error(O)}const v=await this.client.core.crypto.generateKeyPair(),w=Ze.wc_sessionPropose.req.ttl||C.FIVE_MINUTES,b=Ne(w),_=ut(Ee(Ee({requiredNamespaces:o,optionalNamespaces:a,relays:u??[{protocol:Ka}],proposer:{publicKey:v,metadata:this.client.metadata},expiryTimestamp:b,pairingTopic:d},c&&{sessionProperties:c}),h&&{scopedProperties:h}),{id:(0,J.payloadId)()}),x=pe("session_connect",_.id),{reject:E,resolve:R,done:T}=ti(w,Rc),k=({id:O})=>{O===_.id&&(this.client.events.off("proposal_expire",k),this.pendingSessions.delete(_.id),this.events.emit(x,{error:{message:Rc,code:0}}))};return this.client.events.on("proposal_expire",k),this.events.once(x,({error:O,session:D})=>{this.client.events.off("proposal_expire",k),O?E(O):D&&R(D)}),await this.sendRequest({topic:d,method:"wc_sessionPropose",params:_,throwOnFailedPublish:!0,clientRpcId:_.id}),await this.setProposal(_.id,_),{uri:p,approval:T}}),S(this,"pair",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(t)}catch(s){throw this.client.logger.error("pair() failed"),s}}),S(this,"approve",async t=>{var s,r,o;const a=this.client.core.eventClient.createEvent({properties:{topic:(s=t==null?void 0:t.id)==null?void 0:s.toString(),trace:[Lt.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(P){throw a.setError(qi.no_internet_connection),P}try{await this.isValidProposalId(t==null?void 0:t.id)}catch(P){throw this.client.logger.error(`approve() -> proposal.get(${t==null?void 0:t.id}) failed`),a.setError(qi.proposal_not_found),P}try{await this.isValidApprove(t)}catch(P){throw this.client.logger.error("approve() -> isValidApprove() failed"),a.setError(qi.session_approve_namespace_validation_failure),P}const{id:c,relayProtocol:h,namespaces:u,sessionProperties:d,scopedProperties:p,sessionConfig:f}=t,v=this.client.proposal.get(c);this.client.core.eventClient.deleteEvent({eventId:a.eventId});const{pairingTopic:w,proposer:b,requiredNamespaces:_,optionalNamespaces:x}=v;let E=(r=this.client.core.eventClient)==null?void 0:r.getEvent({topic:w});E||(E=(o=this.client.core.eventClient)==null?void 0:o.createEvent({type:Lt.session_approve_started,properties:{topic:w,trace:[Lt.session_approve_started,Lt.session_namespaces_validation_success]}}));const R=await this.client.core.crypto.generateKeyPair(),T=b.publicKey,k=await this.client.core.crypto.generateSharedKey(R,T),O=Ee(Ee(Ee({relay:{protocol:h??"irn"},namespaces:u,controller:{publicKey:R,metadata:this.client.metadata},expiry:Ne(cs)},d&&{sessionProperties:d}),p&&{scopedProperties:p}),f&&{sessionConfig:f}),D=Re.relay;E.addTrace(Lt.subscribing_session_topic);try{await this.client.core.relayer.subscribe(k,{transportType:D})}catch(P){throw E.setError(qi.subscribe_session_topic_failure),P}E.addTrace(Lt.subscribe_session_topic_success);const U=ut(Ee({},O),{topic:k,requiredNamespaces:_,optionalNamespaces:x,pairingTopic:w,acknowledged:!1,self:O.controller,peer:{publicKey:b.publicKey,metadata:b.metadata},controller:R,transportType:Re.relay});await this.client.session.set(k,U),E.addTrace(Lt.store_session);try{E.addTrace(Lt.publishing_session_settle),await this.sendRequest({topic:k,method:"wc_sessionSettle",params:O,throwOnFailedPublish:!0}).catch(P=>{throw E==null||E.setError(qi.session_settle_publish_failure),P}),E.addTrace(Lt.session_settle_publish_success),E.addTrace(Lt.publishing_session_approve),await this.sendResult({id:c,topic:w,result:{relay:{protocol:h??"irn"},responderPublicKey:R},throwOnFailedPublish:!0}).catch(P=>{throw E==null||E.setError(qi.session_approve_publish_failure),P}),E.addTrace(Lt.session_approve_publish_success)}catch(P){throw this.client.logger.error(P),this.client.session.delete(k,_e("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(k),P}return this.client.core.eventClient.deleteEvent({eventId:E.eventId}),await this.client.core.pairing.updateMetadata({topic:w,metadata:b.metadata}),await this.client.proposal.delete(c,_e("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:w}),await this.setExpiry(k,Ne(cs)),{topic:k,acknowledged:()=>Promise.resolve(this.client.session.get(k))}}),S(this,"reject",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(t)}catch(a){throw this.client.logger.error("reject() -> isValidReject() failed"),a}const{id:s,reason:r}=t;let o;try{o=this.client.proposal.get(s).pairingTopic}catch(a){throw this.client.logger.error(`reject() -> proposal.get(${s}) failed`),a}o&&(await this.sendError({id:s,topic:o,error:r,rpcOpts:Ze.wc_sessionPropose.reject}),await this.client.proposal.delete(s,_e("USER_DISCONNECTED")))}),S(this,"update",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(t)}catch(p){throw this.client.logger.error("update() -> isValidUpdate() failed"),p}const{topic:s,namespaces:r}=t,{done:o,resolve:a,reject:c}=ti(),h=(0,J.payloadId)(),u=(0,J.getBigIntRpcId)().toString(),d=this.client.session.get(s).namespaces;return this.events.once(pe("session_update",h),({error:p})=>{p?c(p):a()}),await this.client.session.update(s,{namespaces:r}),await this.sendRequest({topic:s,method:"wc_sessionUpdate",params:{namespaces:r},throwOnFailedPublish:!0,clientRpcId:h,relayRpcId:u}).catch(p=>{this.client.logger.error(p),this.client.session.update(s,{namespaces:d}),c(p)}),{acknowledged:o}}),S(this,"extend",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(t)}catch(h){throw this.client.logger.error("extend() -> isValidExtend() failed"),h}const{topic:s}=t,r=(0,J.payloadId)(),{done:o,resolve:a,reject:c}=ti();return this.events.once(pe("session_extend",r),({error:h})=>{h?c(h):a()}),await this.setExpiry(s,Ne(cs)),this.sendRequest({topic:s,method:"wc_sessionExtend",params:{},clientRpcId:r,throwOnFailedPublish:!0}).catch(h=>{c(h)}),{acknowledged:o}}),S(this,"request",async t=>{this.isInitialized();try{await this.isValidRequest(t)}catch(x){throw this.client.logger.error("request() -> isValidRequest() failed"),x}const{chainId:s,request:r,topic:o,expiry:a=Ze.wc_sessionRequest.req.ttl}=t,c=this.client.session.get(o);(c==null?void 0:c.transportType)===Re.relay&&await this.confirmOnlineStateOrThrow();const h=(0,J.payloadId)(),u=(0,J.getBigIntRpcId)().toString(),{done:d,resolve:p,reject:f}=ti(a,"Request expired. Please try again.");this.events.once(pe("session_request",h),({error:x,result:E})=>{x?f(x):p(E)});const v="wc_sessionRequest",w=this.getAppLinkIfEnabled(c.peer.metadata,c.transportType);if(w)return await this.sendRequest({clientRpcId:h,relayRpcId:u,topic:o,method:v,params:{request:ut(Ee({},r),{expiryTimestamp:Ne(a)}),chainId:s},expiry:a,throwOnFailedPublish:!0,appLink:w}).catch(x=>f(x)),this.client.events.emit("session_request_sent",{topic:o,request:r,chainId:s,id:h}),await d();const b={request:ut(Ee({},r),{expiryTimestamp:Ne(a)}),chainId:s},_=this.shouldSetTVF(v,b);return await Promise.all([new Promise(async x=>{await this.sendRequest(Ee({clientRpcId:h,relayRpcId:u,topic:o,method:v,params:b,expiry:a,throwOnFailedPublish:!0},_&&{tvf:this.getTVFParams(h,b)})).catch(E=>f(E)),this.client.events.emit("session_request_sent",{topic:o,request:r,chainId:s,id:h}),x()}),new Promise(async x=>{var E;if(!((E=c.sessionConfig)!=null&&E.disableDeepLink)){const R=await _o(this.client.core.storage,Cc);await Yn({id:h,topic:o,wcDeepLink:R})}x()}),d()]).then(x=>x[2])}),S(this,"respond",async t=>{this.isInitialized(),await this.isValidRespond(t);const{topic:s,response:r}=t,{id:o}=r,a=this.client.session.get(s);a.transportType===Re.relay&&await this.confirmOnlineStateOrThrow();const c=this.getAppLinkIfEnabled(a.peer.metadata,a.transportType);(0,J.isJsonRpcResult)(r)?await this.sendResult({id:o,topic:s,result:r.result,throwOnFailedPublish:!0,appLink:c}):(0,J.isJsonRpcError)(r)&&await this.sendError({id:o,topic:s,error:r.error,appLink:c}),this.cleanupAfterResponse(t)}),S(this,"ping",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(t)}catch(r){throw this.client.logger.error("ping() -> isValidPing() failed"),r}const{topic:s}=t;if(this.client.session.keys.includes(s)){const r=(0,J.payloadId)(),o=(0,J.getBigIntRpcId)().toString(),{done:a,resolve:c,reject:h}=ti();this.events.once(pe("session_ping",r),({error:u})=>{u?h(u):c()}),await Promise.all([this.sendRequest({topic:s,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:r,relayRpcId:o}),a()])}else this.client.core.pairing.pairings.keys.includes(s)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:s}))}),S(this,"emit",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(t);const{topic:s,event:r,chainId:o}=t,a=(0,J.getBigIntRpcId)().toString(),c=(0,J.payloadId)();await this.sendRequest({topic:s,method:"wc_sessionEvent",params:{event:r,chainId:o},throwOnFailedPublish:!0,relayRpcId:a,clientRpcId:c})}),S(this,"disconnect",async t=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(t);const{topic:s}=t;if(this.client.session.keys.includes(s))await this.sendRequest({topic:s,method:"wc_sessionDelete",params:_e("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:s,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(s))await this.client.core.pairing.disconnect({topic:s});else{const{message:r}=L("MISMATCHED_TOPIC",`Session or pairing topic not found: ${s}`);throw new Error(r)}}),S(this,"find",t=>(this.isInitialized(),this.client.session.getAll().filter(s=>qu(s,t)))),S(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),S(this,"authenticate",async(t,s)=>{var r;this.isInitialized(),this.isValidAuthenticate(t);const o=s&&this.client.core.linkModeSupportedApps.includes(s)&&((r=this.client.metadata.redirect)==null?void 0:r.linkMode),a=o?Re.link_mode:Re.relay;a===Re.relay&&await this.confirmOnlineStateOrThrow();const{chains:c,statement:h="",uri:u,domain:d,nonce:p,type:f,exp:v,nbf:w,methods:b=[],expiry:_}=t,x=[...t.resources||[]],{topic:E,uri:R}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:a});this.client.logger.info({message:"Generated new pairing",pairing:{topic:E,uri:R}});const T=await this.client.core.crypto.generateKeyPair(),k=fn(T);if(await Promise.all([this.client.auth.authKeys.set(An,{responseTopic:k,publicKey:T}),this.client.auth.pairingTopics.set(k,{topic:k,pairingTopic:E})]),await this.client.core.relayer.subscribe(k,{transportType:a}),this.client.logger.info(`sending request to new pairing topic: ${E}`),b.length>0){const{namespace:j}=Pe(c[0]);let Y=Bh(j,"request",b);Ji(x)&&(Y=Uh(Y,x.pop())),x.push(Y)}const O=_&&_>Ze.wc_sessionAuthenticate.req.ttl?_:Ze.wc_sessionAuthenticate.req.ttl,D={authPayload:{type:f??"caip122",chains:c,statement:h,aud:u,domain:d,version:"1",nonce:p,iat:new Date().toISOString(),exp:v,nbf:w,resources:x},requester:{publicKey:T,metadata:this.client.metadata},expiryTimestamp:Ne(O)},U={eip155:{chains:c,methods:[...new Set(["personal_sign",...b])],events:["chainChanged","accountsChanged"]}},P={requiredNamespaces:{},optionalNamespaces:U,relays:[{protocol:"irn"}],pairingTopic:E,proposer:{publicKey:T,metadata:this.client.metadata},expiryTimestamp:Ne(Ze.wc_sessionPropose.req.ttl),id:(0,J.payloadId)()},{done:Z,resolve:H,reject:V}=ti(O,"Request expired"),X=(0,J.payloadId)(),A=pe("session_connect",P.id),F=pe("session_request",X),q=async({error:j,session:Y})=>{this.events.off(F,M),j?V(j):Y&&H({session:Y})},M=async j=>{var Y,re,oe;if(await this.deletePendingAuthRequest(X,{message:"fulfilled",code:0}),j.error){const ze=_e("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return j.error.code===ze.code?void 0:(this.events.off(A,q),V(j.error.message))}await this.deleteProposal(P.id),this.events.off(A,q);const{cacaos:Oe,responder:me}=j.result,Be=[],Ye=[];for(const ze of Oe){await $o({cacao:ze,projectId:this.client.core.projectId})||(this.client.logger.error(ze,"Signature verification failed"),V(_e("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:Mi}=ze,hi=Ji(Mi.resources),Qt=[rr(Mi.iss)],li=an(Mi.iss);if(hi){const ui=ko(hi),qn=Lo(hi);Be.push(...ui),Qt.push(...qn)}for(const ui of Qt)Ye.push(`${ui}:${li}`)}const ct=await this.client.core.crypto.generateSharedKey(T,me.publicKey);let Me;Be.length>0&&(Me={topic:ct,acknowledged:!0,self:{publicKey:T,metadata:this.client.metadata},peer:me,controller:me.publicKey,expiry:Ne(cs),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:E,namespaces:Ta([...new Set(Be)],[...new Set(Ye)]),transportType:a},await this.client.core.relayer.subscribe(ct,{transportType:a}),await this.client.session.set(ct,Me),E&&await this.client.core.pairing.updateMetadata({topic:E,metadata:me.metadata}),Me=this.client.session.get(ct)),(Y=this.client.metadata.redirect)!=null&&Y.linkMode&&(re=me.metadata.redirect)!=null&&re.linkMode&&(oe=me.metadata.redirect)!=null&&oe.universal&&s&&(this.client.core.addLinkModeSupportedApp(me.metadata.redirect.universal),this.client.session.update(ct,{transportType:Re.link_mode})),H({auths:Oe,session:Me})};this.events.once(A,q),this.events.once(F,M);let K;try{if(o){const j=(0,J.formatJsonRpcRequest)("wc_sessionAuthenticate",D,X);this.client.core.history.set(E,j);const Y=await this.client.core.crypto.encode("",j,{type:Ds,encoding:Pi});K=mn(s,E,Y)}else await Promise.all([this.sendRequest({topic:E,method:"wc_sessionAuthenticate",params:D,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:X}),this.sendRequest({topic:E,method:"wc_sessionPropose",params:P,expiry:Ze.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:P.id})])}catch(j){throw this.events.off(A,q),this.events.off(F,M),j}return await this.setProposal(P.id,P),await this.setAuthRequest(X,{request:ut(Ee({},D),{verifyContext:{}}),pairingTopic:E,transportType:a}),{uri:K??R,response:Z}}),S(this,"approveSessionAuthenticate",async t=>{const{id:s,auths:r}=t,o=this.client.core.eventClient.createEvent({properties:{topic:s.toString(),trace:[Fi.authenticated_session_approve_started]}});try{this.isInitialized()}catch(_){throw o.setError(Ms.no_internet_connection),_}const a=this.getPendingAuthRequest(s);if(!a)throw o.setError(Ms.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${s}`);const c=a.transportType||Re.relay;c===Re.relay&&await this.confirmOnlineStateOrThrow();const h=a.requester.publicKey,u=await this.client.core.crypto.generateKeyPair(),d=fn(h),p={type:ai,receiverPublicKey:h,senderPublicKey:u},f=[],v=[];for(const _ of r){if(!await $o({cacao:_,projectId:this.client.core.projectId})){o.setError(Ms.invalid_cacao);const k=_e("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:s,topic:d,error:k,encodeOpts:p}),new Error(k.message)}o.addTrace(Fi.cacaos_verified);const{p:x}=_,E=Ji(x.resources),R=[rr(x.iss)],T=an(x.iss);if(E){const k=ko(E),O=Lo(E);f.push(...k),R.push(...O)}for(const k of R)v.push(`${k}:${T}`)}const w=await this.client.core.crypto.generateSharedKey(u,h);o.addTrace(Fi.create_authenticated_session_topic);let b;if((f==null?void 0:f.length)>0){b={topic:w,acknowledged:!0,self:{publicKey:u,metadata:this.client.metadata},peer:{publicKey:h,metadata:a.requester.metadata},controller:h,expiry:Ne(cs),authentication:r,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:a.pairingTopic,namespaces:Ta([...new Set(f)],[...new Set(v)]),transportType:c},o.addTrace(Fi.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(w,{transportType:c})}catch(_){throw o.setError(Ms.subscribe_authenticated_session_topic_failure),_}o.addTrace(Fi.subscribe_authenticated_session_topic_success),await this.client.session.set(w,b),o.addTrace(Fi.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:a.pairingTopic,metadata:a.requester.metadata})}o.addTrace(Fi.publishing_authenticated_session_approve);try{await this.sendResult({topic:d,id:s,result:{cacaos:r,responder:{publicKey:u,metadata:this.client.metadata}},encodeOpts:p,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(a.requester.metadata,c)})}catch(_){throw o.setError(Ms.authenticated_session_approve_publish_failure),_}return await this.client.auth.requests.delete(s,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:a.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:o.eventId}),{session:b}}),S(this,"rejectSessionAuthenticate",async t=>{this.isInitialized();const{id:s,reason:r}=t,o=this.getPendingAuthRequest(s);if(!o)throw new Error(`Could not find pending auth request with id ${s}`);o.transportType===Re.relay&&await this.confirmOnlineStateOrThrow();const a=o.requester.publicKey,c=await this.client.core.crypto.generateKeyPair(),h=fn(a),u={type:ai,receiverPublicKey:a,senderPublicKey:c};await this.sendError({id:s,topic:h,error:r,encodeOpts:u,rpcOpts:Ze.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(o.requester.metadata,o.transportType)}),await this.client.auth.requests.delete(s,{message:"rejected",code:0}),await this.client.proposal.delete(s,_e("USER_DISCONNECTED"))}),S(this,"formatAuthMessage",t=>{this.isInitialized();const{request:s,iss:r}=t;return jo(s,r)}),S(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)}),S(this,"cleanupDuplicatePairings",async t=>{if(t.pairingTopic)try{const s=this.client.core.pairing.pairings.get(t.pairingTopic),r=this.client.core.pairing.pairings.getAll().filter(o=>{var a,c;return((a=o.peerMetadata)==null?void 0:a.url)&&((c=o.peerMetadata)==null?void 0:c.url)===t.peer.metadata.url&&o.topic&&o.topic!==s.topic});if(r.length===0)return;this.client.logger.info(`Cleaning up ${r.length} duplicate pairing(s)`),await Promise.all(r.map(o=>this.client.core.pairing.disconnect({topic:o.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(s){this.client.logger.error(s)}}),S(this,"deleteSession",async t=>{var s;const{topic:r,expirerHasDeleted:o=!1,emitEvent:a=!0,id:c=0}=t,{self:h}=this.client.session.get(r);await this.client.core.relayer.unsubscribe(r),await this.client.session.delete(r,_e("USER_DISCONNECTED")),this.addToRecentlyDeleted(r,"session"),this.client.core.crypto.keychain.has(h.publicKey)&&await this.client.core.crypto.deleteKeyPair(h.publicKey),this.client.core.crypto.keychain.has(r)&&await this.client.core.crypto.deleteSymKey(r),o||this.client.core.expirer.del(r),this.client.core.storage.removeItem(Cc).catch(u=>this.client.logger.warn(u)),this.getPendingSessionRequests().forEach(u=>{u.topic===r&&this.deletePendingSessionRequest(u.id,_e("USER_DISCONNECTED"))}),r===((s=this.sessionRequestQueue.queue[0])==null?void 0:s.topic)&&(this.sessionRequestQueue.state=Yt.idle),a&&this.client.events.emit("session_delete",{id:c,topic:r})}),S(this,"deleteProposal",async(t,s)=>{if(s)try{const r=this.client.proposal.get(t),o=this.client.core.eventClient.getEvent({topic:r.pairingTopic});o==null||o.setError(qi.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,_e("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")}),S(this,"deletePendingSessionRequest",async(t,s,r=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,s),r?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(o=>o.id!==t),r&&(this.sessionRequestQueue.state=Yt.idle,this.client.events.emit("session_request_expire",{id:t}))}),S(this,"deletePendingAuthRequest",async(t,s,r=!1)=>{await Promise.all([this.client.auth.requests.delete(t,s),r?Promise.resolve():this.client.core.expirer.del(t)])}),S(this,"setExpiry",async(t,s)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,s),await this.client.session.update(t,{expiry:s}))}),S(this,"setProposal",async(t,s)=>{this.client.core.expirer.set(t,Ne(Ze.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,s)}),S(this,"setAuthRequest",async(t,s)=>{const{request:r,pairingTopic:o,transportType:a=Re.relay}=s;this.client.core.expirer.set(t,r.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:r.authPayload,requester:r.requester,expiryTimestamp:r.expiryTimestamp,id:t,pairingTopic:o,verifyContext:r.verifyContext,transportType:a})}),S(this,"setPendingSessionRequest",async t=>{const{id:s,topic:r,params:o,verifyContext:a}=t,c=o.request.expiryTimestamp||Ne(Ze.wc_sessionRequest.req.ttl);this.client.core.expirer.set(s,c),await this.client.pendingRequest.set(s,{id:s,topic:r,params:o,verifyContext:a})}),S(this,"sendRequest",async t=>{const{topic:s,method:r,params:o,expiry:a,relayRpcId:c,clientRpcId:h,throwOnFailedPublish:u,appLink:d,tvf:p}=t,f=(0,J.formatJsonRpcRequest)(r,o,h);let v;const w=!!d;try{const x=w?Pi:Dt;v=await this.client.core.crypto.encode(s,f,{encoding:x})}catch(x){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${s} failed`),x}let b;if(xy.includes(r)){const x=Gt(JSON.stringify(f)),E=Gt(v);b=await this.client.core.verify.register({id:E,decryptedId:x})}const _=Ze[r].req;if(_.attestation=b,a&&(_.ttl=a),c&&(_.id=c),this.client.core.history.set(s,f),w){const x=mn(d,s,v);await $.g.Linking.openURL(x,this.client.name)}else{const x=Ze[r].req;a&&(x.ttl=a),c&&(x.id=c),x.tvf=ut(Ee({},p),{correlationId:f.id}),u?(x.internal=ut(Ee({},x.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,v,x)):this.client.core.relayer.publish(s,v,x).catch(E=>this.client.logger.error(E))}return f.id}),S(this,"sendResult",async t=>{const{id:s,topic:r,result:o,throwOnFailedPublish:a,encodeOpts:c,appLink:h}=t,u=(0,J.formatJsonRpcResult)(s,o);let d;const p=h&&typeof($.g==null?void 0:$.g.Linking)<"u";try{const w=p?Pi:Dt;d=await this.client.core.crypto.encode(r,u,ut(Ee({},c||{}),{encoding:w}))}catch(w){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${r} failed`),w}let f,v;try{f=await this.client.core.history.get(r,s);const w=f.request;try{this.shouldSetTVF(w.method,w.params)&&(v=this.getTVFParams(s,w.params,o))}catch(b){this.client.logger.warn("sendResult() -> getTVFParams() failed",b)}}catch(w){throw this.client.logger.error(`sendResult() -> history.get(${r}, ${s}) failed`),w}if(p){const w=mn(h,r,d);await $.g.Linking.openURL(w,this.client.name)}else{const w=f.request.method,b=Ze[w].res;b.tvf=ut(Ee({},v),{correlationId:s}),a?(b.internal=ut(Ee({},b.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(r,d,b)):this.client.core.relayer.publish(r,d,b).catch(_=>this.client.logger.error(_))}await this.client.core.history.resolve(u)}),S(this,"sendError",async t=>{const{id:s,topic:r,error:o,encodeOpts:a,rpcOpts:c,appLink:h}=t,u=(0,J.formatJsonRpcError)(s,o);let d;const p=h&&typeof($.g==null?void 0:$.g.Linking)<"u";try{const v=p?Pi:Dt;d=await this.client.core.crypto.encode(r,u,ut(Ee({},a||{}),{encoding:v}))}catch(v){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${r} failed`),v}let f;try{f=await this.client.core.history.get(r,s)}catch(v){throw this.client.logger.error(`sendError() -> history.get(${r}, ${s}) failed`),v}if(p){const v=mn(h,r,d);await $.g.Linking.openURL(v,this.client.name)}else{const v=f.request.method,w=c||Ze[v].res;this.client.core.relayer.publish(r,d,w)}await this.client.core.history.resolve(u)}),S(this,"cleanup",async()=>{const t=[],s=[];this.client.session.getAll().forEach(r=>{let o=!1;$t(r.expiry)&&(o=!0),this.client.core.crypto.keychain.has(r.topic)||(o=!0),o&&t.push(r.topic)}),this.client.proposal.getAll().forEach(r=>{$t(r.expiryTimestamp)&&s.push(r.id)}),await Promise.all([...t.map(r=>this.deleteSession({topic:r})),...s.map(r=>this.deleteProposal(r))])}),S(this,"onProviderMessageEvent",async t=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(t):await this.onRelayMessage(t)}),S(this,"onRelayEventRequest",async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()}),S(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===Yt.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=Yt.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(s){this.client.logger.warn(s)}}this.requestQueue.state=Yt.idle}),S(this,"processRequest",async t=>{const{topic:s,payload:r,attestation:o,transportType:a,encryptedId:c}=t,h=r.method;if(!this.shouldIgnorePairingRequest({topic:s,requestMethod:h}))switch(h){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:s,payload:r,attestation:o,encryptedId:c});case"wc_sessionSettle":return await this.onSessionSettleRequest(s,r);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(s,r);case"wc_sessionExtend":return await this.onSessionExtendRequest(s,r);case"wc_sessionPing":return await this.onSessionPingRequest(s,r);case"wc_sessionDelete":return await this.onSessionDeleteRequest(s,r);case"wc_sessionRequest":return await this.onSessionRequest({topic:s,payload:r,attestation:o,encryptedId:c,transportType:a});case"wc_sessionEvent":return await this.onSessionEventRequest(s,r);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:s,payload:r,attestation:o,encryptedId:c,transportType:a});default:return this.client.logger.info(`Unsupported request method ${h}`)}}),S(this,"onRelayEventResponse",async t=>{const{topic:s,payload:r,transportType:o}=t,a=(await this.client.core.history.get(s,r.id)).request.method;switch(a){case"wc_sessionPropose":return this.onSessionProposeResponse(s,r,o);case"wc_sessionSettle":return this.onSessionSettleResponse(s,r);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,r);case"wc_sessionExtend":return this.onSessionExtendResponse(s,r);case"wc_sessionPing":return this.onSessionPingResponse(s,r);case"wc_sessionRequest":return this.onSessionRequestResponse(s,r);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(s,r);default:return this.client.logger.info(`Unsupported response method ${a}`)}}),S(this,"onRelayEventUnknownPayload",t=>{const{topic:s}=t,{message:r}=L("MISSING_OR_INVALID",`Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);throw new Error(r)}),S(this,"shouldIgnorePairingRequest",t=>{const{topic:s,requestMethod:r}=t,o=this.expectedPairingMethodMap.get(s);return!o||o.includes(r)?!1:!!(o.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),S(this,"onSessionProposeRequest",async t=>{const{topic:s,payload:r,attestation:o,encryptedId:a}=t,{params:c,id:h}=r;try{const u=this.client.core.eventClient.getEvent({topic:s});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),u==null||u.setError(ci.proposal_listener_not_found)),this.isValidConnect(Ee({},r.params));const d=c.expiryTimestamp||Ne(Ze.wc_sessionPropose.req.ttl),p=Ee({id:h,pairingTopic:s,expiryTimestamp:d},c);await this.setProposal(h,p);const f=await this.getVerifyContext({attestationId:o,hash:Gt(JSON.stringify(r)),encryptedId:a,metadata:p.proposer.metadata});u==null||u.addTrace(Jt.emit_session_proposal),this.client.events.emit("session_proposal",{id:h,params:p,verifyContext:f})}catch(u){await this.sendError({id:h,topic:s,error:u,rpcOpts:Ze.wc_sessionPropose.autoReject}),this.client.logger.error(u)}}),S(this,"onSessionProposeResponse",async(t,s,r)=>{const{id:o}=s;if((0,J.isJsonRpcResult)(s)){const{result:a}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:a});const c=this.client.proposal.get(o);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:c});const h=c.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:h});const u=a.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:u});const d=await this.client.core.crypto.generateSharedKey(h,u);this.pendingSessions.set(o,{sessionTopic:d,pairingTopic:t,proposalId:o,publicKey:h});const p=await this.client.core.relayer.subscribe(d,{transportType:r});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:p}),await this.client.core.pairing.activate({topic:t})}else if((0,J.isJsonRpcError)(s)){await this.client.proposal.delete(o,_e("USER_DISCONNECTED"));const a=pe("session_connect",o);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners, 954`);this.events.emit(a,{error:s.error})}}),S(this,"onSessionSettleRequest",async(t,s)=>{const{id:r,params:o}=s;try{this.isValidSessionSettleRequest(o);const{relay:a,controller:c,expiry:h,namespaces:u,sessionProperties:d,scopedProperties:p,sessionConfig:f}=s.params,v=[...this.pendingSessions.values()].find(_=>_.sessionTopic===t);if(!v)return this.client.logger.error(`Pending session not found for topic ${t}`);const w=this.client.proposal.get(v.proposalId),b=ut(Ee(Ee(Ee({topic:t,relay:a,expiry:h,namespaces:u,acknowledged:!0,pairingTopic:v.pairingTopic,requiredNamespaces:w.requiredNamespaces,optionalNamespaces:w.optionalNamespaces,controller:c.publicKey,self:{publicKey:v.publicKey,metadata:this.client.metadata},peer:{publicKey:c.publicKey,metadata:c.metadata}},d&&{sessionProperties:d}),p&&{scopedProperties:p}),f&&{sessionConfig:f}),{transportType:Re.relay});await this.client.session.set(b.topic,b),await this.setExpiry(b.topic,b.expiry),await this.client.core.pairing.updateMetadata({topic:v.pairingTopic,metadata:b.peer.metadata}),this.client.events.emit("session_connect",{session:b}),this.events.emit(pe("session_connect",v.proposalId),{session:b}),this.pendingSessions.delete(v.proposalId),this.deleteProposal(v.proposalId,!1),this.cleanupDuplicatePairings(b),await this.sendResult({id:s.id,topic:t,result:!0,throwOnFailedPublish:!0})}catch(a){await this.sendError({id:r,topic:t,error:a}),this.client.logger.error(a)}}),S(this,"onSessionSettleResponse",async(t,s)=>{const{id:r}=s;(0,J.isJsonRpcResult)(s)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(pe("session_approve",r),{})):(0,J.isJsonRpcError)(s)&&(await this.client.session.delete(t,_e("USER_DISCONNECTED")),this.events.emit(pe("session_approve",r),{error:s.error}))}),S(this,"onSessionUpdateRequest",async(t,s)=>{const{params:r,id:o}=s;try{const a=`${t}_session_update`,c=Ls.get(a);if(c&&this.isRequestOutOfSync(c,o)){this.client.logger.warn(`Discarding out of sync request - ${o}`),this.sendError({id:o,topic:t,error:_e("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(Ee({topic:t},r));try{Ls.set(a,o),await this.client.session.update(t,{namespaces:r.namespaces}),await this.sendResult({id:o,topic:t,result:!0,throwOnFailedPublish:!0})}catch(h){throw Ls.delete(a),h}this.client.events.emit("session_update",{id:o,topic:t,params:r})}catch(a){await this.sendError({id:o,topic:t,error:a}),this.client.logger.error(a)}}),S(this,"isRequestOutOfSync",(t,s)=>s.toString().slice(0,-3)<t.toString().slice(0,-3)),S(this,"onSessionUpdateResponse",(t,s)=>{const{id:r}=s,o=pe("session_update",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);(0,J.isJsonRpcResult)(s)?this.events.emit(pe("session_update",r),{}):(0,J.isJsonRpcError)(s)&&this.events.emit(pe("session_update",r),{error:s.error})}),S(this,"onSessionExtendRequest",async(t,s)=>{const{id:r}=s;try{this.isValidExtend({topic:t}),await this.setExpiry(t,Ne(cs)),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:r,topic:t})}catch(o){await this.sendError({id:r,topic:t,error:o}),this.client.logger.error(o)}}),S(this,"onSessionExtendResponse",(t,s)=>{const{id:r}=s,o=pe("session_extend",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);(0,J.isJsonRpcResult)(s)?this.events.emit(pe("session_extend",r),{}):(0,J.isJsonRpcError)(s)&&this.events.emit(pe("session_extend",r),{error:s.error})}),S(this,"onSessionPingRequest",async(t,s)=>{const{id:r}=s;try{this.isValidPing({topic:t}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:r,topic:t})}catch(o){await this.sendError({id:r,topic:t,error:o}),this.client.logger.error(o)}}),S(this,"onSessionPingResponse",(t,s)=>{const{id:r}=s,o=pe("session_ping",r);setTimeout(()=>{if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners 2176`);(0,J.isJsonRpcResult)(s)?this.events.emit(pe("session_ping",r),{}):(0,J.isJsonRpcError)(s)&&this.events.emit(pe("session_ping",r),{error:s.error})},500)}),S(this,"onSessionDeleteRequest",async(t,s)=>{const{id:r}=s;try{this.isValidDisconnect({topic:t,reason:s.params}),Promise.all([new Promise(o=>{this.client.core.relayer.once(We.publish,async()=>{o(await this.deleteSession({topic:t,id:r}))})}),this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:_e("USER_DISCONNECTED")})]).catch(o=>this.client.logger.error(o))}catch(o){this.client.logger.error(o)}}),S(this,"onSessionRequest",async t=>{var s,r,o;const{topic:a,payload:c,attestation:h,encryptedId:u,transportType:d}=t,{id:p,params:f}=c;try{await this.isValidRequest(Ee({topic:a},f));const v=this.client.session.get(a),w=await this.getVerifyContext({attestationId:h,hash:Gt(JSON.stringify((0,J.formatJsonRpcRequest)("wc_sessionRequest",f,p))),encryptedId:u,metadata:v.peer.metadata,transportType:d}),b={id:p,topic:a,params:f,verifyContext:w};await this.setPendingSessionRequest(b),d===Re.link_mode&&(s=v.peer.metadata.redirect)!=null&&s.universal&&this.client.core.addLinkModeSupportedApp((r=v.peer.metadata.redirect)==null?void 0:r.universal),(o=this.client.signConfig)!=null&&o.disableRequestQueue?this.emitSessionRequest(b):(this.addSessionRequestToSessionRequestQueue(b),this.processSessionRequestQueue())}catch(v){await this.sendError({id:p,topic:a,error:v}),this.client.logger.error(v)}}),S(this,"onSessionRequestResponse",(t,s)=>{const{id:r}=s,o=pe("session_request",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);(0,J.isJsonRpcResult)(s)?this.events.emit(pe("session_request",r),{result:s.result}):(0,J.isJsonRpcError)(s)&&this.events.emit(pe("session_request",r),{error:s.error})}),S(this,"onSessionEventRequest",async(t,s)=>{const{id:r,params:o}=s;try{const a=`${t}_session_event_${o.event.name}`,c=Ls.get(a);if(c&&this.isRequestOutOfSync(c,r)){this.client.logger.info(`Discarding out of sync request - ${r}`);return}this.isValidEmit(Ee({topic:t},o)),this.client.events.emit("session_event",{id:r,topic:t,params:o}),Ls.set(a,r)}catch(a){await this.sendError({id:r,topic:t,error:a}),this.client.logger.error(a)}}),S(this,"onSessionAuthenticateResponse",(t,s)=>{const{id:r}=s;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:s}),(0,J.isJsonRpcResult)(s)?this.events.emit(pe("session_request",r),{result:s.result}):(0,J.isJsonRpcError)(s)&&this.events.emit(pe("session_request",r),{error:s.error})}),S(this,"onSessionAuthenticateRequest",async t=>{var s;const{topic:r,payload:o,attestation:a,encryptedId:c,transportType:h}=t;try{const{requester:u,authPayload:d,expiryTimestamp:p}=o.params,f=await this.getVerifyContext({attestationId:a,hash:Gt(JSON.stringify(o)),encryptedId:c,metadata:u.metadata,transportType:h}),v={requester:u,pairingTopic:r,id:o.id,authPayload:d,verifyContext:f,expiryTimestamp:p};await this.setAuthRequest(o.id,{request:v,pairingTopic:r,transportType:h}),h===Re.link_mode&&(s=u.metadata.redirect)!=null&&s.universal&&this.client.core.addLinkModeSupportedApp(u.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:r,params:o.params,id:o.id,verifyContext:f})}catch(u){this.client.logger.error(u);const d=o.params.requester.publicKey,p=await this.client.core.crypto.generateKeyPair(),f=this.getAppLinkIfEnabled(o.params.requester.metadata,h),v={type:ai,receiverPublicKey:d,senderPublicKey:p};await this.sendError({id:o.id,topic:r,error:u,encodeOpts:v,rpcOpts:Ze.wc_sessionAuthenticate.autoReject,appLink:f})}}),S(this,"addSessionRequestToSessionRequestQueue",t=>{this.sessionRequestQueue.queue.push(t)}),S(this,"cleanupAfterResponse",t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=Yt.idle,this.processSessionRequestQueue()},(0,C.toMiliseconds)(this.requestQueueDelay))}),S(this,"cleanupPendingSentRequestsForTopic",({topic:t,error:s})=>{const r=this.client.core.history.pending;r.length>0&&r.filter(o=>o.topic===t&&o.request.method==="wc_sessionRequest").forEach(o=>{const a=o.request.id,c=pe("session_request",a);if(this.events.listenerCount(c)===0)throw new Error(`emitting ${c} without any listeners`);this.events.emit(pe("session_request",o.request.id),{error:s})})}),S(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===Yt.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=Yt.active,this.emitSessionRequest(t)}catch(s){this.client.logger.error(s)}}),S(this,"emitSessionRequest",t=>{this.client.events.emit("session_request",t)}),S(this,"onPairingCreated",t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const s=this.client.proposal.getAll().find(r=>r.pairingTopic===t.topic);s&&this.onSessionProposeRequest({topic:t.topic,payload:(0,J.formatJsonRpcRequest)("wc_sessionPropose",ut(Ee({},s),{requiredNamespaces:s.requiredNamespaces,optionalNamespaces:s.optionalNamespaces,relays:s.relays,proposer:s.proposer,sessionProperties:s.sessionProperties,scopedProperties:s.scopedProperties}),s.id)})}),S(this,"isValidConnect",async t=>{if(!pt(t)){const{message:u}=L("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(u)}const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:o,sessionProperties:a,scopedProperties:c,relays:h}=t;if(tt(s)||await this.isValidPairingTopic(s),!Wu(h,!0)){const{message:u}=L("MISSING_OR_INVALID",`connect() relays: ${h}`);throw new Error(u)}if(!tt(r)&&Si(r)!==0){const u="requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";["fatal","error","silent"].includes(this.client.logger.level)?console.warn(u):this.client.logger.warn(u),this.validateNamespaces(r,"requiredNamespaces")}if(!tt(o)&&Si(o)!==0&&this.validateNamespaces(o,"optionalNamespaces"),tt(a)||this.validateSessionProps(a,"sessionProperties"),!tt(c)){this.validateSessionProps(c,"scopedProperties");const u=Object.keys(r||{}).concat(Object.keys(o||{}));if(!Object.keys(c).every(d=>u.includes(d)))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(c)}, required/optional namespaces: ${JSON.stringify(u)}`)}}),S(this,"validateNamespaces",(t,s)=>{const r=Gu(t,"connect()",s);if(r)throw new Error(r.message)}),S(this,"isValidApprove",async t=>{if(!pt(t))throw new Error(L("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:s,namespaces:r,relayProtocol:o,sessionProperties:a,scopedProperties:c}=t;this.checkRecentlyDeleted(s),await this.isValidProposalId(s);const h=this.client.proposal.get(s),u=bn(r,"approve()");if(u)throw new Error(u.message);const d=Cr(h.requiredNamespaces,r,"approve()");if(d)throw new Error(d.message);if(!ke(o,!0)){const{message:p}=L("MISSING_OR_INVALID",`approve() relayProtocol: ${o}`);throw new Error(p)}if(tt(a)||this.validateSessionProps(a,"sessionProperties"),!tt(c)){this.validateSessionProps(c,"scopedProperties");const p=new Set(Object.keys(r));if(!Object.keys(c).every(f=>p.has(f)))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(c)}, approved namespaces: ${Array.from(p).join(", ")}`)}}),S(this,"isValidReject",async t=>{if(!pt(t)){const{message:o}=L("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(o)}const{id:s,reason:r}=t;if(this.checkRecentlyDeleted(s),await this.isValidProposalId(s),!Zu(r)){const{message:o}=L("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(r)}`);throw new Error(o)}}),S(this,"isValidSessionSettleRequest",t=>{if(!pt(t)){const{message:u}=L("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(u)}const{relay:s,controller:r,namespaces:o,expiry:a}=t;if(!Da(s)){const{message:u}=L("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(u)}const c=Uu(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);const h=bn(o,"onSessionSettleRequest()");if(h)throw new Error(h.message);if($t(a)){const{message:u}=L("EXPIRED","onSessionSettleRequest()");throw new Error(u)}}),S(this,"isValidUpdate",async t=>{if(!pt(t)){const{message:h}=L("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(h)}const{topic:s,namespaces:r}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s);const o=this.client.session.get(s),a=bn(r,"update()");if(a)throw new Error(a.message);const c=Cr(o.requiredNamespaces,r,"update()");if(c)throw new Error(c.message)}),S(this,"isValidExtend",async t=>{if(!pt(t)){const{message:r}=L("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(r)}const{topic:s}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s)}),S(this,"isValidRequest",async t=>{if(!pt(t)){const{message:h}=L("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(h)}const{topic:s,request:r,chainId:o,expiry:a}=t;this.checkRecentlyDeleted(s),await this.isValidSessionTopic(s);const{namespaces:c}=this.client.session.get(s);if(!qa(c,o)){const{message:h}=L("MISSING_OR_INVALID",`request() chainId: ${o}`);throw new Error(h)}if(!Yu(r)){const{message:h}=L("MISSING_OR_INVALID",`request() ${JSON.stringify(r)}`);throw new Error(h)}if(!ed(c,o,r.method)){const{message:h}=L("MISSING_OR_INVALID",`request() method: ${r.method}`);throw new Error(h)}if(a&&!nd(a,Zr)){const{message:h}=L("MISSING_OR_INVALID",`request() expiry: ${a}. Expiry must be a number (in seconds) between ${Zr.min} and ${Zr.max}`);throw new Error(h)}}),S(this,"isValidRespond",async t=>{var s;if(!pt(t)){const{message:a}=L("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(a)}const{topic:r,response:o}=t;try{await this.isValidSessionTopic(r)}catch(a){throw(s=t==null?void 0:t.response)!=null&&s.id&&this.cleanupAfterResponse(t),a}if(!Qu(o)){const{message:a}=L("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(o)}`);throw new Error(a)}}),S(this,"isValidPing",async t=>{if(!pt(t)){const{message:r}=L("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(r)}const{topic:s}=t;await this.isValidSessionOrPairingTopic(s)}),S(this,"isValidEmit",async t=>{if(!pt(t)){const{message:c}=L("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(c)}const{topic:s,event:r,chainId:o}=t;await this.isValidSessionTopic(s);const{namespaces:a}=this.client.session.get(s);if(!qa(a,o)){const{message:c}=L("MISSING_OR_INVALID",`emit() chainId: ${o}`);throw new Error(c)}if(!Xu(r)){const{message:c}=L("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(r)}`);throw new Error(c)}if(!td(a,o,r.name)){const{message:c}=L("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(r)}`);throw new Error(c)}}),S(this,"isValidDisconnect",async t=>{if(!pt(t)){const{message:r}=L("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(r)}const{topic:s}=t;await this.isValidSessionOrPairingTopic(s)}),S(this,"isValidAuthenticate",t=>{const{chains:s,uri:r,domain:o,nonce:a}=t;if(!Array.isArray(s)||s.length===0)throw new Error("chains is required and must be a non-empty array");if(!ke(r,!1))throw new Error("uri is required parameter");if(!ke(o,!1))throw new Error("domain is required parameter");if(!ke(a,!1))throw new Error("nonce is required parameter");if([...new Set(s.map(h=>Pe(h).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:c}=Pe(s[0]);if(c!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),S(this,"getVerifyContext",async t=>{const{attestationId:s,hash:r,encryptedId:o,metadata:a,transportType:c}=t,h={verified:{verifyUrl:a.verifyUrl||Us,validation:"UNKNOWN",origin:a.url||""}};try{if(c===Re.link_mode){const d=this.getAppLinkIfEnabled(a,c);return h.verified.validation=d&&new URL(d).origin===new URL(a.url).origin?"VALID":"INVALID",h}const u=await this.client.core.verify.resolve({attestationId:s,hash:r,encryptedId:o,verifyUrl:a.verifyUrl});u&&(h.verified.origin=u.origin,h.verified.isScam=u.isScam,h.verified.validation=u.origin===new URL(a.url).origin?"VALID":"INVALID")}catch(u){this.client.logger.warn(u)}return this.client.logger.debug(`Verify context: ${JSON.stringify(h)}`),h}),S(this,"validateSessionProps",(t,s)=>{Object.values(t).forEach((r,o)=>{if(r==null){const{message:a}=L("MISSING_OR_INVALID",`${s} must contain an existing value for each key. Received: ${r} for key ${Object.keys(t)[o]}`);throw new Error(a)}})}),S(this,"getPendingAuthRequest",t=>{const s=this.client.auth.requests.get(t);return typeof s=="object"?s:void 0}),S(this,"addToRecentlyDeleted",(t,s)=>{if(this.recentlyDeletedMap.set(t,s),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let r=0;const o=this.recentlyDeletedLimit/2;for(const a of this.recentlyDeletedMap.keys()){if(r++>=o)break;this.recentlyDeletedMap.delete(a)}}}),S(this,"checkRecentlyDeleted",t=>{const s=this.recentlyDeletedMap.get(t);if(s){const{message:r}=L("MISSING_OR_INVALID",`Record was recently deleted - ${s}: ${t}`);throw new Error(r)}}),S(this,"isLinkModeEnabled",(t,s)=>{var r,o,a,c,h,u,d,p,f;return!t||s!==Re.link_mode?!1:((o=(r=this.client.metadata)==null?void 0:r.redirect)==null?void 0:o.linkMode)===!0&&((c=(a=this.client.metadata)==null?void 0:a.redirect)==null?void 0:c.universal)!==void 0&&((u=(h=this.client.metadata)==null?void 0:h.redirect)==null?void 0:u.universal)!==""&&((d=t==null?void 0:t.redirect)==null?void 0:d.universal)!==void 0&&((p=t==null?void 0:t.redirect)==null?void 0:p.universal)!==""&&((f=t==null?void 0:t.redirect)==null?void 0:f.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(t.redirect.universal)&&typeof($.g==null?void 0:$.g.Linking)<"u"}),S(this,"getAppLinkIfEnabled",(t,s)=>{var r;return this.isLinkModeEnabled(t,s)?(r=t==null?void 0:t.redirect)==null?void 0:r.universal:void 0}),S(this,"handleLinkModeMessage",({url:t})=>{if(!t||!t.includes("wc_ev")||!t.includes("topic"))return;const s=Xn(t,"topic")||"",r=decodeURIComponent(Xn(t,"wc_ev")||""),o=this.client.session.keys.includes(s);o&&this.client.session.update(s,{transportType:Re.link_mode}),this.client.core.dispatchEnvelope({topic:s,message:r,sessionExists:o})}),S(this,"registerLinkModeListeners",async()=>{var t;if(tn()||Kt()&&(t=this.client.metadata.redirect)!=null&&t.linkMode){const s=$.g==null?void 0:$.g.Linking;if(typeof s<"u"){s.addEventListener("url",this.handleLinkModeMessage,this.client.name);const r=await s.getInitialURL();r&&setTimeout(()=>{this.handleLinkModeMessage({url:r})},50)}}}),S(this,"shouldSetTVF",(t,s)=>{if(!s||t!=="wc_sessionRequest")return!1;const{request:r}=s;return Object.keys(Nc).includes(r.method)}),S(this,"getTVFParams",(t,s,r)=>{var o,a;try{const c=s.request.method,h=this.extractTxHashesFromResult(c,r);return ut(Ee({correlationId:t,rpcMethods:[c],chainId:s.chainId},this.isValidContractData(s.request.params)&&{contractAddresses:[(a=(o=s.request.params)==null?void 0:o[0])==null?void 0:a.to]}),{txHashes:h})}catch(c){this.client.logger.warn("Error getting TVF params",c)}return{}}),S(this,"isValidContractData",t=>{var s;if(!t)return!1;try{const r=(t==null?void 0:t.data)||((s=t==null?void 0:t[0])==null?void 0:s.data);if(!r.startsWith("0x"))return!1;const o=r.slice(2);return/^[0-9a-fA-F]*$/.test(o)?o.length%2===0:!1}catch{}return!1}),S(this,"extractTxHashesFromResult",(t,s)=>{try{const r=Nc[t];if(typeof s=="string")return[s];const o=s[r.key];if(qt(o))return t==="solana_signAllTransactions"?o.map(a=>Ph(a)):o;if(typeof o=="string")return[o]}catch(r){this.client.logger.warn("Error extracting tx hashes from result",r)}return[]})}async processPendingMessageEvents(){try{const e=this.client.session.keys,t=this.client.core.relayer.messages.getWithoutAck(e);for(const[s,r]of Object.entries(t))for(const o of r)try{await this.onProviderMessageEvent({topic:s,message:o,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${s}, message: ${o}`)}}catch(e){this.client.logger.warn("processPendingMessageEvents failed",e)}}isInitialized(){if(!this.initialized){const{message:e}=L("NOT_INITIALIZED",this.name);throw new Error(e)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(We.message,e=>{this.onProviderMessageEvent(e)})}async onRelayMessage(e){const{topic:t,message:s,attestation:r,transportType:o}=e,{publicKey:a}=this.client.auth.authKeys.keys.includes(An)?this.client.auth.authKeys.get(An):{responseTopic:void 0,publicKey:void 0};try{const c=await this.client.core.crypto.decode(t,s,{receiverPublicKey:a,encoding:o===Re.link_mode?Pi:Dt});(0,J.isJsonRpcRequest)(c)?(this.client.core.history.set(t,c),await this.onRelayEventRequest({topic:t,payload:c,attestation:r,transportType:o,encryptedId:Gt(s)})):(0,J.isJsonRpcResponse)(c)?(await this.client.core.history.resolve(c),await this.onRelayEventResponse({topic:t,payload:c,transportType:o}),this.client.core.history.delete(t,c.id)):await this.onRelayEventUnknownPayload({topic:t,payload:c,transportType:o}),await this.client.core.relayer.messages.ack(t,s)}catch(c){this.client.logger.error(c)}}registerExpirerEvents(){this.client.core.expirer.on(Ot.expired,async e=>{const{topic:t,id:s}=Xs(e.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,L("EXPIRED"),!0);if(s&&this.client.auth.requests.keys.includes(s))return await this.deletePendingAuthRequest(s,L("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s}))})}registerPairingEvents(){this.client.core.pairing.events.on(Di.create,e=>this.onPairingCreated(e)),this.client.core.pairing.events.on(Di.delete,e=>{this.addToRecentlyDeleted(e.topic,"pairing")})}isValidPairingTopic(e){if(!ke(e,!1)){const{message:t}=L("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(e)){const{message:t}=L("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if($t(this.client.core.pairing.pairings.get(e).expiry)){const{message:t}=L("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}}async isValidSessionTopic(e){if(!ke(e,!1)){const{message:t}=L("MISSING_OR_INVALID",`session topic should be a string: ${e}`);throw new Error(t)}if(this.checkRecentlyDeleted(e),!this.client.session.keys.includes(e)){const{message:t}=L("NO_MATCHING_KEY",`session topic doesn't exist: ${e}`);throw new Error(t)}if($t(this.client.session.get(e).expiry)){await this.deleteSession({topic:e});const{message:t}=L("EXPIRED",`session topic: ${e}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(e)){const{message:t}=L("MISSING_OR_INVALID",`session topic does not exist in keychain: ${e}`);throw await this.deleteSession({topic:e}),new Error(t)}}async isValidSessionOrPairingTopic(e){if(this.checkRecentlyDeleted(e),this.client.session.keys.includes(e))await this.isValidSessionTopic(e);else if(this.client.core.pairing.pairings.keys.includes(e))this.isValidPairingTopic(e);else if(ke(e,!1)){const{message:t}=L("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${e}`);throw new Error(t)}else{const{message:t}=L("MISSING_OR_INVALID",`session or pairing topic should be a string: ${e}`);throw new Error(t)}}async isValidProposalId(e){if(!Ju(e)){const{message:t}=L("MISSING_OR_INVALID",`proposal id should be a number: ${e}`);throw new Error(t)}if(!this.client.proposal.keys.includes(e)){const{message:t}=L("NO_MATCHING_KEY",`proposal id doesn't exist: ${e}`);throw new Error(t)}if($t(this.client.proposal.get(e).expiryTimestamp)){await this.deleteProposal(e);const{message:t}=L("EXPIRED",`proposal id: ${e}`);throw new Error(t)}}}class Dy extends ki{constructor(e,t){super(e,t,_y,Wr),this.core=e,this.logger=t}}class qy extends ki{constructor(e,t){super(e,t,vy,Wr),this.core=e,this.logger=t}}class Fy extends ki{constructor(e,t){super(e,t,Ey,Wr,s=>s.id),this.core=e,this.logger=t}}class ky extends ki{constructor(e,t){super(e,t,Sy,Sn,()=>An),this.core=e,this.logger=t}}class Ly extends ki{constructor(e,t){super(e,t,Oy,Sn),this.core=e,this.logger=t}}class By extends ki{constructor(e,t){super(e,t,Ay,Sn,s=>s.id),this.core=e,this.logger=t}}var Uy=Object.defineProperty,My=(i,e,t)=>e in i?Uy(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Qr=(i,e,t)=>My(i,typeof e!="symbol"?e+"":e,t);class zy{constructor(e,t){this.core=e,this.logger=t,Qr(this,"authKeys"),Qr(this,"pairingTopics"),Qr(this,"requests"),this.authKeys=new ky(this.core,this.logger),this.pairingTopics=new Ly(this.core,this.logger),this.requests=new By(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var Hy=Object.defineProperty,Ky=(i,e,t)=>e in i?Hy(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,le=(i,e,t)=>Ky(i,typeof e!="symbol"?e+"":e,t);class Xr extends jd{constructor(e){super(e),le(this,"protocol",Sc),le(this,"version",Oc),le(this,"name",Jr.name),le(this,"metadata"),le(this,"core"),le(this,"logger"),le(this,"events",new xe.EventEmitter),le(this,"engine"),le(this,"session"),le(this,"proposal"),le(this,"pendingRequest"),le(this,"auth"),le(this,"signConfig"),le(this,"on",(s,r)=>this.events.on(s,r)),le(this,"once",(s,r)=>this.events.once(s,r)),le(this,"off",(s,r)=>this.events.off(s,r)),le(this,"removeListener",(s,r)=>this.events.removeListener(s,r)),le(this,"removeAllListeners",s=>this.events.removeAllListeners(s)),le(this,"connect",async s=>{try{return await this.engine.connect(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"pair",async s=>{try{return await this.engine.pair(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"approve",async s=>{try{return await this.engine.approve(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"reject",async s=>{try{return await this.engine.reject(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"update",async s=>{try{return await this.engine.update(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"extend",async s=>{try{return await this.engine.extend(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"request",async s=>{try{return await this.engine.request(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"respond",async s=>{try{return await this.engine.respond(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"ping",async s=>{try{return await this.engine.ping(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"emit",async s=>{try{return await this.engine.emit(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"disconnect",async s=>{try{return await this.engine.disconnect(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"find",s=>{try{return this.engine.find(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}}),le(this,"authenticate",async(s,r)=>{try{return await this.engine.authenticate(s,r)}catch(o){throw this.logger.error(o.message),o}}),le(this,"formatAuthMessage",s=>{try{return this.engine.formatAuthMessage(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"approveSessionAuthenticate",async s=>{try{return await this.engine.approveSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),le(this,"rejectSessionAuthenticate",async s=>{try{return await this.engine.rejectSessionAuthenticate(s)}catch(r){throw this.logger.error(r.message),r}}),this.name=(e==null?void 0:e.name)||Jr.name,this.metadata=Zs(e==null?void 0:e.metadata),this.signConfig=e==null?void 0:e.signConfig;const t=typeof(e==null?void 0:e.logger)<"u"&&typeof(e==null?void 0:e.logger)!="string"?e.logger:(0,ce.gw)((0,ce.jI)({level:(e==null?void 0:e.logger)||Jr.logger}));this.core=(e==null?void 0:e.core)||new wy(e),this.logger=(0,ce.Ep)(t,this.name),this.session=new qy(this.core,this.logger),this.proposal=new Dy(this.core,this.logger),this.pendingRequest=new Fy(this.core,this.logger),this.engine=new jy(this),this.auth=new zy(this.core,this.logger)}static async init(e){const t=new Xr(e);return await t.initialize(),t}get context(){return(0,ce.Fd)(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},(0,C.toMiliseconds)(C.ONE_SECOND))}catch(e){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(e.message),e}}}const m_=null,w_=null;var Ut=$(51916),Cn=$(55872).Buffer;const $c="error",Vy="wss://relay.walletconnect.org",Gy="wc",Wy="universal_provider",Rn=`${Gy}@2:${Wy}:`,jc="https://rpc.walletconnect.org/v1/",hs="generic",Jy=`${jc}bundler`,At={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function Zy(){}function eo(i){return i==null||typeof i!="object"&&typeof i!="function"}function to(i){return ArrayBuffer.isView(i)&&!(i instanceof DataView)}function Yy(i){if(eo(i))return i;if(Array.isArray(i)||to(i)||i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer)return i.slice(0);const e=Object.getPrototypeOf(i),t=e.constructor;if(i instanceof Date||i instanceof Map||i instanceof Set)return new t(i);if(i instanceof RegExp){const s=new t(i);return s.lastIndex=i.lastIndex,s}if(i instanceof DataView)return new t(i.buffer.slice(0));if(i instanceof Error){const s=new t(i.message);return s.stack=i.stack,s.name=i.name,s.cause=i.cause,s}if(typeof File<"u"&&i instanceof File)return new t([i],i.name,{type:i.type,lastModified:i.lastModified});if(typeof i=="object"){const s=Object.create(e);return Object.assign(s,i)}return i}function Dc(i){return typeof i=="object"&&i!==null}function qc(i){return Object.getOwnPropertySymbols(i).filter(e=>Object.prototype.propertyIsEnumerable.call(i,e))}function Fc(i){return i==null?i===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(i)}const Qy="[object RegExp]",kc="[object String]",Lc="[object Number]",Bc="[object Boolean]",Uc="[object Arguments]",Xy="[object Symbol]",em="[object Date]",tm="[object Map]",im="[object Set]",sm="[object Array]",nm="[object ArrayBuffer]",rm="[object Object]",om="[object DataView]",am="[object Uint8Array]",cm="[object Uint8ClampedArray]",hm="[object Uint16Array]",lm="[object Uint32Array]",um="[object Int8Array]",dm="[object Int16Array]",pm="[object Int32Array]",gm="[object Float32Array]",fm="[object Float64Array]";function ym(i,e){return ls(i,void 0,i,new Map,e)}function ls(i,e,t,s=new Map,r=void 0){const o=r==null?void 0:r(i,e,t,s);if(o!=null)return o;if(eo(i))return i;if(s.has(i))return s.get(i);if(Array.isArray(i)){const a=new Array(i.length);s.set(i,a);for(let c=0;c<i.length;c++)a[c]=ls(i[c],c,t,s,r);return Object.hasOwn(i,"index")&&(a.index=i.index),Object.hasOwn(i,"input")&&(a.input=i.input),a}if(i instanceof Date)return new Date(i.getTime());if(i instanceof RegExp){const a=new RegExp(i.source,i.flags);return a.lastIndex=i.lastIndex,a}if(i instanceof Map){const a=new Map;s.set(i,a);for(const[c,h]of i)a.set(c,ls(h,c,t,s,r));return a}if(i instanceof Set){const a=new Set;s.set(i,a);for(const c of i)a.add(ls(c,void 0,t,s,r));return a}if(typeof Cn<"u"&&Cn.isBuffer(i))return i.subarray();if(to(i)){const a=new(Object.getPrototypeOf(i)).constructor(i.length);s.set(i,a);for(let c=0;c<i.length;c++)a[c]=ls(i[c],c,t,s,r);return a}if(i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer)return i.slice(0);if(i instanceof DataView){const a=new DataView(i.buffer.slice(0),i.byteOffset,i.byteLength);return s.set(i,a),Li(a,i,t,s,r),a}if(typeof File<"u"&&i instanceof File){const a=new File([i],i.name,{type:i.type});return s.set(i,a),Li(a,i,t,s,r),a}if(i instanceof Blob){const a=new Blob([i],{type:i.type});return s.set(i,a),Li(a,i,t,s,r),a}if(i instanceof Error){const a=new i.constructor;return s.set(i,a),a.message=i.message,a.name=i.name,a.stack=i.stack,a.cause=i.cause,Li(a,i,t,s,r),a}if(typeof i=="object"&&mm(i)){const a=Object.create(Object.getPrototypeOf(i));return s.set(i,a),Li(a,i,t,s,r),a}return i}function Li(i,e,t=i,s,r){const o=[...Object.keys(e),...qc(e)];for(let a=0;a<o.length;a++){const c=o[a],h=Object.getOwnPropertyDescriptor(i,c);(h==null||h.writable)&&(i[c]=ls(e[c],c,t,s,r))}}function mm(i){switch(Fc(i)){case Uc:case sm:case nm:case om:case Bc:case em:case gm:case fm:case um:case dm:case pm:case tm:case Lc:case rm:case Qy:case im:case kc:case Xy:case am:case cm:case hm:case lm:return!0;default:return!1}}function wm(i,e){return ym(i,(t,s,r,o)=>{const a=e==null?void 0:e(t,s,r,o);if(a!=null)return a;if(typeof i=="object")switch(Object.prototype.toString.call(i)){case Lc:case kc:case Bc:{const c=new i.constructor(i==null?void 0:i.valueOf());return Li(c,i),c}case Uc:{const c={};return Li(c,i),c.length=i.length,c[Symbol.iterator]=i[Symbol.iterator],c}default:return}})}function Mc(i){return wm(i)}function zc(i){return i!==null&&typeof i=="object"&&Fc(i)==="[object Arguments]"}function _m(i){return to(i)}function vm(i){var t;if(typeof i!="object"||i==null)return!1;if(Object.getPrototypeOf(i)===null)return!0;if(Object.prototype.toString.call(i)!=="[object Object]"){const s=i[Symbol.toStringTag];return s==null||!((t=Object.getOwnPropertyDescriptor(i,Symbol.toStringTag))!=null&&t.writable)?!1:i.toString()===`[object ${s}]`}let e=i;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(i)===e}function bm(i,...e){const t=e.slice(0,-1),s=e[e.length-1];let r=i;for(let o=0;o<t.length;o++){const a=t[o];r=io(r,a,s,new Map)}return r}function io(i,e,t,s){if(eo(i)&&(i=Object(i)),e==null||typeof e!="object")return i;if(s.has(e))return Yy(s.get(e));if(s.set(e,i),Array.isArray(e)){e=e.slice();for(let o=0;o<e.length;o++)e[o]=e[o]??void 0}const r=[...Object.keys(e),...qc(e)];for(let o=0;o<r.length;o++){const a=r[o];let c=e[a],h=i[a];if(zc(c)&&(c={...c}),zc(h)&&(h={...h}),typeof Cn<"u"&&Cn.isBuffer(c)&&(c=Mc(c)),Array.isArray(c))if(typeof h=="object"&&h!=null){const d=[],p=Reflect.ownKeys(h);for(let f=0;f<p.length;f++){const v=p[f];d[v]=h[v]}h=d}else h=[];const u=t(h,c,a,i,e,s);u!=null?i[a]=u:Array.isArray(c)||Dc(h)&&Dc(c)?i[a]=io(h,c,t,s):h==null&&vm(c)?i[a]=io({},c,t,s):h==null&&_m(c)?i[a]=Mc(c):(h===void 0||c!==void 0)&&(i[a]=c)}return i}function Em(i,...e){return bm(i,...e,Zy)}var xm=Object.defineProperty,Im=Object.defineProperties,Pm=Object.getOwnPropertyDescriptors,Hc=Object.getOwnPropertySymbols,Sm=Object.prototype.hasOwnProperty,Om=Object.prototype.propertyIsEnumerable,Kc=(i,e,t)=>e in i?xm(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Nn=(i,e)=>{for(var t in e||(e={}))Sm.call(e,t)&&Kc(i,t,e[t]);if(Hc)for(var t of Hc(e))Om.call(e,t)&&Kc(i,t,e[t]);return i},Am=(i,e)=>Im(i,Pm(e));function vt(i,e,t){var s;const r=Pe(i);return((s=e.rpcMap)==null?void 0:s[r.reference])||`${jc}?chainId=${r.namespace}:${r.reference}&projectId=${t}`}function Bi(i){return i.includes(":")?i.split(":")[1]:i}function Vc(i){return i.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}function Cm(i,e){const t=Object.keys(e.namespaces).filter(r=>r.includes(i));if(!t.length)return[];const s=[];return t.forEach(r=>{const o=e.namespaces[r].accounts;s.push(...o)}),s}function Tn(i={},e={}){const t=Gc(i),s=Gc(e);return Em(t,s)}function Gc(i){var e,t,s,r,o;const a={};if(!Si(i))return a;for(const[c,h]of Object.entries(i)){const u=wn(c)?[c]:h.chains,d=h.methods||[],p=h.events||[],f=h.rpcMap||{},v=rs(c);a[v]=Am(Nn(Nn({},a[v]),h),{chains:Ue(u,(e=a[v])==null?void 0:e.chains),methods:Ue(d,(t=a[v])==null?void 0:t.methods),events:Ue(p,(s=a[v])==null?void 0:s.events)}),(Si(f)||Si(((r=a[v])==null?void 0:r.rpcMap)||{}))&&(a[v].rpcMap=Nn(Nn({},f),(o=a[v])==null?void 0:o.rpcMap))}return a}function Wc(i){return i.includes(":")?i.split(":")[2]:i}function Jc(i){const e={};for(const[t,s]of Object.entries(i)){const r=s.methods||[],o=s.events||[],a=s.accounts||[],c=wn(t)?[t]:s.chains?s.chains:Vc(s.accounts);e[t]={chains:c,methods:r,events:o,accounts:a}}return e}function so(i){return typeof i=="number"?i:i.includes("0x")?parseInt(i,16):(i=i.includes(":")?i.split(":")[1]:i,isNaN(Number(i))?i:Number(i))}const Zc={},ye=i=>Zc[i],no=(i,e)=>{Zc[i]=e};var Rm=Object.defineProperty,Nm=(i,e,t)=>e in i?Rm(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,us=(i,e,t)=>Nm(i,typeof e!="symbol"?e+"":e,t);class Tm{constructor(e){us(this,"name","polkadot"),us(this,"client"),us(this,"httpProviders"),us(this,"events"),us(this,"namespace"),us(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=Bi(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||vt(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Pt.r(new Ut.Z(s,ye("disableProviderPing")))}}var $m=Object.defineProperty,jm=Object.defineProperties,Dm=Object.getOwnPropertyDescriptors,Yc=Object.getOwnPropertySymbols,qm=Object.prototype.hasOwnProperty,Fm=Object.prototype.propertyIsEnumerable,ro=(i,e,t)=>e in i?$m(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Qc=(i,e)=>{for(var t in e||(e={}))qm.call(e,t)&&ro(i,t,e[t]);if(Yc)for(var t of Yc(e))Fm.call(e,t)&&ro(i,t,e[t]);return i},Xc=(i,e)=>jm(i,Dm(e)),ds=(i,e,t)=>ro(i,typeof e!="symbol"?e+"":e,t);class km{constructor(e){ds(this,"name","eip155"),ds(this,"client"),ds(this,"chainId"),ds(this,"namespace"),ds(this,"httpProviders"),ds(this,"events"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(parseInt(e),t),this.chainId=parseInt(e),this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,t){const s=t||vt(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Pt.r(new Ut.k(s,ye("disableProviderPing")))}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=parseInt(Bi(t));e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}getHttpProvider(){const e=this.chainId,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}async handleSwitchChain(e){var t,s;let r=e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:"0x0";r=r.startsWith("0x")?r:`0x${r}`;const o=parseInt(r,16);if(this.isChainApproved(o))this.setDefaultChain(`${o}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:r}]},chainId:(s=this.namespace.chains)==null?void 0:s[0]}),this.setDefaultChain(`${o}`);else throw new Error(`Failed to switch to chain 'eip155:${o}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var t,s,r,o,a;const c=(s=(t=e.request)==null?void 0:t.params)==null?void 0:s[0],h=((o=(r=e.request)==null?void 0:r.params)==null?void 0:o[1])||[],u=`${c}${h.join(",")}`;if(!c)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const d=this.client.session.get(e.topic),p=((a=d==null?void 0:d.sessionProperties)==null?void 0:a.capabilities)||{};if(p!=null&&p[u])return p==null?void 0:p[u];const f=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:Xc(Qc({},d.sessionProperties||{}),{capabilities:Xc(Qc({},p||{}),{[u]:f})})})}catch(v){console.warn("Failed to update session with capabilities",v)}return f}async getCallStatus(e){var t,s;const r=this.client.session.get(e.topic),o=(t=r.sessionProperties)==null?void 0:t.bundler_name;if(o){const c=this.getBundlerUrl(e.chainId,o);try{return await this.getUserOperationReceipt(c,e)}catch(h){console.warn("Failed to fetch call status from bundler",h,c)}}const a=(s=r.sessionProperties)==null?void 0:s.bundler_url;if(a)try{return await this.getUserOperationReceipt(a,e)}catch(c){console.warn("Failed to fetch call status from custom bundler",c,a)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,t){var s;const r=new URL(e),o=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify((0,J.formatJsonRpcRequest)("eth_getUserOperationReceipt",[(s=t.request.params)==null?void 0:s[0]]))});if(!o.ok)throw new Error(`Failed to fetch user operation receipt - ${o.status}`);return await o.json()}getBundlerUrl(e,t){return`${Jy}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${t}`}}var Lm=Object.defineProperty,Bm=(i,e,t)=>e in i?Lm(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ps=(i,e,t)=>Bm(i,typeof e!="symbol"?e+"":e,t);class Um{constructor(e){ps(this,"name","solana"),ps(this,"client"),ps(this,"httpProviders"),ps(this,"events"),ps(this,"namespace"),ps(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=Bi(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||vt(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Pt.r(new Ut.Z(s,ye("disableProviderPing")))}}var Mm=Object.defineProperty,zm=(i,e,t)=>e in i?Mm(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,gs=(i,e,t)=>zm(i,typeof e!="symbol"?e+"":e,t);class Hm{constructor(e){gs(this,"name","cosmos"),gs(this,"client"),gs(this,"httpProviders"),gs(this,"events"),gs(this,"namespace"),gs(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=Bi(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||vt(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Pt.r(new Ut.Z(s,ye("disableProviderPing")))}}var Km=Object.defineProperty,Vm=(i,e,t)=>e in i?Km(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,fs=(i,e,t)=>Vm(i,typeof e!="symbol"?e+"":e,t);class Gm{constructor(e){fs(this,"name","algorand"),fs(this,"client"),fs(this,"httpProviders"),fs(this,"events"),fs(this,"namespace"),fs(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(!this.httpProviders[e]){const s=t||vt(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.chainId=e,this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;e[t]=this.createHttpProvider(t,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||vt(e,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new Pt.r(new Ut.Z(s,ye("disableProviderPing")))}}var Wm=Object.defineProperty,Jm=(i,e,t)=>e in i?Wm(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ys=(i,e,t)=>Jm(i,typeof e!="symbol"?e+"":e,t);class Zm{constructor(e){ys(this,"name","cip34"),ys(this,"client"),ys(this,"httpProviders"),ys(this,"events"),ys(this,"namespace"),ys(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{const s=this.getCardanoRPCUrl(t),r=Bi(t);e[r]=this.createHttpProvider(r,s)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}getCardanoRPCUrl(e){const t=this.namespace.rpcMap;if(t)return t[e]}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||this.getCardanoRPCUrl(e);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Pt.r(new Ut.Z(s,ye("disableProviderPing")))}}var Ym=Object.defineProperty,Qm=(i,e,t)=>e in i?Ym(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ms=(i,e,t)=>Qm(i,typeof e!="symbol"?e+"":e,t);class Xm{constructor(e){ms(this,"name","elrond"),ms(this,"client"),ms(this,"httpProviders"),ms(this,"events"),ms(this,"namespace"),ms(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=Bi(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||vt(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Pt.r(new Ut.Z(s,ye("disableProviderPing")))}}var ew=Object.defineProperty,tw=(i,e,t)=>e in i?ew(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ws=(i,e,t)=>tw(i,typeof e!="symbol"?e+"":e,t);class iw{constructor(e){ws(this,"name","multiversx"),ws(this,"client"),ws(this,"httpProviders"),ws(this,"events"),ws(this,"namespace"),ws(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;const r=Bi(t);e[r]=this.createHttpProvider(r,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||vt(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Pt.r(new Ut.Z(s,ye("disableProviderPing")))}}var sw=Object.defineProperty,nw=(i,e,t)=>e in i?sw(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,_s=(i,e,t)=>nw(i,typeof e!="symbol"?e+"":e,t);class rw{constructor(e){_s(this,"name","near"),_s(this,"client"),_s(this,"httpProviders"),_s(this,"events"),_s(this,"namespace"),_s(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||vt(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{var s;e[t]=this.createHttpProvider(t,(s=this.namespace.rpcMap)==null?void 0:s[t])}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||vt(e,this.namespace);return typeof s>"u"?void 0:new Pt.r(new Ut.Z(s,ye("disableProviderPing")))}}var ow=Object.defineProperty,aw=(i,e,t)=>e in i?ow(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,vs=(i,e,t)=>aw(i,typeof e!="symbol"?e+"":e,t);class cw{constructor(e){vs(this,"name","tezos"),vs(this,"client"),vs(this,"httpProviders"),vs(this,"events"),vs(this,"namespace"),vs(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider().request(e.request)}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||vt(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||vt(e,this.namespace);return typeof s>"u"?void 0:new Pt.r(new Ut.Z(s))}}var hw=Object.defineProperty,lw=(i,e,t)=>e in i?hw(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,bs=(i,e,t)=>lw(i,typeof e!="symbol"?e+"":e,t);class uw{constructor(e){bs(this,"name",hs),bs(this,"client"),bs(this,"httpProviders"),bs(this,"events"),bs(this,"namespace"),bs(this,"chainId"),this.namespace=e.namespace,this.events=ye("events"),this.client=ye("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,t){this.httpProviders[e]||this.setHttpProvider(e,t),this.chainId=e,this.events.emit(At.DEFAULT_CHAIN_CHANGED,`${this.name}:${e}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(t=>t.split(":")[1]===this.chainId.toString()).map(t=>t.split(":")[2]))]:[]}createHttpProviders(){var e,t;const s={};return(t=(e=this.namespace)==null?void 0:e.accounts)==null||t.forEach(r=>{const o=Pe(r);s[`${o.namespace}:${o.reference}`]=this.createHttpProvider(r)}),s}getHttpProvider(e){const t=this.httpProviders[e];if(typeof t>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||vt(e,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);return new Pt.r(new Ut.Z(s,ye("disableProviderPing")))}}var dw=Object.defineProperty,pw=Object.defineProperties,gw=Object.getOwnPropertyDescriptors,eh=Object.getOwnPropertySymbols,fw=Object.prototype.hasOwnProperty,yw=Object.prototype.propertyIsEnumerable,oo=(i,e,t)=>e in i?dw(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,$n=(i,e)=>{for(var t in e||(e={}))fw.call(e,t)&&oo(i,t,e[t]);if(eh)for(var t of eh(e))yw.call(e,t)&&oo(i,t,e[t]);return i},ao=(i,e)=>pw(i,gw(e)),Ct=(i,e,t)=>oo(i,typeof e!="symbol"?e+"":e,t);class co{constructor(e){Ct(this,"client"),Ct(this,"namespaces"),Ct(this,"optionalNamespaces"),Ct(this,"sessionProperties"),Ct(this,"scopedProperties"),Ct(this,"events",new(Ie())),Ct(this,"rpcProviders",{}),Ct(this,"session"),Ct(this,"providerOpts"),Ct(this,"logger"),Ct(this,"uri"),Ct(this,"disableProviderPing",!1),this.providerOpts=e,this.logger=typeof(e==null?void 0:e.logger)<"u"&&typeof(e==null?void 0:e.logger)!="string"?e.logger:(0,ce.gw)((0,ce.jI)({level:(e==null?void 0:e.logger)||$c})),this.disableProviderPing=(e==null?void 0:e.disableProviderPing)||!1}static async init(e){const t=new co(e);return await t.initialize(),t}async request(e,t,s){const[r,o]=this.validateChain(t);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(r).request({request:$n({},e),chainId:`${r}:${o}`,topic:this.session.topic,expiry:s})}sendAsync(e,t,s,r){const o=new Date().getTime();this.request(e,s,r).then(a=>t(null,(0,J.formatJsonRpcResult)(o,a))).catch(a=>t(a,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:_e("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(e),await this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}async authenticate(e,t){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(e),await this.cleanupPendingPairings();const{uri:s,response:r}=await this.client.authenticate(e,t);s&&(this.uri=s,this.events.emit("display_uri",s));const o=await r();if(this.session=o.session,this.session){const a=Jc(this.session.namespaces);this.namespaces=Tn(this.namespaces,a),await this.persist("namespaces",this.namespaces),this.onConnect()}return o}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}removeListener(e,t){this.events.removeListener(e,t)}off(e,t){this.events.off(e,t)}get isWalletConnect(){return!0}async pair(e){const{uri:t,approval:s}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});t&&(this.uri=t,this.events.emit("display_uri",t));const r=await s();this.session=r;const o=Jc(r.namespaces);return this.namespaces=Tn(this.namespaces,o),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(e,t){try{if(!this.session)return;const[s,r]=this.validateChain(e),o=this.getProvider(s);o.name===hs?o.setDefaultChain(`${s}:${r}`,t):o.setDefaultChain(r,t)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(e={}){this.logger.info("Cleaning up inactive pairings...");const t=this.client.pairing.getAll();if(qt(t)){for(const s of t)e.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${t.length}`)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var e,t;if(this.client=this.providerOpts.client||await Xr.init({core:this.providerOpts.core,logger:this.providerOpts.logger||$c,relayUrl:this.providerOpts.relayUrl||Vy,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(s){throw this.logger.error("Failed to get session",s),new Error(`The provided session: ${(t=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:t.topic} doesn't exist in the Sign client`)}else{const s=this.client.session.getAll();this.session=s[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const e=[...new Set(Object.keys(this.session.namespaces).map(t=>rs(t)))];no("client",this.client),no("events",this.events),no("disableProviderPing",this.disableProviderPing),e.forEach(t=>{if(!this.session)return;const s=Cm(t,this.session),r=Vc(s),o=Tn(this.namespaces,this.optionalNamespaces),a=ao($n({},o[t]),{accounts:s,chains:r});switch(t){case"eip155":this.rpcProviders[t]=new km({namespace:a});break;case"algorand":this.rpcProviders[t]=new Gm({namespace:a});break;case"solana":this.rpcProviders[t]=new Um({namespace:a});break;case"cosmos":this.rpcProviders[t]=new Hm({namespace:a});break;case"polkadot":this.rpcProviders[t]=new Tm({namespace:a});break;case"cip34":this.rpcProviders[t]=new Zm({namespace:a});break;case"elrond":this.rpcProviders[t]=new Xm({namespace:a});break;case"multiversx":this.rpcProviders[t]=new iw({namespace:a});break;case"near":this.rpcProviders[t]=new rw({namespace:a});break;case"tezos":this.rpcProviders[t]=new cw({namespace:a});break;default:this.rpcProviders[hs]?this.rpcProviders[hs].updateNamespace(a):this.rpcProviders[hs]=new uw({namespace:a})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{var t;const{topic:s}=e;s===((t=this.session)==null?void 0:t.topic)&&this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{var t;const{params:s,topic:r}=e;if(r!==((t=this.session)==null?void 0:t.topic))return;const{event:o}=s;if(o.name==="accountsChanged"){const a=o.data;a&&qt(a)&&this.events.emit("accountsChanged",a.map(Wc))}else if(o.name==="chainChanged"){const a=s.chainId,c=s.event.data,h=rs(a),u=so(a)!==so(c)?`${h}:${so(c)}`:a;this.onChainChanged(u)}else this.events.emit(o.name,o.data);this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:t})=>{var s,r;if(e!==((s=this.session)==null?void 0:s.topic))return;const{namespaces:o}=t,a=(r=this.client)==null?void 0:r.session.get(e);this.session=ao($n({},a),{namespaces:o}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:t})}),this.client.on("session_delete",async e=>{var t;e.topic===((t=this.session)==null?void 0:t.topic)&&(await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",ao($n({},_e("USER_DISCONNECTED")),{data:e.topic})))}),this.on(At.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(e,!0)})}getProvider(e){return this.rpcProviders[e]||this.rpcProviders[hs]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var t;this.getProvider(e).updateNamespace((t=this.session)==null?void 0:t.namespaces[e])})}setNamespaces(e){const{namespaces:t={},optionalNamespaces:s={},sessionProperties:r,scopedProperties:o}=e;this.optionalNamespaces=Tn(t,s),this.sessionProperties=r,this.scopedProperties=o}validateChain(e){const[t,s]=(e==null?void 0:e.split(":"))||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[t,s];if(t&&!Object.keys(this.namespaces||{}).map(a=>rs(a)).includes(t))throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);if(t&&s)return[t,s];const r=rs(Object.keys(this.namespaces)[0]),o=this.rpcProviders[r].getDefaultChain();return[r,o]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}async onChainChanged(e,t=!1){if(!this.namespaces)return;const[s,r]=this.validateChain(e);if(!r)return;this.updateNamespaceChain(s,r),this.events.emit("chainChanged",r);const o=this.getProvider(s).getDefaultChain();t||this.getProvider(s).setDefaultChain(r),this.emitAccountsChangedOnChainChange({namespace:s,previousChainId:o,newChainId:e}),await this.persist("namespaces",this.namespaces)}emitAccountsChangedOnChainChange({namespace:e,previousChainId:t,newChainId:s}){var r,o;try{if(t===s)return;const a=(o=(r=this.session)==null?void 0:r.namespaces[e])==null?void 0:o.accounts;if(!a)return;const c=a.filter(h=>h.includes(`${s}:`)).map(Wc);if(!qt(c))return;this.events.emit("accountsChanged",c)}catch(a){this.logger.warn("Failed to emit accountsChanged on chain change",a)}}updateNamespaceChain(e,t){if(!this.namespaces)return;const s=this.namespaces[e]?e:`${e}:${t}`,r={chains:[],methods:[],events:[],defaultChain:t};this.namespaces[s]?this.namespaces[s]&&(this.namespaces[s].defaultChain=t):this.namespaces[s]=r}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(e,t){var s;const r=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.setItem(`${Rn}/${e}${r}`,t)}async getFromStore(e){var t;const s=((t=this.session)==null?void 0:t.topic)||"";return await this.client.core.storage.getItem(`${Rn}/${e}${s}`)}async deleteFromStore(e){var t;const s=((t=this.session)==null?void 0:t.topic)||"";await this.client.core.storage.removeItem(`${Rn}/${e}${s}`)}async cleanupStorage(){var e;try{if(((e=this.client)==null?void 0:e.session.length)>0)return;const t=await this.client.core.storage.getKeys();for(const s of t)s.startsWith(Rn)&&await this.client.core.storage.removeItem(s)}catch(t){this.logger.warn("Failed to cleanup storage",t)}}}const mw=co,ww="wc",_w="ethereum_provider",vw=`${ww}@2:${_w}:`,bw="https://rpc.walletconnect.org/v1/",ho=["eth_sendTransaction","personal_sign"],Ew=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_sendCalls","wallet_getCapabilities","wallet_getCallsStatus","wallet_showCallsStatus"],lo=["chainChanged","accountsChanged"],xw=["chainChanged","accountsChanged","message","disconnect","connect"],Iw=async()=>{const{createAppKit:i}=await $.e(7934).then($.bind($,67934));return i};var Pw=Object.defineProperty,Sw=Object.defineProperties,Ow=Object.getOwnPropertyDescriptors,th=Object.getOwnPropertySymbols,Aw=Object.prototype.hasOwnProperty,Cw=Object.prototype.propertyIsEnumerable,uo=(i,e,t)=>e in i?Pw(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Ui=(i,e)=>{for(var t in e||(e={}))Aw.call(e,t)&&uo(i,t,e[t]);if(th)for(var t of th(e))Cw.call(e,t)&&uo(i,t,e[t]);return i},Ws=(i,e)=>Sw(i,Ow(e)),bt=(i,e,t)=>uo(i,typeof e!="symbol"?e+"":e,t);function jn(i){return Number(i[0].split(":")[1])}function Dn(i){return`0x${i.toString(16)}`}function Rw(i){const{chains:e,optionalChains:t,methods:s,optionalMethods:r,events:o,optionalEvents:a,rpcMap:c}=i;if(!qt(e))throw new Error("Invalid chains");const h={chains:e,methods:s||ho,events:o||lo,rpcMap:Ui({},e.length?{[jn(e)]:c[jn(e)]}:{})},u=o==null?void 0:o.filter(v=>!lo.includes(v)),d=s==null?void 0:s.filter(v=>!ho.includes(v));if(!t&&!a&&!r&&!(u!=null&&u.length)&&!(d!=null&&d.length))return{required:e.length?h:void 0};const p=(u==null?void 0:u.length)&&(d==null?void 0:d.length)||!t,f={chains:[...new Set(p?h.chains.concat(t||[]):t)],methods:[...new Set(h.methods.concat(r!=null&&r.length?r:Ew))],events:[...new Set(h.events.concat(a!=null&&a.length?a:xw))],rpcMap:c};return{required:e.length?h:void 0,optional:t.length?f:void 0}}class po{constructor(){bt(this,"events",new xe.EventEmitter),bt(this,"namespace","eip155"),bt(this,"accounts",[]),bt(this,"signer"),bt(this,"chainId",1),bt(this,"modal"),bt(this,"rpc"),bt(this,"STORAGE_KEY",vw),bt(this,"on",(e,t)=>(this.events.on(e,t),this)),bt(this,"once",(e,t)=>(this.events.once(e,t),this)),bt(this,"removeListener",(e,t)=>(this.events.removeListener(e,t),this)),bt(this,"off",(e,t)=>(this.events.off(e,t),this)),bt(this,"parseAccount",e=>this.isCompatibleChainId(e)?this.parseAccountId(e).address:e),this.signer={},this.rpc={}}static async init(e){const t=new po;return await t.initialize(e),t}async request(e,t){return await this.signer.request(e,this.formatChainId(this.chainId),t)}sendAsync(e,t,s){this.signer.sendAsync(e,t,this.formatChainId(this.chainId),s)}get connected(){return this.signer.client?this.signer.client.core.relayer.connected:!1}get connecting(){return this.signer.client?this.signer.client.core.relayer.connecting:!1}async enable(){return this.session||await this.connect(),await this.request({method:"eth_requestAccounts"})}async connect(e){var t;if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts(e);const{required:s,optional:r}=Rw(this.rpc);try{const o=await new Promise(async(c,h)=>{var u,d;this.rpc.showQrModal&&((u=this.modal)==null||u.open(),(d=this.modal)==null||d.subscribeState(f=>{!f.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),h(new Error("Connection request reset. Please try again.")))}));const p=e!=null&&e.scopedProperties?{[this.namespace]:e.scopedProperties}:void 0;await this.signer.connect(Ws(Ui({namespaces:Ui({},s&&{[this.namespace]:s})},r&&{optionalNamespaces:{[this.namespace]:r}}),{pairingTopic:e==null?void 0:e.pairingTopic,scopedProperties:p})).then(f=>{c(f)}).catch(f=>{var v;(v=this.modal)==null||v.showErrorMessage("Unable to connect"),h(new Error(f.message))})});if(!o)return;const a=ei(o.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:a),this.setAccounts(a),this.events.emit("connect",{chainId:Dn(this.chainId)})}catch(o){throw this.signer.logger.error(o),o}finally{(t=this.modal)==null||t.close()}}async authenticate(e,t){var s;if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts({chains:e==null?void 0:e.chains});try{const r=await new Promise(async(a,c)=>{var h,u;this.rpc.showQrModal&&((h=this.modal)==null||h.open(),(u=this.modal)==null||u.subscribeState(d=>{!d.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),c(new Error("Connection request reset. Please try again.")))})),await this.signer.authenticate(Ws(Ui({},e),{chains:this.rpc.chains}),t).then(d=>{a(d)}).catch(d=>{var p;(p=this.modal)==null||p.showErrorMessage("Unable to connect"),c(new Error(d.message))})}),o=r.session;if(o){const a=ei(o.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:a),this.setAccounts(a),this.events.emit("connect",{chainId:Dn(this.chainId)})}return r}catch(r){throw this.signer.logger.error(r),r}finally{(s=this.modal)==null||s.close()}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset()}get isWalletConnect(){return!0}get session(){return this.signer.session}registerEventListeners(){this.signer.on("session_event",e=>{const{params:t}=e,{event:s}=t;s.name==="accountsChanged"?(this.accounts=this.parseAccounts(s.data),this.events.emit("accountsChanged",this.accounts)):s.name==="chainChanged"?this.setChainId(this.formatChainId(s.data)):this.events.emit(s.name,s.data),this.events.emit("session_event",e)}),this.signer.on("accountsChanged",e=>{this.accounts=this.parseAccounts(e),this.events.emit("accountsChanged",this.accounts)}),this.signer.on("chainChanged",e=>{const t=parseInt(e);this.chainId=t,this.events.emit("chainChanged",Dn(this.chainId)),this.persist()}),this.signer.on("session_update",e=>{this.events.emit("session_update",e)}),this.signer.on("session_delete",e=>{this.reset(),this.events.emit("session_delete",e),this.events.emit("disconnect",Ws(Ui({},_e("USER_DISCONNECTED")),{data:e.topic,name:"USER_DISCONNECTED"}))}),this.signer.on("display_uri",e=>{this.events.emit("display_uri",e)})}switchEthereumChain(e){this.request({method:"wallet_switchEthereumChain",params:[{chainId:e.toString(16)}]})}isCompatibleChainId(e){return typeof e=="string"?e.startsWith(`${this.namespace}:`):!1}formatChainId(e){return`${this.namespace}:${e}`}parseChainId(e){return Number(e.split(":")[1])}setChainIds(e){const t=e.filter(s=>this.isCompatibleChainId(s)).map(s=>this.parseChainId(s));t.length&&(this.chainId=t[0],this.events.emit("chainChanged",Dn(this.chainId)),this.persist())}setChainId(e){if(this.isCompatibleChainId(e)){const t=this.parseChainId(e);this.chainId=t,this.switchEthereumChain(t)}}parseAccountId(e){const[t,s,r]=e.split(":");return{chainId:`${t}:${s}`,address:r}}setAccounts(e){this.accounts=e.filter(t=>this.parseChainId(this.parseAccountId(t).chainId)===this.chainId).map(t=>this.parseAccountId(t).address),this.events.emit("accountsChanged",this.accounts)}getRpcConfig(e){var t,s;const r=(t=e==null?void 0:e.chains)!=null?t:[],o=(s=e==null?void 0:e.optionalChains)!=null?s:[],a=r.concat(o);if(!a.length)throw new Error("No chains specified in either `chains` or `optionalChains`");const c=r.length?(e==null?void 0:e.methods)||ho:[],h=r.length?(e==null?void 0:e.events)||lo:[],u=(e==null?void 0:e.optionalMethods)||[],d=(e==null?void 0:e.optionalEvents)||[],p=(e==null?void 0:e.rpcMap)||this.buildRpcMap(a,e.projectId),f=(e==null?void 0:e.qrModalOptions)||void 0;return{chains:r==null?void 0:r.map(v=>this.formatChainId(v)),optionalChains:o.map(v=>this.formatChainId(v)),methods:c,events:h,optionalMethods:u,optionalEvents:d,rpcMap:p,showQrModal:!!(e!=null&&e.showQrModal),qrModalOptions:f,projectId:e.projectId,metadata:e.metadata}}buildRpcMap(e,t){const s={};return e.forEach(r=>{s[r]=this.getRpcUrl(r,t)}),s}async initialize(e){if(this.rpc=this.getRpcConfig(e),this.chainId=this.rpc.chains.length?jn(this.rpc.chains):jn(this.rpc.optionalChains),this.signer=await mw.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:e.disableProviderPing,relayUrl:e.relayUrl,storage:e.storage,storageOptions:e.storageOptions,customStoragePrefix:e.customStoragePrefix,telemetryEnabled:e.telemetryEnabled,logger:e.logger}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal){let t;try{const s=await Iw(),{convertWCMToAppKitOptions:r}=await Promise.resolve().then(function(){return Uw}),o=r(Ws(Ui({},this.rpc.qrModalOptions),{chains:[...new Set([...this.rpc.chains,...this.rpc.optionalChains])],metadata:this.rpc.metadata,projectId:this.rpc.projectId}));if(!o.networks.length)throw new Error("No networks found for WalletConnect\xB7");t=s(Ws(Ui({},o),{universalProvider:this.signer,manualWCControl:!0}))}catch(s){throw console.warn(s),new Error("To use QR modal, please install @reown/appkit package")}if(t)try{this.modal=t}catch(s){throw this.signer.logger.error(s),new Error("Could not generate WalletConnectModal Instance")}}}loadConnectOpts(e){if(!e)return;const{chains:t,optionalChains:s,rpcMap:r}=e;t&&qt(t)&&(this.rpc.chains=t.map(o=>this.formatChainId(o)),t.forEach(o=>{this.rpc.rpcMap[o]=(r==null?void 0:r[o])||this.getRpcUrl(o)})),s&&qt(s)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=s==null?void 0:s.map(o=>this.formatChainId(o)),s.forEach(o=>{this.rpc.rpcMap[o]=(r==null?void 0:r[o])||this.getRpcUrl(o)}))}getRpcUrl(e,t){var s;return((s=this.rpc.rpcMap)==null?void 0:s[e])||`${bw}?chainId=eip155:${e}&projectId=${t||this.rpc.projectId}`}async loadPersistedSession(){if(this.session)try{const e=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),t=this.session.namespaces[`${this.namespace}:${e}`]?this.session.namespaces[`${this.namespace}:${e}`]:this.session.namespaces[this.namespace];this.setChainIds(e?[this.formatChainId(e)]:t==null?void 0:t.accounts),this.setAccounts(t==null?void 0:t.accounts)}catch(e){this.signer.logger.error("Failed to load persisted session, clearing state..."),this.signer.logger.error(e),await this.disconnect().catch(t=>this.signer.logger.warn(t))}}reset(){this.chainId=1,this.accounts=[]}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId)}parseAccounts(e){return typeof e=="string"||e instanceof String?[this.parseAccount(e)]:e.map(t=>this.parseAccount(t))}}const Nw=po;var Tw=Object.defineProperty,$w=Object.defineProperties,jw=Object.getOwnPropertyDescriptors,ih=Object.getOwnPropertySymbols,Dw=Object.prototype.hasOwnProperty,qw=Object.prototype.propertyIsEnumerable,sh=(i,e,t)=>e in i?Tw(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,nh=(i,e)=>{for(var t in e||(e={}))Dw.call(e,t)&&sh(i,t,e[t]);if(ih)for(var t of ih(e))qw.call(e,t)&&sh(i,t,e[t]);return i},Fw=(i,e)=>$w(i,jw(e));function kw(i){if(i)return{"--w3m-font-family":i["--wcm-font-family"],"--w3m-accent":i["--wcm-accent-color"],"--w3m-color-mix":i["--wcm-background-color"],"--w3m-z-index":i["--wcm-z-index"]?Number(i["--wcm-z-index"]):void 0,"--w3m-qr-color":i["--wcm-accent-color"],"--w3m-font-size-master":i["--wcm-text-medium-regular-size"],"--w3m-border-radius-master":i["--wcm-container-border-radius"],"--w3m-color-mix-strength":0}}const Lw=i=>{const[e,t]=i.split(":");return rh({id:t,caipNetworkId:i,chainNamespace:e,name:"",nativeCurrency:{name:"",symbol:"",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}})};function Bw(i){var e,t,s,r,o,a,c;const h=(e=i.chains)==null?void 0:e.map(Lw).filter(Boolean);if(h.length===0)throw new Error("At least one chain must be specified");const u=h.find(p=>{var f;return p.id===((f=i.defaultChain)==null?void 0:f.id)}),d={projectId:i.projectId,networks:h,themeMode:i.themeMode,themeVariables:kw(i.themeVariables),chainImages:i.chainImages,connectorImages:i.walletImages,defaultNetwork:u,metadata:Fw(nh({},i.metadata),{name:((t=i.metadata)==null?void 0:t.name)||"WalletConnect",description:((s=i.metadata)==null?void 0:s.description)||"Connect to WalletConnect-compatible wallets",url:((r=i.metadata)==null?void 0:r.url)||"https://walletconnect.org",icons:((o=i.metadata)==null?void 0:o.icons)||["https://walletconnect.org/walletconnect-logo.png"]}),showWallets:!0,featuredWalletIds:i.explorerRecommendedWalletIds==="NONE"?[]:Array.isArray(i.explorerRecommendedWalletIds)?i.explorerRecommendedWalletIds:[],excludeWalletIds:i.explorerExcludedWalletIds==="ALL"?[]:Array.isArray(i.explorerExcludedWalletIds)?i.explorerExcludedWalletIds:[],enableEIP6963:!1,enableInjected:!1,enableCoinbase:!0,enableWalletConnect:!0,features:{email:!1,socials:!1}};if((a=i.mobileWallets)!=null&&a.length||(c=i.desktopWallets)!=null&&c.length){const p=[...(i.mobileWallets||[]).map(w=>({id:w.id,name:w.name,links:w.links})),...(i.desktopWallets||[]).map(w=>({id:w.id,name:w.name,links:{native:w.links.native,universal:w.links.universal}}))],f=[...d.featuredWalletIds||[],...d.excludeWalletIds||[]],v=p.filter(w=>!f.includes(w.id));v.length&&(d.customWallets=v)}return d}function rh(i){return nh({formatters:void 0,fees:void 0,serializers:void 0},i)}var Uw=Object.freeze({__proto__:null,convertWCMToAppKitOptions:Bw,defineChain:rh})},32021:function(Es,Rt,$){$.d(Rt,{Z:function(){return di}});var xe=$(71894),Ie=$(37353),ft=$(41926);function C(ne){return ne}const Te="idb-keyval";var rt=(ne={})=>{const Q=ne.base&&ne.base.length>0?`${ne.base}:`:"",G=Ke=>Q+Ke;let De;return ne.dbName&&ne.storeName&&(De=(0,Ie.MT)(ne.dbName,ne.storeName)),{name:Te,options:ne,async hasItem(Ke){return!(typeof await(0,Ie.U2)(G(Ke),De)>"u")},async getItem(Ke){return await(0,Ie.U2)(G(Ke),De)??null},setItem(Ke,Mt){return(0,Ie.t8)(G(Ke),Mt,De)},removeItem(Ke){return(0,Ie.IV)(G(Ke),De)},getKeys(){return(0,Ie.XP)(De)},clear(){return(0,Ie.ZH)(De)}}};const de="WALLET_CONNECT_V2_INDEXED_DB",ot="keyvaluestorage";class He{constructor(){this.indexedDb=(0,xe.o6)({driver:rt({dbName:de,storeName:ot})})}async getKeys(){return this.indexedDb.getKeys()}async getEntries(){return(await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(Q=>[Q.key,Q.value])}async getItem(Q){const G=await this.indexedDb.getItem(Q);if(G!==null)return G}async setItem(Q,G){await this.indexedDb.setItem(Q,(0,ft.u)(G))}async removeItem(Q){await this.indexedDb.removeItem(Q)}}var te=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof $.g<"u"?$.g:typeof self<"u"?self:{},Nt={exports:{}};(function(){let ne;function Q(){}ne=Q,ne.prototype.getItem=function(G){return this.hasOwnProperty(G)?String(this[G]):null},ne.prototype.setItem=function(G,De){this[G]=String(De)},ne.prototype.removeItem=function(G){delete this[G]},ne.prototype.clear=function(){const G=this;Object.keys(G).forEach(function(De){G[De]=void 0,delete G[De]})},ne.prototype.key=function(G){return G=G||0,Object.keys(this)[G]},ne.prototype.__defineGetter__("length",function(){return Object.keys(this).length}),typeof te<"u"&&te.localStorage?Nt.exports=te.localStorage:typeof window<"u"&&window.localStorage?Nt.exports=window.localStorage:Nt.exports=new Q})();function se(ne){var Q;return[ne[0],(0,ft.D)((Q=ne[1])!=null?Q:"")]}class ae{constructor(){this.localStorage=Nt.exports}async getKeys(){return Object.keys(this.localStorage)}async getEntries(){return Object.entries(this.localStorage).map(se)}async getItem(Q){const G=this.localStorage.getItem(Q);if(G!==null)return(0,ft.D)(G)}async setItem(Q,G){this.localStorage.setItem(Q,(0,ft.u)(G))}async removeItem(Q){this.localStorage.removeItem(Q)}}const we="wc_storage_version",Pe=1,Et=async(ne,Q,G)=>{const De=we,Ke=await Q.getItem(De);if(Ke&&Ke>=Pe){G(Q);return}const Mt=await ne.getKeys();if(!Mt.length){G(Q);return}const ei=[];for(;Mt.length;){const Tt=Mt.shift();if(!Tt)continue;const pi=Tt.toLowerCase();if(pi.includes("wc@")||pi.includes("walletconnect")||pi.includes("wc_")||pi.includes("wallet_connect")){const zt=await ne.getItem(Tt);await Q.setItem(Tt,zt),ei.push(Tt)}}await Q.setItem(De,Pe),G(Q),Xt(ne,ei)},Xt=async(ne,Q)=>{Q.length&&Q.forEach(async G=>{await ne.removeItem(G)})};class di{constructor(){this.initialized=!1,this.setInitialized=G=>{this.storage=G,this.initialized=!0};const Q=new ae;this.storage=Q;try{const G=new He;Et(Q,G,this.setInitialized)}catch{this.initialized=!0}}async getKeys(){return await this.initialize(),this.storage.getKeys()}async getEntries(){return await this.initialize(),this.storage.getEntries()}async getItem(Q){return await this.initialize(),this.storage.getItem(Q)}async setItem(Q,G){return await this.initialize(),this.storage.setItem(Q,G)}async removeItem(Q){return await this.initialize(),this.storage.removeItem(Q)}async initialize(){this.initialized||await new Promise(Q=>{const G=setInterval(()=>{this.initialized&&(clearInterval(G),Q())},20)})}}},6504:function(Es,Rt,$){$.d(Rt,{$h:function(){return Te},eB:function(){return rt},gk:function(){return ft},k8:function(){return xe},z3:function(){return C}});function xe(de){if(!Number.isSafeInteger(de)||de<0)throw new Error("positive integer expected, got "+de)}function Ie(de){return de instanceof Uint8Array||ArrayBuffer.isView(de)&&de.constructor.name==="Uint8Array"}function ft(de,...ot){if(!Ie(de))throw new Error("Uint8Array expected");if(ot.length>0&&!ot.includes(de.length))throw new Error("Uint8Array expected of length "+ot+", got length="+de.length)}function C(de){if(typeof de!="function"||typeof de.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");xe(de.outputLen),xe(de.blockLen)}function Te(de,ot=!0){if(de.destroyed)throw new Error("Hash instance has been destroyed");if(ot&&de.finished)throw new Error("Hash#digest() has already been called")}function rt(de,ot){ft(de);const He=ot.outputLen;if(de.length<He)throw new Error("digestInto() expects output buffer of length at least "+He)}},3893:function(Es,Rt,$){$.d(Rt,{kb:function(){return Ke},l1:function(){return se},eV:function(){return De},GL:function(){return rt},iA:function(){return He},O6:function(){return zt},np:function(){return de},O0:function(){return G},Jq:function(){return Te},hE:function(){return ei}});const xe=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var Ie=$(6504);function ft(N){return N instanceof Uint8Array||ArrayBuffer.isView(N)&&N.constructor.name==="Uint8Array"}function C(N){return new Uint8Array(N.buffer,N.byteOffset,N.byteLength)}function Te(N){return new Uint32Array(N.buffer,N.byteOffset,Math.floor(N.byteLength/4))}function rt(N){return new DataView(N.buffer,N.byteOffset,N.byteLength)}function de(N,ee){return N<<32-ee|N>>>ee}function ot(N,ee){return N<<ee|N>>>32-ee>>>0}const He=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function te(N){return N<<24&4278190080|N<<8&16711680|N>>>8&65280|N>>>24&255}const Nt=null;function se(N){for(let ee=0;ee<N.length;ee++)N[ee]=te(N[ee])}const ae=Array.from({length:256},(N,ee)=>ee.toString(16).padStart(2,"0"));function we(N){abytes(N);let ee="";for(let Ae=0;Ae<N.length;Ae++)ee+=ae[N[Ae]];return ee}const Pe={_0:48,_9:57,A:65,F:70,a:97,f:102};function Et(N){if(N>=Pe._0&&N<=Pe._9)return N-Pe._0;if(N>=Pe.A&&N<=Pe.F)return N-(Pe.A-10);if(N>=Pe.a&&N<=Pe.f)return N-(Pe.a-10)}function Xt(N){if(typeof N!="string")throw new Error("hex string expected, got "+typeof N);const ee=N.length,Ae=ee/2;if(ee%2)throw new Error("hex string expected, got unpadded hex of length "+ee);const ve=new Uint8Array(Ae);for(let $e=0,Qe=0;$e<Ae;$e++,Qe+=2){const ht=Et(N.charCodeAt(Qe)),gi=Et(N.charCodeAt(Qe+1));if(ht===void 0||gi===void 0){const zi=N[Qe]+N[Qe+1];throw new Error('hex string expected, got non-hex character "'+zi+'" at index '+Qe)}ve[$e]=ht*16+gi}return ve}const di=async()=>{};async function ne(N,ee,Ae){let ve=Date.now();for(let $e=0;$e<N;$e++){Ae($e);const Qe=Date.now()-ve;Qe>=0&&Qe<ee||(await di(),ve+=Qe)}}function Q(N){if(typeof N!="string")throw new Error("utf8ToBytes expected string, got "+typeof N);return new Uint8Array(new TextEncoder().encode(N))}function G(N){return typeof N=="string"&&(N=Q(N)),(0,Ie.gk)(N),N}function De(...N){let ee=0;for(let ve=0;ve<N.length;ve++){const $e=N[ve];(0,Ie.gk)($e),ee+=$e.length}const Ae=new Uint8Array(ee);for(let ve=0,$e=0;ve<N.length;ve++){const Qe=N[ve];Ae.set(Qe,$e),$e+=Qe.length}return Ae}class Ke{clone(){return this._cloneInto()}}function Mt(N,ee){if(ee!==void 0&&{}.toString.call(ee)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(N,ee)}function ei(N){const ee=ve=>N().update(G(ve)).digest(),Ae=N();return ee.outputLen=Ae.outputLen,ee.blockLen=Ae.blockLen,ee.create=()=>N(),ee}function Tt(N){const ee=(ve,$e)=>N($e).update(G(ve)).digest(),Ae=N({});return ee.outputLen=Ae.outputLen,ee.blockLen=Ae.blockLen,ee.create=ve=>N(ve),ee}function pi(N){const ee=(ve,$e)=>N($e).update(G(ve)).digest(),Ae=N({});return ee.outputLen=Ae.outputLen,ee.blockLen=Ae.blockLen,ee.create=ve=>N(ve),ee}function zt(N=32){if(xe&&typeof xe.getRandomValues=="function")return xe.getRandomValues(new Uint8Array(N));if(xe&&typeof xe.randomBytes=="function")return xe.randomBytes(N);throw new Error("crypto.getRandomValues must be defined")}},90032:function(Es,Rt,$){$.d(Rt,{zo:function(){return ft},mL:function(){return te},BB:function(){return Nt}});function xe(se=0){return globalThis.Buffer!=null&&globalThis.Buffer.alloc!=null?globalThis.Buffer.alloc(se):new Uint8Array(se)}function Ie(se=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(se):new Uint8Array(se)}function ft(se,ae){ae||(ae=se.reduce((Et,Xt)=>Et+Xt.length,0));const we=Ie(ae);let Pe=0;for(const Et of se)we.set(Et,Pe),Pe+=Et.length;return we}var C=$(64826);function Te(se,ae,we,Pe){return{name:se,prefix:ae,encoder:{name:se,prefix:ae,encode:we},decoder:{decode:Pe}}}const rt=Te("utf8","u",se=>"u"+new TextDecoder("utf8").decode(se),se=>new TextEncoder().encode(se.substring(1))),de=Te("ascii","a",se=>{let ae="a";for(let we=0;we<se.length;we++)ae+=String.fromCharCode(se[we]);return ae},se=>{se=se.substring(1);const ae=Ie(se.length);for(let we=0;we<se.length;we++)ae[we]=se.charCodeAt(we);return ae});var He={utf8:rt,"utf-8":rt,hex:C.gh.base16,latin1:de,ascii:de,binary:de,...C.gh};function te(se,ae="utf8"){const we=He[ae];if(!we)throw new Error(`Unsupported encoding "${ae}"`);return(ae==="utf8"||ae==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(se,"utf8"):we.decoder.decode(`${we.prefix}${se}`)}function Nt(se,ae="utf8"){const we=He[ae];if(!we)throw new Error(`Unsupported encoding "${ae}"`);return(ae==="utf8"||ae==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(se.buffer,se.byteOffset,se.byteLength).toString("utf8"):we.encoder.encode(se).substring(1)}},42014:function(Es,Rt,$){$.d(Rt,{R:function(){return on}});const xe="2.23.2";let Ie={getDocsUrl:({docsBaseUrl:y,docsPath:g="",docsSlug:m})=>g?`${y??"https://viem.sh"}${g}${m?`#${m}`:""}`:void 0,version:`viem@${xe}`};function ft(y){Ie=y}class C extends Error{constructor(g,m={}){var ue;const I=(()=>{var qe;return m.cause instanceof C?m.cause.details:(qe=m.cause)!=null&&qe.message?m.cause.message:m.details})(),B=m.cause instanceof C&&m.cause.docsPath||m.docsPath,W=(ue=Ie.getDocsUrl)==null?void 0:ue.call(Ie,{...m,docsPath:B}),z=[g||"An error occurred.","",...m.metaMessages?[...m.metaMessages,""]:[],...W?[`Docs: ${W}`]:[],...I?[`Details: ${I}`]:[],...Ie.version?[`Version: ${Ie.version}`]:[]].join(`
`);super(z,m.cause?{cause:m.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=I,this.docsPath=B,this.metaMessages=m.metaMessages,this.name=m.name??this.name,this.shortMessage=g,this.version=xe}walk(g){return Te(this,g)}}function Te(y,g){return g!=null&&g(y)?y:y&&typeof y=="object"&&"cause"in y&&y.cause!==void 0?Te(y.cause,g):g?null:y}function rt(y,{strict:g=!0}={}){return!y||typeof y!="string"?!1:g?/^0x[0-9a-fA-F]*$/.test(y):y.startsWith("0x")}class de extends null{constructor({offset:g,position:m,size:I}){super(`Slice ${m==="start"?"starting":"ending"} at offset "${g}" is out-of-bounds (size: ${I}).`,{name:"SliceOffsetOutOfBoundsError"})}}class ot extends C{constructor({size:g,targetSize:m,type:I}){super(`${I.charAt(0).toUpperCase()}${I.slice(1).toLowerCase()} size (${g}) exceeds padding size (${m}).`,{name:"SizeExceedsPaddingSizeError"})}}class He extends null{constructor({size:g,targetSize:m,type:I}){super(`${I.charAt(0).toUpperCase()}${I.slice(1).toLowerCase()} is expected to be ${m} ${I} long, but is ${g} ${I} long.`,{name:"InvalidBytesLengthError"})}}function te(y,{dir:g,size:m=32}={}){return typeof y=="string"?Nt(y,{dir:g,size:m}):se(y,{dir:g,size:m})}function Nt(y,{dir:g,size:m=32}={}){if(m===null)return y;const I=y.replace("0x","");if(I.length>m*2)throw new ot({size:Math.ceil(I.length/2),targetSize:m,type:"hex"});return`0x${I[g==="right"?"padEnd":"padStart"](m*2,"0")}`}function se(y,{dir:g,size:m=32}={}){if(m===null)return y;if(y.length>m)throw new ot({size:y.length,targetSize:m,type:"bytes"});const I=new Uint8Array(m);for(let B=0;B<m;B++){const W=g==="right";I[W?B:m-B-1]=y[W?B:y.length-B-1]}return I}class ae extends C{constructor({max:g,min:m,signed:I,size:B,value:W}){super(`Number "${W}" is not in safe ${B?`${B*8}-bit ${I?"signed":"unsigned"} `:""}integer range ${g?`(${m} to ${g})`:`(above ${m})`}`,{name:"IntegerOutOfRangeError"})}}class we extends null{constructor(g){super(`Bytes value "${g}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,{name:"InvalidBytesBooleanError"})}}class Pe extends null{constructor(g){super(`Hex value "${g}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`,{name:"InvalidHexBooleanError"})}}class Et extends null{constructor(g){super(`Hex value "${g}" is an odd length (${g.length}). It must be an even length.`,{name:"InvalidHexValueError"})}}class Xt extends C{constructor({givenSize:g,maxSize:m}){super(`Size cannot exceed ${m} bytes. Given size: ${g} bytes.`,{name:"SizeOverflowError"})}}function di(y){return rt(y,{strict:!1})?Math.ceil((y.length-2)/2):y.length}function ne(y,{size:g}){if(di(y)>g)throw new Xt({givenSize:di(y),maxSize:g})}function Q(y,g){const m=typeof g=="string"?{to:g}:g,I=m.to;return I==="number"?Ke(y,m):I==="bigint"?G(y,m):I==="string"?Mt(y,m):I==="boolean"?De(y,m):hexToBytes(y,m)}function G(y,g={}){const{signed:m}=g;g.size&&ne(y,{size:g.size});const I=BigInt(y);if(!m)return I;const B=(y.length-2)/2,W=(1n<<BigInt(B)*8n-1n)-1n;return I<=W?I:I-BigInt(`0x${"f".padStart(B*2,"f")}`)-1n}function De(y,g={}){let m=y;if(g.size&&(ne(m,{size:g.size}),m=trim(m)),trim(m)==="0x00")return!1;if(trim(m)==="0x01")return!0;throw new InvalidHexBooleanError(m)}function Ke(y,g={}){return Number(G(y,g))}function Mt(y,g={}){let m=hexToBytes(y);return g.size&&(ne(m,{size:g.size}),m=trim(m,{dir:"right"})),new TextDecoder().decode(m)}const ei=Array.from({length:256},(y,g)=>g.toString(16).padStart(2,"0"));function Tt(y,g={}){return typeof y=="number"||typeof y=="bigint"?N(y,g):typeof y=="string"?Ae(y,g):typeof y=="boolean"?pi(y,g):zt(y,g)}function pi(y,g={}){const m=`0x${Number(y)}`;return typeof g.size=="number"?(ne(m,{size:g.size}),te(m,{size:g.size})):m}function zt(y,g={}){let m="";for(let B=0;B<y.length;B++)m+=ei[y[B]];const I=`0x${m}`;return typeof g.size=="number"?(ne(I,{size:g.size}),te(I,{dir:"right",size:g.size})):I}function N(y,g={}){const{signed:m,size:I}=g,B=BigInt(y);let W;I?m?W=(1n<<BigInt(I)*8n-1n)-1n:W=2n**(BigInt(I)*8n)-1n:typeof y=="number"&&(W=BigInt(Number.MAX_SAFE_INTEGER));const z=typeof W=="bigint"&&m?-W-1n:0;if(W&&B>W||B<z){const qe=typeof y=="bigint"?"n":"";throw new ae({max:W?`${W}${qe}`:void 0,min:`${z}${qe}`,signed:m,size:I,value:`${y}${qe}`})}const ue=`0x${(m&&B<0?(1n<<BigInt(I*8))+BigInt(B):B).toString(16)}`;return I?te(ue,{size:I}):ue}const ee=new TextEncoder;function Ae(y,g={}){const m=ee.encode(y);return zt(m,g)}const ve=new TextEncoder;function $e(y,g={}){return typeof y=="number"||typeof y=="bigint"?Fn(y,g):typeof y=="boolean"?Qe(y,g):rt(y)?zi(y,g):Xe(y,g)}function Qe(y,g={}){const m=new Uint8Array(1);return m[0]=Number(y),typeof g.size=="number"?(ne(m,{size:g.size}),te(m,{size:g.size})):m}const ht={zero:48,nine:57,A:65,F:70,a:97,f:102};function gi(y){if(y>=ht.zero&&y<=ht.nine)return y-ht.zero;if(y>=ht.A&&y<=ht.F)return y-(ht.A-10);if(y>=ht.a&&y<=ht.f)return y-(ht.a-10)}function zi(y,g={}){let m=y;g.size&&(ne(m,{size:g.size}),m=te(m,{dir:"right",size:g.size}));let I=m.slice(2);I.length%2&&(I=`0${I}`);const B=I.length/2,W=new Uint8Array(B);for(let z=0,ue=0;z<B;z++){const qe=gi(I.charCodeAt(ue++)),Fe=gi(I.charCodeAt(ue++));if(qe===void 0||Fe===void 0)throw new C(`Invalid byte sequence ("${I[ue-2]}${I[ue-1]}" in "${I}").`);W[z]=qe*16+Fe}return W}function Fn(y,g){const m=N(y,g);return zi(m)}function Xe(y,g={}){const m=ve.encode(y);return typeof g.size=="number"?(ne(m,{size:g.size}),te(m,{dir:"right",size:g.size})):m}var Ht=$(6504);const xs=BigInt(2**32-1),Is=BigInt(32);function Ps(y,g=!1){return g?{h:Number(y&xs),l:Number(y>>Is&xs)}:{h:Number(y>>Is&xs)|0,l:Number(y&xs)|0}}function kn(y,g=!1){let m=new Uint32Array(y.length),I=new Uint32Array(y.length);for(let B=0;B<y.length;B++){const{h:W,l:z}=Ps(y[B],g);[m[B],I[B]]=[W,z]}return[m,I]}const Ln=(y,g)=>BigInt(y>>>0)<<Is|BigInt(g>>>0),Hi=(y,g,m)=>y>>>m,Kt=(y,g,m)=>y<<32-m|g>>>m,Bn=(y,g,m)=>y>>>m|g<<32-m,Un=(y,g,m)=>y<<32-m|g>>>m,fi=(y,g,m)=>y<<64-m|g>>>m-32,yi=(y,g,m)=>y>>>m-32|g<<64-m,Js=(y,g)=>g,Mn=(y,g)=>y,Zs=(y,g,m)=>y<<m|g>>>32-m,Ss=(y,g,m)=>g<<m|y>>>32-m,zn=(y,g,m)=>g<<m-32|y>>>64-m,Ys=(y,g,m)=>y<<m-32|g>>>64-m;function Hn(y,g,m,I){const B=(g>>>0)+(I>>>0);return{h:y+m+(B/2**32|0)|0,l:B|0}}const mi={fromBig:Ps,split:kn,toBig:Ln,shrSH:Hi,shrSL:Kt,rotrSH:Bn,rotrSL:Un,rotrBH:fi,rotrBL:yi,rotr32H:Js,rotr32L:Mn,rotlSH:Zs,rotlSL:Ss,rotlBH:zn,rotlBL:Ys,add:Hn,add3L:(y,g,m)=>(y>>>0)+(g>>>0)+(m>>>0),add3H:(y,g,m,I)=>g+m+I+(y/2**32|0)|0,add4L:(y,g,m,I)=>(y>>>0)+(g>>>0)+(m>>>0)+(I>>>0),add4H:(y,g,m,I,B)=>g+m+I+B+(y/2**32|0)|0,add5H:(y,g,m,I,B,W)=>g+m+I+B+W+(y/2**32|0)|0,add5L:(y,g,m,I,B)=>(y>>>0)+(g>>>0)+(m>>>0)+(I>>>0)+(B>>>0)};var yo=null,xt=$(3893);const Ki=[],Vn=[],Gn=[],Wn=BigInt(0),Vi=BigInt(1),ti=BigInt(2),Vt=BigInt(7),Qs=BigInt(256),Jn=BigInt(113);for(let y=0,g=Vi,m=1,I=0;y<24;y++){[m,I]=[I,(2*m+3*I)%5],Ki.push(2*(5*I+m)),Vn.push((y+1)*(y+2)/2%64);let B=Wn;for(let W=0;W<7;W++)g=(g<<Vi^(g>>Vt)*Jn)%Qs,g&ti&&(B^=Vi<<(Vi<<BigInt(W))-Vi);Gn.push(B)}const[Zn,Xs]=kn(Gn,!0),Ne=(y,g,m)=>m>32?zn(y,g,m):Zs(y,g,m),$t=(y,g,m)=>m>32?Ys(y,g,m):Ss(y,g,m);function pe(y,g=24){const m=new Uint32Array(10);for(let I=24-g;I<24;I++){for(let z=0;z<10;z++)m[z]=y[z]^y[z+10]^y[z+20]^y[z+30]^y[z+40];for(let z=0;z<10;z+=2){const ue=(z+8)%10,qe=(z+2)%10,Fe=m[qe],It=m[qe+1],As=Ne(Fe,It,1)^m[ue],Gi=$t(Fe,It,1)^m[ue+1];for(let vi=0;vi<50;vi+=10)y[z+vi]^=As,y[z+vi+1]^=Gi}let B=y[2],W=y[3];for(let z=0;z<24;z++){const ue=Vn[z],qe=Ne(B,W,ue),Fe=$t(B,W,ue),It=Ki[z];B=y[It],W=y[It+1],y[It]=qe,y[It+1]=Fe}for(let z=0;z<50;z+=10){for(let ue=0;ue<10;ue++)m[ue]=y[z+ue];for(let ue=0;ue<10;ue++)y[z+ue]^=~m[(ue+2)%10]&m[(ue+4)%10]}y[0]^=Zn[I],y[1]^=Xs[I]}m.fill(0)}class Ue extends xt.kb{constructor(g,m,I,B=!1,W=24){if(super(),this.blockLen=g,this.suffix=m,this.outputLen=I,this.enableXOF=B,this.rounds=W,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,Ht.k8)(I),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,xt.Jq)(this.state)}keccak(){xt.iA||(0,xt.l1)(this.state32),pe(this.state32,this.rounds),xt.iA||(0,xt.l1)(this.state32),this.posOut=0,this.pos=0}update(g){(0,Ht.$h)(this);const{blockLen:m,state:I}=this;g=(0,xt.O0)(g);const B=g.length;for(let W=0;W<B;){const z=Math.min(m-this.pos,B-W);for(let ue=0;ue<z;ue++)I[this.pos++]^=g[W++];this.pos===m&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:g,suffix:m,pos:I,blockLen:B}=this;g[I]^=m,m&128&&I===B-1&&this.keccak(),g[B-1]^=128,this.keccak()}writeInto(g){(0,Ht.$h)(this,!1),(0,Ht.gk)(g),this.finish();const m=this.state,{blockLen:I}=this;for(let B=0,W=g.length;B<W;){this.posOut>=I&&this.keccak();const z=Math.min(I-this.posOut,W-B);g.set(m.subarray(this.posOut,this.posOut+z),B),this.posOut+=z,B+=z}return g}xofInto(g){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(g)}xof(g){return(0,Ht.k8)(g),this.xofInto(new Uint8Array(g))}digestInto(g){if((0,Ht.eB)(g,this),this.finished)throw new Error("digest() was already called");return this.writeInto(g),this.destroy(),g}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(g){const{blockLen:m,suffix:I,outputLen:B,rounds:W,enableXOF:z}=this;return g||(g=new Ue(m,I,B,z,W)),g.state32.set(this.state32),g.pos=this.pos,g.posOut=this.posOut,g.finished=this.finished,g.rounds=W,g.suffix=I,g.outputLen=B,g.enableXOF=z,g.destroyed=this.destroyed,g}}const Yn=(y,g,m)=>(0,xt.hE)(()=>new Ue(g,y,m)),mo=null,wo=null,_o=null,Qn=null,Xn=null,en=Yn(1,136,256/8),tn=null,vo=null,bo=(y,g,m)=>wrapXOFConstructorWithOpts((I={})=>new Ue(g,y,I.dkLen===void 0?m:I.dkLen,!0)),Eo=null,er=null;function sn(y,g){const m=g||"hex",I=en(rt(y,{strict:!1})?$e(y):y);return m==="bytes"?I:Tt(I)}class Oi extends Map{constructor(g){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=g}get(g){const m=super.get(g);return super.has(g)&&m!==void 0&&(this.delete(g),super.set(g,m)),m}set(g,m){if(super.set(g,m),this.maxSize&&this.size>this.maxSize){const I=this.keys().next().value;I&&this.delete(I)}return this}}const Os=new Oi(8192);function wi(y,g){if(Os.has(`${y}.${g}`))return Os.get(`${y}.${g}`);const m=g?`${g}${y.toLowerCase()}`:y.substring(2).toLowerCase(),I=sn(Xe(m),"bytes"),B=(g?m.substring(`${g}0x`.length):m).split("");for(let z=0;z<40;z+=2)I[z>>1]>>4>=8&&B[z]&&(B[z]=B[z].toUpperCase()),(I[z>>1]&15)>=8&&B[z+1]&&(B[z+1]=B[z+1].toUpperCase());const W=`0x${B.join("")}`;return Os.set(`${y}.${g}`,W),W}function nn(y,g){if(!isAddress(y,{strict:!1}))throw new InvalidAddressError({address:y});return wi(y,g)}function _i(y){const g=sn(`0x${y.substring(4)}`).substring(26);return wi(`0x${g}`)}async function rn({hash:y,signature:g}){const m=rt(y)?y:Tt(y),{secp256k1:I}=await $.e(8362).then($.bind($,49678));return`0x${(()=>{if(typeof g=="object"&&"r"in g&&"s"in g){const{r:Fe,s:It,v:As,yParity:Gi}=g,vi=Number(Gi??As),bi=Ai(vi);return new I.Signature(G(Fe),G(It)).addRecoveryBit(bi)}const z=rt(g)?g:Tt(g),ue=Ke(`0x${z.slice(130)}`),qe=Ai(ue);return I.Signature.fromCompact(z.substring(2,130)).addRecoveryBit(qe)})().recoverPublicKey(m.substring(2)).toHex(!1)}`}function Ai(y){if(y===0||y===1)return y;if(y===27)return 0;if(y===28)return 1;throw new Error("Invalid yParityOrV value")}async function on({hash:y,signature:g}){return _i(await rn({hash:y,signature:g}))}}}]);
