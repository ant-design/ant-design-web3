"use strict";(self.webpackChunk_ant_design_web3_docs=self.webpackChunk_ant_design_web3_docs||[]).push([[1904],{63470:function(d,a,e){var n;e.r(a),e.d(a,{demos:function(){return l}});var t=e(90228),o=e.n(t),f=e(87999),u=e.n(f),i=e(1735),w=e(50163),_=e(68035),g=e(96229),v=e(56195),I=e(36109),p=e(50515),l={"docs-course-advanced-call-contract-solana-demo-solana-tx-without-wallet":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,21509))})),asset:{type:"BLOCK",id:"docs-course-advanced-call-contract-solana-demo-solana-tx-without-wallet",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(73306).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},"@solana/web3.js":{type:"NPM",value:"1.98.0"},antd:{type:"NPM",value:"5.22.7"}},entry:"index.tsx"},context:{react:n||(n=e.t(i,2)),"@solana/web3.js":_,antd:g},renderOpts:{compile:function(){var c=u()(o()().mark(function s(){var m,y=arguments;return o()().wrap(function(h){for(;;)switch(h.prev=h.next){case 0:return h.next=2,e.e(6536).then(e.bind(e,96536));case 2:return h.abrupt("return",(m=h.sent).default.apply(m,y));case 3:case"end":return h.stop()}},s)}));function r(){return c.apply(this,arguments)}return r}()}},"docs-course-advanced-call-contract-solana-demo-solana-tx-with-wallet":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,78289))})),asset:{type:"BLOCK",id:"docs-course-advanced-call-contract-solana-demo-solana-tx-with-wallet",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(66386).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},"@ant-design/web3-solana":{type:"NPM",value:"1.3.1"},"./solana-memo-call.tsx":{type:"FILE",value:e(31740).Z},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@solana/web3.js":{type:"NPM",value:"1.98.0"},antd:{type:"NPM",value:"5.22.7"}},entry:"index.tsx"},context:{"./solana-memo-call.tsx":I,react:n||(n=e.t(i,2)),"@ant-design/web3-solana":v,"/home/runner/work/ant-design-web3/ant-design-web3/docs/course/demos/solana-memo-call.tsx":I,"@ant-design/web3":p,"@solana/web3.js":_,antd:g},renderOpts:{compile:function(){var c=u()(o()().mark(function s(){var m,y=arguments;return o()().wrap(function(h){for(;;)switch(h.prev=h.next){case 0:return h.next=2,e.e(6536).then(e.bind(e,96536));case 2:return h.abrupt("return",(m=h.sent).default.apply(m,y));case 3:case"end":return h.stop()}},s)}));function r(){return c.apply(this,arguments)}return r}()}}}},1329:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(18087),o={}},21145:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(63242),o={}},71095:function(d,a,e){var n;e.r(a),e.d(a,{demos:function(){return l}});var t=e(90228),o=e.n(t),f=e(87999),u=e.n(f),i=e(1735),w=e(11618),_=e(50515),g=e(54741),v=e(96229),I=e(66279),p=e(41211),l={"docs-course-contract-dapp-demo-dapp":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,70660))})),asset:{type:"BLOCK",id:"docs-course-contract-dapp-demo-dapp",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(37753).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ant-design/web3-wagmi":{type:"NPM",value:"2.10.3"},antd:{type:"NPM",value:"5.22.7"},undefined:{type:"NPM"},wagmi:{type:"NPM",value:"2.14.16"}},entry:"index.tsx"},context:{react:n||(n=e.t(i,2)),"@ant-design/web3":_,"@ant-design/web3-wagmi":g,antd:v,viem:I,wagmi:p},renderOpts:{compile:function(){var c=u()(o()().mark(function s(){var m,y=arguments;return o()().wrap(function(h){for(;;)switch(h.prev=h.next){case 0:return h.next=2,e.e(6536).then(e.bind(e,96536));case 2:return h.abrupt("return",(m=h.sent).default.apply(m,y));case 3:case"end":return h.stop()}},s)}));function r(){return c.apply(this,arguments)}return r}()}}}},64043:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(13697),o={}},24081:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(94431),o={}},8985:function(d,a,e){var n;e.r(a),e.d(a,{demos:function(){return l}});var t=e(90228),o=e.n(t),f=e(87999),u=e.n(f),i=e(1735),w=e(30098),_=e(50515),g=e(54741),v=e(96229),I=e(66279),p=e(41211),l={"docs-course-dev-call-contract-demo-call-contract":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,31323))})),asset:{type:"BLOCK",id:"docs-course-dev-call-contract-demo-call-contract",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(99225).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ant-design/web3-wagmi":{type:"NPM",value:"2.10.3"},antd:{type:"NPM",value:"5.22.7"},undefined:{type:"NPM"},wagmi:{type:"NPM",value:"2.14.16"}},entry:"index.tsx"},context:{react:n||(n=e.t(i,2)),"@ant-design/web3":_,"@ant-design/web3-wagmi":g,antd:v,viem:I,wagmi:p},renderOpts:{compile:function(){var c=u()(o()().mark(function s(){var m,y=arguments;return o()().wrap(function(h){for(;;)switch(h.prev=h.next){case 0:return h.next=2,e.e(6536).then(e.bind(e,96536));case 2:return h.abrupt("return",(m=h.sent).default.apply(m,y));case 3:case"end":return h.stop()}},s)}));function r(){return c.apply(this,arguments)}return r}()}}}},85077:function(d,a,e){e.r(a),e.d(a,{demos:function(){return g}});var n=e(90228),t=e.n(n),o=e(87999),f=e.n(o),u=e(1735),i=e(45905),w=e(50515),_=e(54741),g={"docs-course-dev-connect-demo-connect":{component:u.memo(u.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,78355))})),asset:{type:"BLOCK",id:"docs-course-dev-connect-demo-connect",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(52712).Z},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ant-design/web3-wagmi":{type:"NPM",value:"2.10.3"}},entry:"index.tsx"},context:{"@ant-design/web3":w,"@ant-design/web3-wagmi":_},renderOpts:{compile:function(){var v=f()(t()().mark(function p(){var l,c=arguments;return t()().wrap(function(s){for(;;)switch(s.prev=s.next){case 0:return s.next=2,e.e(6536).then(e.bind(e,96536));case 2:return s.abrupt("return",(l=s.sent).default.apply(l,c));case 3:case"end":return s.stop()}},p)}));function I(){return v.apply(this,arguments)}return I}()}}}},26288:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(92519),o={}},45933:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(9181),o={}},66443:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(37745),o={}},30834:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(64223),o={}},95856:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(65306),o={}},26369:function(d,a,e){var n;e.r(a),e.d(a,{demos:function(){return v}});var t=e(90228),o=e.n(t),f=e(87999),u=e.n(f),i=e(1735),w=e(49935),_=e(50515),g=e(98185),v={"docs-guide-adapter-demo-adapter":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,88473))})),asset:{type:"BLOCK",id:"docs-guide-adapter-demo-adapter",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(46791).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ant-design/web3-common":{type:"NPM",value:"1.19.0"}},entry:"index.tsx"},context:{react:n||(n=e.t(i,2)),"@ant-design/web3":_,"@ant-design/web3-common":g},renderOpts:{compile:function(){var I=u()(o()().mark(function l(){var c,r=arguments;return o()().wrap(function(m){for(;;)switch(m.prev=m.next){case 0:return m.next=2,e.e(6536).then(e.bind(e,96536));case 2:return m.abrupt("return",(c=m.sent).default.apply(c,r));case 3:case"end":return m.stop()}},l)}));function p(){return I.apply(this,arguments)}return p}()}}}},77212:function(d,a,e){var n;e.r(a),e.d(a,{demos:function(){return D}});var t=e(90228),o=e.n(t),f=e(87999),u=e.n(f),i=e(1735),w=e(98758),_=e(50515),g=e(61461),v=e(96229),I=e(29488),p=e(51148),l=e(3535),c=e(19019),r=e(81313),s=e(11804),m=e(96153),y=e(87976),x=e(41074),h=e(56195),M=e(54741),P=e(45302),D={"docs-guide-ant-design-web-3-demo-try-it-out":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,54363))})),asset:{type:"BLOCK",id:"docs-guide-ant-design-web-3-demo-try-it-out",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(80956).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ctrl/tinycolor":{type:"NPM",value:"4.1.0"},antd:{type:"NPM",value:"5.22.7"},"./ton.tsx":{type:"FILE",value:e(86061).Z},"../tokens.ts":{type:"FILE",value:e(16697).Z},"./bitcoin.tsx":{type:"FILE",value:e(51930).Z},"./ethereum.tsx":{type:"FILE",value:e(20285).Z},"./index.module.less":{type:"FILE",value:e(32598).Z},"./solana.tsx":{type:"FILE",value:e(42300).Z},"./sui.tsx":{type:"FILE",value:e(79473).Z},"@ant-design/web3-bitcoin":{type:"NPM",value:"1.5.3"},"@ant-design/web3-ton":{type:"NPM",value:"1.1.0"},"@ant-design/web3-solana":{type:"NPM",value:"1.3.1"},"@ant-design/web3-wagmi":{type:"NPM",value:"2.10.3"},"@ant-design/web3-sui":{type:"NPM",value:"1.0.11"}},entry:"index.tsx"},context:{"./ton.tsx":I,"../tokens.ts":p,"./bitcoin.tsx":l,"./ethereum.tsx":c,"./index.module.less":r,"./solana.tsx":s,"./sui.tsx":m,react:n||(n=e.t(i,2)),"@ant-design/web3":_,"@ctrl/tinycolor":g,antd:v,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/try-it-out/ton.tsx":I,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/tokens.ts":p,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/try-it-out/bitcoin.tsx":l,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/try-it-out/ethereum.tsx":c,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/try-it-out/index.module.less":r,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/try-it-out/solana.tsx":s,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/try-it-out/sui.tsx":m,"@ant-design/web3-bitcoin":y,"@ant-design/web3-ton":x,"@ant-design/web3-solana":h,"@ant-design/web3-wagmi":M,"@ant-design/web3-sui":P},renderOpts:{compile:function(){var C=u()(o()().mark(function b(){var T,O=arguments;return o()().wrap(function(E){for(;;)switch(E.prev=E.next){case 0:return E.next=2,e.e(6536).then(e.bind(e,96536));case 2:return E.abrupt("return",(T=E.sent).default.apply(T,O));case 3:case"end":return E.stop()}},b)}));function A(){return C.apply(this,arguments)}return A}()}}}},35758:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(81286),o={}},9588:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(79465),o={}},2138:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(77966),o={}},9862:function(d,a,e){e.r(a),e.d(a,{demos:function(){return _}});var n=e(90228),t=e.n(n),o=e(87999),f=e.n(o),u=e(1735),i=e(11262),w=e(50515),_={"docs-guide-intl-demo-intl":{component:u.memo(u.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,8673))})),asset:{type:"BLOCK",id:"docs-guide-intl-demo-intl",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(58097).Z},"@ant-design/web3":{type:"NPM",value:"1.23.0"}},entry:"index.tsx",title:"Component configuration"},context:{"@ant-design/web3":w},renderOpts:{compile:function(){var g=f()(t()().mark(function I(){var p,l=arguments;return t()().wrap(function(r){for(;;)switch(r.prev=r.next){case 0:return r.next=2,e.e(6536).then(e.bind(e,96536));case 2:return r.abrupt("return",(p=r.sent).default.apply(p,l));case 3:case"end":return r.stop()}},I)}));function v(){return g.apply(this,arguments)}return v}()}},"docs-guide-intl-demo-intl-with-provider":{component:u.memo(u.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,90450))})),asset:{type:"BLOCK",id:"docs-guide-intl-demo-intl-with-provider",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(92767).Z},"@ant-design/web3":{type:"NPM",value:"1.23.0"}},entry:"index.tsx",title:"Global configuration"},context:{"@ant-design/web3":w},renderOpts:{compile:function(){var g=f()(t()().mark(function I(){var p,l=arguments;return t()().wrap(function(r){for(;;)switch(r.prev=r.next){case 0:return r.next=2,e.e(6536).then(e.bind(e,96536));case 2:return r.abrupt("return",(p=r.sent).default.apply(p,l));case 3:case"end":return r.stop()}},I)}));function v(){return g.apply(this,arguments)}return v}()}},"docs-guide-intl-demo-intl-with-builtin":{component:u.memo(u.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,54186))})),asset:{type:"BLOCK",id:"docs-guide-intl-demo-intl-with-builtin",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(43991).Z},"@ant-design/web3":{type:"NPM",value:"1.23.0"}},entry:"index.tsx",title:"Built-in language"},context:{"@ant-design/web3":w},renderOpts:{compile:function(){var g=f()(t()().mark(function I(){var p,l=arguments;return t()().wrap(function(r){for(;;)switch(r.prev=r.next){case 0:return r.next=2,e.e(6536).then(e.bind(e,96536));case 2:return r.abrupt("return",(p=r.sent).default.apply(p,l));case 3:case"end":return r.stop()}},I)}));function v(){return g.apply(this,arguments)}return v}()}}}},61074:function(d,a,e){var n;e.r(a),e.d(a,{demos:function(){return x}});var t=e(90228),o=e.n(t),f=e(87999),u=e.n(f),i=e(1735),w=e(36363),_=e(96229),g=e(52889),v=e(24487),I=e(38605),p=e(50515),l=e(54741),c=e(41211),r=e(45135),s=e(74330),m=e(34557),y=e(66279),x={"docs-guide-payment-in-usdt-demo-usdt":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,88153))})),asset:{type:"BLOCK",id:"docs-guide-payment-in-usdt-demo-usdt",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(2450).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},antd:{type:"NPM",value:"5.22.7"},"./constants/tokenPayAddress.ts":{type:"FILE",value:e(20428).Z},"./components/select.tsx":{type:"FILE",value:e(65680).Z},"./components/pay-button.tsx":{type:"FILE",value:e(89713).Z},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ant-design/web3-wagmi":{type:"NPM",value:"2.10.3"},wagmi:{type:"NPM",value:"2.14.16"},"./send.tsx":{type:"FILE",value:e(49314).Z},undefined:{type:"NPM"}},entry:"index.tsx"},context:{"./constants/tokenPayAddress.ts":g,"./components/select.tsx":v,"./components/pay-button.tsx":I,"./send.tsx":m,react:n||(n=e.t(i,2)),antd:_,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/best-practice/constants/tokenPayAddress.ts":g,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/best-practice/components/select.tsx":v,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/best-practice/components/pay-button.tsx":I,"@ant-design/web3":p,"@ant-design/web3-wagmi":l,wagmi:c,"wagmi/chains":r,"wagmi/connectors":s,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/best-practice/components/send.tsx":m,viem:y},renderOpts:{compile:function(){var h=u()(o()().mark(function P(){var D,C=arguments;return o()().wrap(function(b){for(;;)switch(b.prev=b.next){case 0:return b.next=2,e.e(6536).then(e.bind(e,96536));case 2:return b.abrupt("return",(D=b.sent).default.apply(D,C));case 3:case"end":return b.stop()}},P)}));function M(){return h.apply(this,arguments)}return M}()}}}},22085:function(d,a,e){e.r(a),e.d(a,{demos:function(){return g}});var n=e(90228),t=e.n(n),o=e(87999),f=e.n(o),u=e(1735),i=e(79235),w=e(50515),_=e(54741),g={"docs-guide-quick-start-demo-0":{component:u.memo(u.lazy(f()(t()().mark(function v(){var I,p;return t()().wrap(function(c){for(;;)switch(c.prev=c.next){case 0:return c.next=2,Promise.resolve().then(e.bind(e,50515));case 2:return I=c.sent,p=I.Address,c.abrupt("return",{default:function(){return u.createElement(p,{ellipsis:!0,tooltip:!0,address:"0x21CDf0974d53a6e96eF05d7B324a9803735fFd3B"})}});case 5:case"end":return c.stop()}},v)})))),asset:{type:"BLOCK",id:"docs-guide-quick-start-demo-0",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:`import { Address } from '@ant-design/web3';

export default () => {
  return <Address ellipsis tooltip address="0x21CDf0974d53a6e96eF05d7B324a9803735fFd3B" />;
};`},"@ant-design/web3":{type:"NPM",value:"1.23.0"}},entry:"index.tsx"},context:{"@ant-design/web3":w},renderOpts:{compile:function(){var v=f()(t()().mark(function p(){var l,c=arguments;return t()().wrap(function(s){for(;;)switch(s.prev=s.next){case 0:return s.next=2,e.e(6536).then(e.bind(e,96536));case 2:return s.abrupt("return",(l=s.sent).default.apply(l,c));case 3:case"end":return s.stop()}},p)}));function I(){return v.apply(this,arguments)}return I}()}},"docs-guide-quick-start-demo-quick-start":{component:u.memo(u.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,69802))})),asset:{type:"BLOCK",id:"docs-guide-quick-start-demo-quick-start",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(58979).Z},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ant-design/web3-wagmi":{type:"NPM",value:"2.10.3"}},entry:"index.tsx"},context:{"@ant-design/web3":w,"@ant-design/web3-wagmi":_},renderOpts:{compile:function(){var v=f()(t()().mark(function p(){var l,c=arguments;return t()().wrap(function(s){for(;;)switch(s.prev=s.next){case 0:return s.next=2,e.e(6536).then(e.bind(e,96536));case 2:return s.abrupt("return",(l=s.sent).default.apply(l,c));case 3:case"end":return s.stop()}},p)}));function I(){return v.apply(this,arguments)}return I}()}}}},12903:function(d,a,e){var n;e.r(a),e.d(a,{demos:function(){return p}});var t=e(90228),o=e.n(t),f=e(87999),u=e.n(f),i=e(1735),w=e(94786),_=e(50515),g=e(83468),v=e(96229),I=e(51148),p={"docs-guide-theme-demo-theme":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,38926))})),asset:{type:"BLOCK",id:"docs-guide-theme-demo-theme",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(46228).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ant-design/web3-assets":{type:"NPM",value:"1.12.1"},antd:{type:"NPM",value:"5.22.7"}},entry:"index.tsx"},context:{react:n||(n=e.t(i,2)),"@ant-design/web3":_,"@ant-design/web3-assets":g,antd:v},renderOpts:{compile:function(){var l=u()(o()().mark(function r(){var s,m=arguments;return o()().wrap(function(x){for(;;)switch(x.prev=x.next){case 0:return x.next=2,e.e(6536).then(e.bind(e,96536));case 2:return x.abrupt("return",(s=x.sent).default.apply(s,m));case 3:case"end":return x.stop()}},r)}));function c(){return l.apply(this,arguments)}return c}()}},"docs-guide-theme-demo-custom-token":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,13953))})),asset:{type:"BLOCK",id:"docs-guide-theme-demo-custom-token",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(48747).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ant-design/web3-assets":{type:"NPM",value:"1.12.1"},antd:{type:"NPM",value:"5.22.7"},"./tokens.ts":{type:"FILE",value:e(16697).Z}},entry:"index.tsx"},context:{"./tokens.ts":I,react:n||(n=e.t(i,2)),"@ant-design/web3":_,"@ant-design/web3-assets":g,antd:v,"/home/runner/work/ant-design-web3/ant-design-web3/docs/guide/demos/tokens.ts":I},renderOpts:{compile:function(){var l=u()(o()().mark(function r(){var s,m=arguments;return o()().wrap(function(x){for(;;)switch(x.prev=x.next){case 0:return x.next=2,e.e(6536).then(e.bind(e,96536));case 2:return x.abrupt("return",(s=x.sent).default.apply(s,m));case 3:case"end":return x.stop()}},r)}));function c(){return l.apply(this,arguments)}return c}()}},"docs-guide-theme-demo-custom-token-web3":{component:i.memo(i.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,75028))})),asset:{type:"BLOCK",id:"docs-guide-theme-demo-custom-token-web3",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(5787).Z},react:{type:"NPM",value:"18.3.0-canary-c3048aab4-20240326"},"@ant-design/web3":{type:"NPM",value:"1.23.0"},"@ant-design/web3-assets":{type:"NPM",value:"1.12.1"},antd:{type:"NPM",value:"5.22.7"}},entry:"index.tsx"},context:{react:n||(n=e.t(i,2)),"@ant-design/web3":_,"@ant-design/web3-assets":g,antd:v},renderOpts:{compile:function(){var l=u()(o()().mark(function r(){var s,m=arguments;return o()().wrap(function(x){for(;;)switch(x.prev=x.next){case 0:return x.next=2,e.e(6536).then(e.bind(e,96536));case 2:return x.abrupt("return",(s=x.sent).default.apply(s,m));case 3:case"end":return x.stop()}},r)}));function c(){return l.apply(this,arguments)}return c}()}}}},95350:function(d,a,e){e.r(a),e.d(a,{demos:function(){return o}});var n=e(1735),t=e(27119),o={"docs-meetup-2024-demo-dapp":{component:n.memo(n.lazy(function(){return Promise.all([e.e(8008),e.e(3942),e.e(4522),e.e(2433)]).then(e.bind(e,53643))})),asset:null,context:void 0,renderOpts:void 0}}},80588:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(50163);const t=[{value:"Interacting with blockchain contracts is one of the core functionalities of a DApp. Achieving this is not difficult, but it does require writing some logic. In this example, we will demonstrate how to connect to the Solana network using Ant Design Web3 and call the Memo contract.",paraId:0,tocIndex:0},{value:"The Memo Program is a sample program on Solana, which is a simple contract used to add note information to transactions. You can find its documentation here: ",paraId:1,tocIndex:0},{value:"Memo Program | Solana Program Library Docs",paraId:1,tocIndex:0},{value:".",paraId:1,tocIndex:0},{value:"We will demonstrate how to interact with Solana contracts in two ways:",paraId:2,tocIndex:0},{value:"Directly calling the contract without using a wallet",paraId:3,tocIndex:0},{value:"Calling the contract using a wallet",paraId:3,tocIndex:0},{value:"Regardless of the method used, we need to use ",paraId:4,tocIndex:0},{value:"@solana/web3.js",paraId:4,tocIndex:0},{value:", an official JavaScript library provided by Solana for interacting with the Solana blockchain. Here, we use version 1.x, which is simpler compared to the latest version and sufficient for our example.",paraId:4,tocIndex:0},{value:"Directly calling the contract means signing transactions using a private key without a wallet. This method is suitable for simple scenarios, such as debugging on the test network.",paraId:5,tocIndex:1},{value:"In the above code, we did not use any content from ",paraId:6},{value:"@ant-design/web3-solana",paraId:6},{value:"; the actual call is made in the ",paraId:6},{value:"writeMemo",paraId:6},{value:" function.",paraId:6},{value:"In it, we first generate a keypair using Keypair, which includes a public key and a private key. Since we haven't interacted with it, it's just a set of values without any actual significance.",paraId:7},{value:"You can comment out the code that generates the keypair in ",paraId:8},{value:"writeMemo",paraId:8},{value:" and check the generated public key in the browser console. You can also view this public key information on a blockchain explorer, or check the following address: ",paraId:8},{value:"61QgmBmUw1Nekq7wGXtA7CCETUcbmTBJPjDWGLSrPqRK",paraId:8},{value:"You will find that the displayed data on the page does not show any anomalies because it is indeed a legitimate public key located on the elliptic curve.",paraId:9},{value:"Continuing, since the newly generated keypair does not have any balance, we need to obtain some test tokens from the faucet on the testnet. Here, we use the ",paraId:10},{value:"requestAirdrop",paraId:10},{value:" method to send some test tokens to the specified address.",paraId:10},{value:"Next, we use the ",paraId:11},{value:"confirmTransaction",paraId:11},{value:" method to confirm whether the transaction was successful. If successful, we can call the Memo contract.",paraId:11},{value:"Requesting test tokens and confirming the transaction is not mandatory; you can use your existing account as long as it has enough balance to run our example code.",paraId:12},{value:"\u{1F6D1} Note: Please do not enter your private key on any website casually!!!",paraId:13},{value:"Once we ensure that the account we just created has enough balance, we can call the Memo contract.",paraId:14},{value:"In Solana, a transaction can contain one or more instructions, each being a contract call. We can create a transaction with just a memo instruction, but to make it somewhat interesting, let's try executing two instructions in one transaction: a transfer and writing a memo.",paraId:15},{value:"Continuing, we create a transfer instruction using the ",paraId:16},{value:"transfer",paraId:16},{value:" method from ",paraId:16},{value:"SystemProgram",paraId:16},{value:" and assign it to ",paraId:16},{value:"transferInstruction",paraId:16},{value:". Then, we create a transaction instruction object pointing to the Memo contract and assign it to ",paraId:16},{value:"memoInstruction",paraId:16},{value:".",paraId:16},{value:"Then, we create a ",paraId:17},{value:"Transaction",paraId:17},{value:" object and add these two instructions to the transaction.",paraId:17},{value:"When creating the transfer instruction, we use the ",paraId:18},{value:"SystemProgram.transfer",paraId:18},{value:" method. Since transfers are done using Solana's built-in contracts and are very common, @solana/web3.js provides a method for convenient calls. When using transfer, we need to provide the sender's address, recipient's address, and transfer amount.",paraId:18},{value:"When creating the memo instruction, since @solana/web3.js does not provide a corresponding function, we manually construct the transfer instruction object. We need to specify the address of the contract being called (Memo) (",paraId:19},{value:"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr",paraId:19},{value:"), the public keys involved in this instruction, and the data to be passed (here, a string converted to a Buffer). Note: Participant accounts must be signers of the transaction, so ",paraId:19},{value:"isSigner",paraId:19},{value:" is set to ",paraId:19},{value:"true",paraId:19},{value:". Detailed documentation can be found here: ",paraId:19},{value:"https://spl.solana.com/memo#operational-notes",paraId:19},{value:"Finally, we use the ",paraId:20},{value:"sendAndConfirmTransaction",paraId:20},{value:" method to send the transaction. This method sends the transaction to the network and waits for confirmation. Note that when we call it, we pass the keypair to sign the transaction with the private key.",paraId:20},{value:"If the transaction succeeds, it returns a TransactionSignature object, which is essentially a string representing the transaction's hash. We can use it to view the transaction details on a blockchain explorer.",paraId:21},{value:"Let's click the [Send] button, run the code, and see the effect!",paraId:22},{value:"If everything is successful, you'll see the transaction hash value output in the console, indicating that the transaction has been successfully sent to the network. You can view the transaction details on the ",paraId:23},{value:"Solana Blockchain Explorer",paraId:23},{value:".",paraId:23},{value:"If something fails, it might be due to using the RPC too many times, triggering rate limiting. You can register for a new RPC address ",paraId:24},{value:"here",paraId:24},{value:" and replace it, or try again after some time.",paraId:24},{value:"In dApp development, we typically use a wallet to manage the user's keypair. This approach is more secure and convenient, as users can sign transactions through the wallet instead of exposing their private keys to the dApp.",paraId:25,tocIndex:2},{value:"Compared to the code for directly calling contracts in the first section, this code is slightly reduced, removing steps such as generating a keypair and requesting test tokens. Instead, we directly use the keypair in the wallet to sign the transaction.",paraId:26},{value:"The transaction processing logic is in ",paraId:27},{value:"writeMemo",paraId:27},{value:", similar to before. It creates a transfer instruction and a memo instruction and adds them to the transaction.",paraId:27},{value:"The difference is that we use the ",paraId:28},{value:"useWallet",paraId:28},{value:" hook to obtain the ",paraId:28},{value:"sendTransaction",paraId:28},{value:" method provided by the wallet. This method sends the transaction to the network and waits for confirmation. Note that we do not pass the keypair when calling it.",paraId:28},{value:"In the above two examples, we manually constructed ",paraId:29,tocIndex:3},{value:"TransactionInstruction",paraId:29,tocIndex:3},{value:" objects when creating Memo instructions. While this approach offers flexibility, it also increases the workload. If you prefer a simpler method, you can use the ",paraId:29,tocIndex:3},{value:"createMemoInstruction",paraId:29,tocIndex:3},{value:" method provided by ",paraId:29,tocIndex:3},{value:"@solana/spl-memo",paraId:29,tocIndex:3},{value:". The specific code can be found here: ",paraId:29,tocIndex:3},{value:"@solana/spl-memo",paraId:29,tocIndex:3},{value:".",paraId:29,tocIndex:3}]},11453:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(18087);const t=[{value:"After completing the Ant Design Web3 Introductory course, students interested in DApp development can continue to learn more in-depth.",paraId:0,tocIndex:0},{value:"You can find more courses at ",paraId:1,tocIndex:0},{value:"WTF Academy",paraId:1,tocIndex:0},{value:", e.g. if you want to learn how to develop Solidity contracts, you can take the ",paraId:1,tocIndex:0},{value:"Introduction to Solidity Course",paraId:1,tocIndex:0},{value:".",paraId:1,tocIndex:0},{value:"We're also working on an advanced ",paraId:2,tocIndex:0},{value:"DApp course",paraId:2,tocIndex:0},{value:" with ",paraId:2,tocIndex:0},{value:"WTF Academy",paraId:2,tocIndex:0},{value:", so keep an eye out for that as well.",paraId:2,tocIndex:0}]},58998:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(63242);const t=[{value:"Click the ",paraId:0,tocIndex:1},{value:"Solidity Compiler",paraId:0,tocIndex:1},{value:" icon in the icon panel to enter the compiler interface. The interface displays the basic configuration items of the compiler by default. Click the ",paraId:0,tocIndex:1},{value:"Advanced Configurations",paraId:0,tocIndex:1},{value:" button to open the advanced configuration panel. In the ",paraId:0,tocIndex:1},{value:"Advanced Configurations",paraId:0,tocIndex:1},{value:" menu, you can change the EVM version, enable the optimization function, and set the number of times the bytecode is expected to run during the contract lifecycle (default setting is 200 times). For more information about contract optimization, see ",paraId:0,tocIndex:1},{value:"Solidity documentation on Optimizer",paraId:0,tocIndex:1},{value:".",paraId:0,tocIndex:1},{value:"Open a file in the ",paraId:1,tocIndex:1},{value:"File explorer",paraId:1,tocIndex:1},{value:" to compile. If multiple files are opened, make sure that the file you want to compile is selected in the editor.",paraId:1,tocIndex:1},{value:"There are three cases that trigger compilation:",paraId:2,tocIndex:1},{value:"Use the shortcut key ",paraId:3,tocIndex:1},{value:"control/command + s",paraId:3,tocIndex:1},{value:"Right-click the file in the ",paraId:3,tocIndex:1},{value:"File explorer",paraId:3,tocIndex:1},{value:" and select the compilation option",paraId:3,tocIndex:1},{value:"Click the ",paraId:3,tocIndex:1},{value:"Compile",paraId:3,tocIndex:1},{value:" button",paraId:3,tocIndex:1},{value:"When the compilation is completed, there will be a green completion mark next to the ",paraId:4,tocIndex:1},{value:"Solidity Compiler",paraId:4,tocIndex:1},{value:" icon, just like the one in the picture above. And ",paraId:4,tocIndex:1},{value:"Remix",paraId:4,tocIndex:1},{value:" will create three JSON files for each compiled contract. These files can be seen in the ",paraId:4,tocIndex:1},{value:"File explorer",paraId:4,tocIndex:1},{value:" plugin:",paraId:4,tocIndex:1},{value:"artifacts/<contractName>.json",paraId:5,tocIndex:1},{value:": Contains the link of ",paraId:5,tocIndex:1},{value:"libraries",paraId:5,tocIndex:1},{value:", ",paraId:5,tocIndex:1},{value:"bytecode",paraId:5,tocIndex:1},{value:", ",paraId:5,tocIndex:1},{value:"deployedBytecode",paraId:5,tocIndex:1},{value:", ",paraId:5,tocIndex:1},{value:"gas estimation",paraId:5,tocIndex:1},{value:", ",paraId:5,tocIndex:1},{value:"identifiers",paraId:5,tocIndex:1},{value:" and ",paraId:5,tocIndex:1},{value:"ABI",paraId:5,tocIndex:1},{value:". It is used to associate the library address with the file.",paraId:5,tocIndex:1},{value:"artifacts/<contractName_metadata>.json",paraId:5,tocIndex:1},{value:": Contains the metadata output by ",paraId:5,tocIndex:1},{value:"Solidity",paraId:5,tocIndex:1},{value:" compilation.",paraId:5,tocIndex:1},{value:"artifacts/build-info/<dynamic_hash>.json",paraId:5,tocIndex:1},{value:": Contains information about ",paraId:5,tocIndex:1},{value:"solc",paraId:5,tocIndex:1},{value:" compiler version, compiler input and output.",paraId:5,tocIndex:1},{value:"Just like the picture below:",paraId:6,tocIndex:1},{value:"ABI",paraId:7,tocIndex:1},{value:" is a JSON array that describes the contract interface.",paraId:7,tocIndex:1},{value:"Click ",paraId:8,tocIndex:1},{value:"ABI",paraId:8,tocIndex:1},{value:" to copy and export:",paraId:8,tocIndex:1},{value:"Click ",paraId:9,tocIndex:2},{value:"Deploy&Run",paraId:9,tocIndex:2},{value:" to send the transaction to the current ",paraId:9,tocIndex:2},{value:"ENVIRONMENT",paraId:9,tocIndex:2},{value:". Deploying contracts consumes GAS, even on the test network. GAS is paid with ETH from the test network, so you also need to obtain some ETH from the test network through the faucet. For example, you can get Sepolia test network ETH through the ",paraId:9,tocIndex:2},{value:"ZAN test network faucet",paraId:9,tocIndex:2},{value:".",paraId:9,tocIndex:2},{value:"Next, we will try to deploy the contract to the Sepolia testnet through MetaMask. Please switch your MetaMask to the Sepolia testnet (of course, you can also switch to other testnets you are used to using).",paraId:10,tocIndex:2},{value:"Click the drop-down box of ",paraId:11,tocIndex:2},{value:"ENVIRONMENT",paraId:11,tocIndex:2},{value:", you can see many options to choose from, we choose ",paraId:11,tocIndex:2},{value:"Injected Provider - MetaMask",paraId:11,tocIndex:2},{value:".",paraId:11,tocIndex:2},{value:"Then, ",paraId:12,tocIndex:2},{value:"MetaMask",paraId:12,tocIndex:2},{value:" will pop up a window and prompt to connect it to ",paraId:12,tocIndex:2},{value:"Remix",paraId:12,tocIndex:2},{value:". After connecting ",paraId:12,tocIndex:2},{value:"MetaMask",paraId:12,tocIndex:2},{value:" to ",paraId:12,tocIndex:2},{value:"Remix",paraId:12,tocIndex:2},{value:", the side panel will be updated to display the connected network and account. Deploying to the testnet also requires testnet tokens. You can find the corresponding testnet token faucet on the network for recharging.",paraId:12,tocIndex:2},{value:"Now, the wallet connection is complete, and you can start deploying the contract. Since a simple ",paraId:13,tocIndex:2},{value:"ERC721",paraId:13,tocIndex:2},{value:" smart contract is being deployed, the default ",paraId:13,tocIndex:2},{value:"Gas Limit",paraId:13,tocIndex:2},{value:" set by ",paraId:13,tocIndex:2},{value:"Remix",paraId:13,tocIndex:2},{value:" is 3 million, which is enough, and there is no need to specify the value sent with the deployment. For this, you can perform the following steps to deploy the contract:",paraId:13,tocIndex:2},{value:"Make sure that ",paraId:14,tocIndex:2},{value:"ENVIRONMENT",paraId:14,tocIndex:2},{value:" is set to ",paraId:14,tocIndex:2},{value:"Injected Provider - MetaMask",paraId:14,tocIndex:2},{value:"Make sure the connected account is the account you want to deploy",paraId:14,tocIndex:2},{value:"Use the default ",paraId:14,tocIndex:2},{value:"GAS LIMIT: 3000000",paraId:14,tocIndex:2},{value:"No need to adjust the set ",paraId:14,tocIndex:2},{value:"VALUE: 0",paraId:14,tocIndex:2},{value:"Make sure the selected contract is ",paraId:14,tocIndex:2},{value:"MyToken.sol",paraId:14,tocIndex:2},{value:"Click ",paraId:14,tocIndex:2},{value:"Deploy",paraId:14,tocIndex:2},{value:"Click ",paraId:14,tocIndex:2},{value:"transact",paraId:14,tocIndex:2},{value:" to send the deployment transaction",paraId:14,tocIndex:2},{value:"MetaMask",paraId:14,tocIndex:2},{value:" will pop up a window, click to confirm the deployment of the contract",paraId:14,tocIndex:2},{value:"After the transaction is deployed, you will see the details of the deployment transaction in the ",paraId:15,tocIndex:2},{value:"Remix",paraId:15,tocIndex:2},{value:" terminal. In addition, the contract will appear below the ",paraId:15,tocIndex:2},{value:"Deployed Contracts",paraId:15,tocIndex:2},{value:" section of the side panel. It is collapsed by default and can be expanded by clicking the small arrow.",paraId:15,tocIndex:2},{value:"You can try to expand it and then call ",paraId:16,tocIndex:2},{value:"mint",paraId:16,tocIndex:2},{value:", as shown in the figure below:",paraId:16,tocIndex:2},{value:"The call here will also trigger the MetaMask transaction confirmation pop-up window. After clicking confirm, you can initiate a transaction, which is the same as the process of initiating a transaction in DApp.",paraId:17,tocIndex:2},{value:"So far, we have successfully deployed a contract on the testnet. Next, we will try to call this contract in the DApp developed in the previous chapter.",paraId:18,tocIndex:2}]},10657:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(11618);const t=[{value:"In this section, we will integrate the DApp developed in Chapter 2 with the contract deployed in this chapter to complete a complete DApp development task.",paraId:0,tocIndex:0},{value:"In the DApp developed in the previous chapter, there is already a page that can call the contract. We only need to fill in the address of this contract in the DApp to call this contract.",paraId:1,tocIndex:1},{value:"In addition to the address, we also need to switch to the testnet. The specific code is as follows:",paraId:2,tocIndex:1},{value:`import { http, useReadContract, useWriteContract } from "wagmi";
import {
  WagmiWeb3ConfigProvider,
  MetaMask,
+  Mainnet,
+  Sepolia,
} from "@ant-design/web3-wagmi";
import {
  Address,
  NFTCard,
  Connector,
  ConnectButton,
  useAccount,
} from "@ant-design/web3";
import { injected } from "wagmi/connectors";
import { Button, message } from "antd";
import { parseEther } from "viem";

- const CONTRACT_ADDRESS = "0xEcd0D12E21805803f70de03B72B1C162dB0898d9";
+ const CONTRACT_ADDRESS = "0x81BaD6F768947D7741c83d9EB9007e1569115703"; // use your own contract address

const CallTest = () => {
  const { account } = useAccount();
  const result = useReadContract({
    abi: [
      {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [{ name: "account", type: "address" }],
        outputs: [{ type: "uint256" }],
      },
    ],
    address: CONTRACT_ADDRESS,
    functionName: "balanceOf",
    args: [account?.address as \`0x\${string}\`],
  });
  const { data: hash, writeContract } = useWriteContract();
  const { isLoading: isConfirming, isSuccess: isConfirmed } =
    useWaitForTransactionReceipt({
      hash,
    });

  useEffect(() => {
    if (isConfirmed) {
      message.success("Mint Success");
      result.refetch();
    }
  }, [isConfirmed]);

  return (
    <div>
      {result.data?.toString()}
      <Button
        loading={isConfirming}
        onClick={() => {
          writeContract(
            {
              abi: [
                {
                  type: "function",
                  name: "mint",
                  stateMutability: "payable",
                  inputs: [
                    {
                      internalType: "uint256",
                      name: "quantity",
                      type: "uint256",
                    },
                  ],
                  outputs: [],
                },
              ],
              address: CONTRACT_ADDRESS,
              functionName: "mint",
              args: [BigInt(1)],
              value: parseEther("0.01"),
            },
            {
              onError: (err) => {
                message.error(err.message);
              },
            }
          );
        }}
      >
        mint
      </Button>
    </div>
  );
};

export default function Web3() {
  return (
    <WagmiWeb3ConfigProvider
       eip6963={{
         autoAddInjectedWallets: true,
       }}
+      chains={[Mainnet, Sepolia]}
       transports={{
         [Mainnet.id]: http(),
+        [Sepolia.id]: http(),
      }}
      wallets={[MetaMask()]}
    >
      <Address format address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" />
      <NFTCard
        address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9"
        tokenId={641}
      />
      <Connector>
        <ConnectButton />
      </Connector>
      <CallTest />
    </WagmiWeb3ConfigProvider>
  );
};

`,paraId:3,tocIndex:1},{value:"Switch to the Sepolia testnet in the DApp page, and if you click the ",paraId:4,tocIndex:1},{value:"mint",paraId:4,tocIndex:1},{value:" button, the MetaMask transaction confirmation pop-up window will be triggered if everything goes well:",paraId:4,tocIndex:1},{value:"After the transaction is online, and you will find that the previous ",paraId:5,tocIndex:1},{value:"balanceOf",paraId:5,tocIndex:1},{value:" result has become ",paraId:5,tocIndex:1},{value:"1",paraId:5,tocIndex:1},{value:", which means that you have successfully minted an NFT. Of course, a truly good DApp will add events to the smart contract, listen to contract events on the front end, and then automatically update the results. But we will not introduce the event part in this introductory course.",paraId:5,tocIndex:1},{value:"The following is the complete example of the course:",paraId:6,tocIndex:2},{value:"You can also refer to the GitHub project source code ",paraId:7},{value:"https://github.com/ant-design/ant-design-web3-demo",paraId:7},{value:".",paraId:7},{value:"So far, we have completed all the content of this course, I hope you can learn something from it, thank you all! \u{1F389}",paraId:8}]},22288:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(13697);const t=[{value:"In the ",paraId:0,tocIndex:1},{value:"previous article",paraId:1,tocIndex:1},{value:" we created a base contract for ",paraId:0,tocIndex:1},{value:"ERC721",paraId:0,tocIndex:1},{value:" with ",paraId:0,tocIndex:1},{value:"Mint",paraId:0,tocIndex:1},{value:" functionality, so let's move on to writing and compiling the contract.",paraId:0,tocIndex:1},{value:"In the following code we simply implement a new ",paraId:2,tocIndex:1},{value:"mint",paraId:2,tocIndex:1},{value:" method to replace the ",paraId:2,tocIndex:1},{value:"safeMint",paraId:2,tocIndex:1},{value:" generated by default. The new ",paraId:2,tocIndex:1},{value:"mint",paraId:2,tocIndex:1},{value:" method maintains the same interface as the method we used in the previous chapter so that we can replace the course's contract with the new one once we have deployed the contract.",paraId:2,tocIndex:1},{value:"Specifically to be modified within there:",paraId:3,tocIndex:1},{value:"set ",paraId:4,tocIndex:1},{value:"initialOwner",paraId:4,tocIndex:1},{value:" to be the contract issuer so that it is simpler to deploy the contract without having to specify ",paraId:4,tocIndex:1},{value:"initialOwner",paraId:4,tocIndex:1},{value:".",paraId:4,tocIndex:1},{value:"define a contract private variable ",paraId:4,tocIndex:1},{value:"private",paraId:4,tocIndex:1},{value:" named ",paraId:4,tocIndex:1},{value:"_nextTokenId",paraId:4,tocIndex:1},{value:" of type ",paraId:4,tocIndex:1},{value:"uint256",paraId:4,tocIndex:1},{value:" to mark the current progress, and add one to the value for each new NFT. 1. set ",paraId:4,tocIndex:1},{value:"mint",paraId:4,tocIndex:1},{value:" as the contract issuer so that it will be easier to deploy contracts without specifying ",paraId:4,tocIndex:1},{value:"initialOwner",paraId:4,tocIndex:1},{value:";",paraId:4,tocIndex:1},{value:"quantity",paraId:4,tocIndex:1},{value:" of type ",paraId:4,tocIndex:1},{value:"uint256",paraId:4,tocIndex:1},{value:" is required to be passed in ",paraId:4,tocIndex:1},{value:"mint",paraId:4,tocIndex:1},{value:" method to represent how many NFTs are to be minted this time, here we simplify the logic by limiting the minting to one at a time.",paraId:4,tocIndex:1},{value:"remove the ",paraId:4,tocIndex:1},{value:"onlyOwner",paraId:4,tocIndex:1},{value:" modifier so that anyone can call the ",paraId:4,tocIndex:1},{value:"mint",paraId:4,tocIndex:1},{value:" method. 2. add the ",paraId:4,tocIndex:1},{value:"payable",paraId:4,tocIndex:1},{value:" modifier so that anyone can call the ",paraId:4,tocIndex:1},{value:"mint",paraId:4,tocIndex:1},{value:" method.",paraId:4,tocIndex:1},{value:"add the ",paraId:4,tocIndex:1},{value:"payable",paraId:4,tocIndex:1},{value:" qualifier so that anyone calling the ",paraId:4,tocIndex:1},{value:"mint",paraId:4,tocIndex:1},{value:" method can transfer money to the contract at the same time.",paraId:4,tocIndex:1},{value:"_safeMint",paraId:4,tocIndex:1},{value:" should also be changed to ",paraId:4,tocIndex:1},{value:"_mint",paraId:4,tocIndex:1},{value:", mainly to avoid errors when testing the contract by calling it from a Remix contract later on, and ",paraId:4,tocIndex:1},{value:"to",paraId:4,tocIndex:1},{value:" should be changed to ",paraId:4,tocIndex:1},{value:"msg.sender",paraId:4,tocIndex:1},{value:", which stands for the address that the NFT is casting to for initiating the transaction.",paraId:4,tocIndex:1},{value:"The code is as follows\uFF1A",paraId:5,tocIndex:1},{value:`// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyToken is ERC721, Ownable {
+    uint256 private _nextTokenId = 0;

-    constructor(address initialOwner)
+    constructor()
        ERC721("MyToken", "MTK")
-        Ownable(initialOwner)
+        Ownable(msg.sender)
    {}

-    function safeMint(address to, uint256 tokenId) public onlyOwner {
+    function mint(uint256 quantity) public payable {
+        require(quantity == 1, "quantity must be 1");
+        require(msg.value == 0.01 ether, "must pay 0.01 ether");
+        uint256 tokenId = _nextTokenId++;
-        _safeMint(to, tokenId);
+        _mint(msg.sender, tokenId);
    }
}
`,paraId:6,tocIndex:1},{value:"Private",paraId:7,tocIndex:1},{value:" refers to methods and variables that can only be called in the pre-deployment contract, while ",paraId:7,tocIndex:1},{value:"public",paraId:7,tocIndex:1},{value:" methods and variables are accessible to everyone.",paraId:7,tocIndex:1},{value:"Unit Test Plugin",paraId:8,tocIndex:2},{value:"We need to click on the ",paraId:9,tocIndex:2},{value:"Plugin Manager",paraId:9,tocIndex:2},{value:" icon in the bottom left corner of the plugin manager to search for the ",paraId:9,tocIndex:2},{value:"unit",paraId:9,tocIndex:2},{value:" keyword, then the search result ",paraId:9,tocIndex:2},{value:"SOLIDITY UNIT TESTING",paraId:9,tocIndex:2},{value:" will appear, click on ",paraId:9,tocIndex:2},{value:"Activate",paraId:9,tocIndex:2},{value:" to install and activate the plugin, as shown in the figure below:",paraId:9,tocIndex:2},{value:"The ",paraId:10,tocIndex:2},{value:"Solidity unit testing",paraId:10,tocIndex:2},{value:" icon will then appear in the left icon bar and clicking on it will load the plugin in the side panel.",paraId:10,tocIndex:2},{value:"After successful loading, the plugin should look like this:",paraId:11,tocIndex:2},{value:"Unit test documentation",paraId:12,tocIndex:2},{value:"Remix injects a built-in assert library that can be used for testing. You can see the documentation of the library ",paraId:13,tocIndex:2},{value:"here",paraId:13,tocIndex:2},{value:".",paraId:13,tocIndex:2},{value:`
In addition to this, Remix allows some special functions to be used in the test file to make the tests more structured. They are:`,paraId:13,tocIndex:2},{value:"beforeEach()",paraId:14,tocIndex:2},{value:" - Run before each test",paraId:14,tocIndex:2},{value:"beforeAll()",paraId:14,tocIndex:2},{value:" - Run before all tests",paraId:14,tocIndex:2},{value:"afterEach()",paraId:14,tocIndex:2},{value:" - Run after each test",paraId:14,tocIndex:2},{value:"afterAll()",paraId:14,tocIndex:2},{value:" - Run after all the tests",paraId:14,tocIndex:2},{value:"Our unit test file, in the directory ",paraId:15,tocIndex:2},{value:"tests/MyToken_test.sol",paraId:15,tocIndex:2},{value:", is there because the template contract we chose automatically created the test contract for us. If we had created a new blank folder, then we would need to click through the ",paraId:15,tocIndex:2},{value:"Generate",paraId:15,tocIndex:2},{value:" button to generate the test file, as shown below:",paraId:15,tocIndex:2},{value:"Then we click on our test file ",paraId:16,tocIndex:2},{value:"tests/MyToken_test.sol",paraId:16,tocIndex:2},{value:" in ",paraId:16,tocIndex:2},{value:"File explorer",paraId:16,tocIndex:2},{value:" and write the following test:",paraId:16,tocIndex:2},{value:"remix_tests.sol",paraId:17,tocIndex:2},{value:" is automatically injected by ",paraId:17,tocIndex:2},{value:"Remix",paraId:17,tocIndex:2},{value:";",paraId:17,tocIndex:2},{value:"remix_accounts.sol",paraId:17,tocIndex:2},{value:" generates the list of test account addresses for us;",paraId:17,tocIndex:2},{value:"../contracts/MyToken.sol",paraId:17,tocIndex:2},{value:" introduces the contract file we have written;",paraId:17,tocIndex:2},{value:"instantiated our contract ",paraId:17,tocIndex:2},{value:"MyToken",paraId:17,tocIndex:2},{value:" defined as ",paraId:17,tocIndex:2},{value:"s",paraId:17,tocIndex:2},{value:" in ",paraId:17,tocIndex:2},{value:"beforeAll()",paraId:17,tocIndex:2},{value:" and took a test address and saved it ",paraId:17,tocIndex:2},{value:"TestsAccounts.getAccount(0)",paraId:17,tocIndex:2},{value:" defined as ",paraId:17,tocIndex:2},{value:"acc0",paraId:17,tocIndex:2},{value:";",paraId:17,tocIndex:2},{value:"verify in ",paraId:17,tocIndex:2},{value:"testTokenNameAndSymbol()",paraId:17,tocIndex:2},{value:" that the instantiated contract ",paraId:17,tocIndex:2},{value:"name()",paraId:17,tocIndex:2},{value:" is going to get the value ",paraId:17,tocIndex:2},{value:"MyToken",paraId:17,tocIndex:2},{value:" and ",paraId:17,tocIndex:2},{value:"symbol()",paraId:17,tocIndex:2},{value:" the value of ",paraId:17,tocIndex:2},{value:"MTK",paraId:17,tocIndex:2},{value:";",paraId:17,tocIndex:2},{value:"Write a function ",paraId:17,tocIndex:2},{value:"testMint()",paraId:17,tocIndex:2},{value:" that calls our ",paraId:17,tocIndex:2},{value:"mint(1)",paraId:17,tocIndex:2},{value:" method, and the value of ",paraId:17,tocIndex:2},{value:"balanceOf()",paraId:17,tocIndex:2},{value:" cast once should be ",paraId:17,tocIndex:2},{value:"1",paraId:17,tocIndex:2},{value:". The code for the ",paraId:17,tocIndex:2},{value:"tests/MyToken_test.sol",paraId:17,tocIndex:2},{value:" is as follows\uFF1A",paraId:17,tocIndex:2},{value:`// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.0 <0.9.0;
import "remix_tests.sol";
import "remix_accounts.sol";
import "../contracts/MyToken.sol";

contract MyTokenTest {
    MyToken s;
    function beforeAll () public {
        s = new MyToken();
    }

    function testTokenNameAndSymbol () public {
        Assert.equal(s.name(), "MyToken", "token name did not match");
        Assert.equal(s.symbol(), "MTK", "token symbol did not match");
    }
    /// #value: 10000000000000000
    function testMint() public payable {
        s.mint{value: msg.value}(1);
        Assert.equal(s.balanceOf(address(this)), 1, "balance did not match");
    }
}
`,paraId:18,tocIndex:2},{value:"Remix's single test is to call the contract we want to test in a contract to test, the details will not be expanded first, you can refer to ",paraId:19,tocIndex:2},{value:"Remix unit test plugin's documentation",paraId:19,tocIndex:2},{value:".",paraId:19,tocIndex:2},{value:"Running Unit Tests",paraId:20,tocIndex:2},{value:"When we have finished writing the test, select the file and click ",paraId:21,tocIndex:2},{value:"Run",paraId:21,tocIndex:2},{value:" to execute the test. The execution will run in a separate environment. After completing the execution of a file, the following test summary will be displayed:",paraId:21,tocIndex:2},{value:"And that's it, unit testing for our contract is done.",paraId:22,tocIndex:2},{value:"Of course, if you're more comfortable testing with Chai and Mocha, ",paraId:23,tocIndex:2},{value:"Remix",paraId:23,tocIndex:2},{value:" is also supported.",paraId:23,tocIndex:2},{value:"Chai is a BDD / TDD assertion library for Node.js and browsers that pairs happily with any JavaScript testing framework.Mocha is a feature-rich JavaScript testing framework that runs on Node.js and browsers, making asynchronous testing easy and fun.",paraId:24,tocIndex:2},{value:"Simply create a ",paraId:25,tocIndex:2},{value:"js",paraId:25,tocIndex:2},{value:" file in your workspace, preferably in the ",paraId:25,tocIndex:2},{value:"scripts",paraId:25,tocIndex:2},{value:" folder. Then right click on the new ",paraId:25,tocIndex:2},{value:"js",paraId:25,tocIndex:2},{value:" file with the test code written in it and click ",paraId:25,tocIndex:2},{value:"Run",paraId:25,tocIndex:2},{value:".",paraId:25,tocIndex:2},{value:`
It will look something like this:`,paraId:25,tocIndex:2},{value:"Click ",paraId:26,tocIndex:2},{value:"Run",paraId:26,tocIndex:2},{value:" and the results will be displayed in the terminal after executing the test.",paraId:26,tocIndex:2},{value:"Here is just an example, providing ways and means by which this can be done, and is fully supported if you are good at this approach.",paraId:27,tocIndex:2},{value:"Next we'll try, ",paraId:28,tocIndex:2},{value:"Compile",paraId:28,tocIndex:2},{value:" and ",paraId:28,tocIndex:2},{value:"Deploy Upstream",paraId:28,tocIndex:2},{value:" the contract file we wrote.",paraId:28,tocIndex:2}]},36070:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(94431);const t=[{value:"In this course, we will use ",paraId:0,tocIndex:1},{value:"Remix",paraId:0,tocIndex:1},{value:" to run the ",paraId:0,tocIndex:1},{value:"Solidity",paraId:0,tocIndex:1},{value:" contract.",paraId:0,tocIndex:1},{value:"Remix",paraId:1,tocIndex:1},{value:" is the official recommended integrated development environment (IDE) for smart contracts on Ethereum. It is suitable for novices. It provides an easy-to-use interface to quickly write, compile and deploy smart contracts in the browser without installing any programs locally.",paraId:1,tocIndex:1},{value:"Solidity",paraId:2,tocIndex:1},{value:" is a high-level programming language created for implementing ",paraId:2,tocIndex:1},{value:"smart contracts",paraId:2,tocIndex:1},{value:". This language is influenced by the ",paraId:2,tocIndex:1},{value:"C++",paraId:2,tocIndex:1},{value:", ",paraId:2,tocIndex:1},{value:"Python",paraId:2,tocIndex:1},{value:" and ",paraId:2,tocIndex:1},{value:"JavaScript",paraId:2,tocIndex:1},{value:" languages, and is designed to run on the Ethereum virtual machine (",paraId:2,tocIndex:1},{value:"EVM",paraId:2,tocIndex:1},{value:"). ",paraId:2,tocIndex:1},{value:"Solidity",paraId:2,tocIndex:1},{value:" is a statically typed language that supports inheritance, libraries, and complex user-defined types.",paraId:2,tocIndex:1},{value:"Enter ",paraId:3,tocIndex:2},{value:"Remix",paraId:3,tocIndex:2},{value:", we can see the interface as shown in the figure below:",paraId:3,tocIndex:2},{value:"As you can see, ",paraId:4,tocIndex:2},{value:"Remix",paraId:4,tocIndex:2},{value:" consists of three panels and a terminal.",paraId:4,tocIndex:2},{value:"Icon panel-click to change the plug-in displayed in the side panel;",paraId:5,tocIndex:2},{value:"Side panel-most of the interfaces of the plug-in (not all plug-ins) are here;",paraId:5,tocIndex:2},{value:"Main panel-used to edit files, large-scale tools and home page tabs;",paraId:5,tocIndex:2},{value:"Terminal-for viewing transaction receipts and various logs.",paraId:5,tocIndex:2},{value:"A brief introduction to the side panel icon function, we will have a more detailed introduction when we use it later. ",paraId:6,tocIndex:3},{value:"Home",paraId:6,tocIndex:3},{value:" can always open the main page, even if it is turned off. ",paraId:6,tocIndex:3},{value:"File explorer",paraId:6,tocIndex:3},{value:" is used to manage workspaces and files. ",paraId:6,tocIndex:3},{value:"Search",paraId:6,tocIndex:3},{value:" is a global search function. ",paraId:6,tocIndex:3},{value:"Solidity Compiler",paraId:6,tocIndex:3},{value:" is the interface of the contract compiler. The interface displays the basic configuration items of the compiler by default, and the ",paraId:6,tocIndex:3},{value:"Advanced Configurations",paraId:6,tocIndex:3},{value:" button opens the advanced configuration panel. ",paraId:6,tocIndex:3},{value:"Deploy&Run",paraId:6,tocIndex:3},{value:" is to send the transaction to the current ",paraId:6,tocIndex:3},{value:"environment",paraId:6,tocIndex:3},{value:". ",paraId:6,tocIndex:3},{value:"Debugger",paraId:6,tocIndex:3},{value:" is a debugger. When debugging a transaction, the debugger will display the status of the contract. ",paraId:6,tocIndex:3},{value:"Plugin Manager",paraId:6,tocIndex:3},{value:" is a plug-in manager, there are many plug-ins to choose from. ",paraId:6,tocIndex:3},{value:"Setting",paraId:6,tocIndex:3},{value:" will have some basic settings, such as ",paraId:6,tocIndex:3},{value:"language",paraId:6,tocIndex:3},{value:", ",paraId:6,tocIndex:3},{value:"theme",paraId:6,tocIndex:3},{value:", ",paraId:6,tocIndex:3},{value:"GitHub access token",paraId:6,tocIndex:3},{value:", ",paraId:6,tocIndex:3},{value:"general settings",paraId:6,tocIndex:3},{value:", etc.",paraId:6,tocIndex:3},{value:"The ",paraId:7,tocIndex:4},{value:"WORKSPACES",paraId:7,tocIndex:4},{value:" in ",paraId:7,tocIndex:4},{value:"Remix",paraId:7,tocIndex:4},{value:" is a special folder that separates projects. The files in a workspace cannot import or access files in another workspace. As shown in the figure below, click icon 1 to switch different workspaces, and icon 2 can perform a series of operations on the workspace, such as ",paraId:7,tocIndex:4},{value:"Create",paraId:7,tocIndex:4},{value:", ",paraId:7,tocIndex:4},{value:"Clone",paraId:7,tocIndex:4},{value:", ",paraId:7,tocIndex:4},{value:"Rename",paraId:7,tocIndex:4},{value:", ",paraId:7,tocIndex:4},{value:"Download",paraId:7,tocIndex:4},{value:", ",paraId:7,tocIndex:4},{value:"Delete",paraId:7,tocIndex:4},{value:", etc.",paraId:7,tocIndex:4},{value:" ",paraId:8,tocIndex:4},{value:"We will demonstrate through the ",paraId:9,tocIndex:5},{value:"Create",paraId:9,tocIndex:5},{value:" button in this tutorial. When we click ",paraId:9,tocIndex:5},{value:"Create",paraId:9,tocIndex:5},{value:", the ",paraId:9,tocIndex:5},{value:"Create Workspace",paraId:9,tocIndex:5},{value:" pop-up window will pop up. ",paraId:9,tocIndex:5},{value:"Remix",paraId:9,tocIndex:5},{value:" provides the following templates:",paraId:9,tocIndex:5},{value:"Basic",paraId:10,tocIndex:5},{value:"Blank",paraId:10,tocIndex:5},{value:"OpenZeppelin ERC20",paraId:10,tocIndex:5},{value:"OpenZeppelin ERC721",paraId:10,tocIndex:5},{value:"OpenZeppelin ERC1155",paraId:10,tocIndex:5},{value:"0xProject ERC20",paraId:10,tocIndex:5},{value:"Gnosis Safe",paraId:10,tocIndex:5},{value:"When you select an ",paraId:11,tocIndex:5},{value:"ERC721",paraId:11,tocIndex:5},{value:" template of the ",paraId:11,tocIndex:5},{value:"OpenZeppelin",paraId:11,tocIndex:5},{value:" library, you can add additional features.",paraId:11,tocIndex:5},{value:"ERC721",paraId:12,tocIndex:5},{value:" (Ethereum Request for Comments 721), proposed by William Entriken, Dieter Shirley, Jacob Evans, Nastasia Sachs in January 2018, is a non-homogeneous token standard that implements token APIs in smart contracts. ",paraId:12,tocIndex:5},{value:"OpenZeppelin",paraId:12,tocIndex:5},{value:" is a library for secure smart contract development, which contains the standard implementation of many commonly used contracts.",paraId:12,tocIndex:5},{value:" ",paraId:13,tocIndex:5},{value:"Check ",paraId:14,tocIndex:5},{value:"Mintable",paraId:14,tocIndex:5},{value:", which means that we add the ",paraId:14,tocIndex:5},{value:"Mint",paraId:14,tocIndex:5},{value:" method to the template contract, and then click ",paraId:14,tocIndex:5},{value:"OK",paraId:14,tocIndex:5},{value:". Here, our ",paraId:14,tocIndex:5},{value:"Workspace",paraId:14,tocIndex:5},{value:" is created. As shown in the figure below:",paraId:14,tocIndex:5},{value:".deps",paraId:15,tocIndex:5},{value:" directory contains the npm package of ",paraId:15,tocIndex:5},{value:"@openzeppelin",paraId:15,tocIndex:5},{value:" we installed. The ",paraId:15,tocIndex:5},{value:"contract template",paraId:15,tocIndex:5},{value:" referenced in our contract is installed here, as well as the ",paraId:15,tocIndex:5},{value:"toolkit",paraId:15,tocIndex:5},{value:" referenced in the contract template. ",paraId:15,tocIndex:5},{value:"contracts",paraId:15,tocIndex:5},{value:" is the contract file written by ourselves. ",paraId:15,tocIndex:5},{value:"scripts",paraId:15,tocIndex:5},{value:" folder contains the automatically generated script files for deploying contracts. You can also deploy contracts by executing the js file below this. ",paraId:15,tocIndex:5},{value:"tests",paraId:15,tocIndex:5},{value:" automatically writes some automatic verification test files.",paraId:15,tocIndex:5},{value:"@openzeppelin",paraId:16,tocIndex:5},{value:" provides us with the ",paraId:16,tocIndex:5},{value:"ERC721",paraId:16,tocIndex:5},{value:" contract template in ",paraId:16,tocIndex:5},{value:"contracts/MyToken.sol",paraId:16,tocIndex:5},{value:", let's take a brief look at the content of this contract.",paraId:16,tocIndex:5},{value:"The first line is a comment, which will write the software license (",paraId:17,tocIndex:5},{value:"license",paraId:17,tocIndex:5},{value:") used by this code. Here we use ",paraId:17,tocIndex:5},{value:"MIT license",paraId:17,tocIndex:5},{value:". If no license is written, a warning (",paraId:17,tocIndex:5},{value:"warning",paraId:17,tocIndex:5},{value:") will be issued during compilation, but the program can run. ",paraId:17,tocIndex:5},{value:"solidity",paraId:17,tocIndex:5},{value:" comments start with ",paraId:17,tocIndex:5},{value:"//",paraId:17,tocIndex:5},{value:", followed by the content of the comment (will not be executed by the program).",paraId:17,tocIndex:5},{value:"The second line declares the ",paraId:17,tocIndex:5},{value:"solidity",paraId:17,tocIndex:5},{value:" version used by the source file, because different versions have different syntax. This line of code means that the source file will not allow compilers less than version ",paraId:17,tocIndex:5},{value:"0.8.20",paraId:17,tocIndex:5},{value:" or greater than or equal to ",paraId:17,tocIndex:5},{value:"0.9.0",paraId:17,tocIndex:5},{value:" to compile (the second condition is provided by ",paraId:17,tocIndex:5},{value:"^",paraId:17,tocIndex:5},{value:"). ",paraId:17,tocIndex:5},{value:"Solidity",paraId:17,tocIndex:5},{value:" statements end with a semicolon (",paraId:17,tocIndex:5},{value:";",paraId:17,tocIndex:5},{value:").",paraId:17,tocIndex:5},{value:"The 4-5 lines import external ",paraId:17,tocIndex:5},{value:"Solidity",paraId:17,tocIndex:5},{value:" files, and the imported ",paraId:17,tocIndex:5},{value:"Solidity",paraId:17,tocIndex:5},{value:" files and the ",paraId:17,tocIndex:5},{value:"Solidity",paraId:17,tocIndex:5},{value:" files themselves are equivalent to the same ",paraId:17,tocIndex:5},{value:"Solidity",paraId:17,tocIndex:5},{value:" contract.",paraId:17,tocIndex:5},{value:"Line 7 creates a contract (",paraId:17,tocIndex:5},{value:"contract",paraId:17,tocIndex:5},{value:") and declares the name of the contract as ",paraId:17,tocIndex:5},{value:"MyToken",paraId:17,tocIndex:5},{value:". The keyword ",paraId:17,tocIndex:5},{value:"is",paraId:17,tocIndex:5},{value:" indicates that the contract inherits the imported ",paraId:17,tocIndex:5},{value:"ERC721",paraId:17,tocIndex:5},{value:" and ",paraId:17,tocIndex:5},{value:"Ownable",paraId:17,tocIndex:5},{value:" contracts.",paraId:17,tocIndex:5},{value:"Lines 8-10, within the ",paraId:17,tocIndex:5},{value:"constructor",paraId:17,tocIndex:5},{value:", we pass the predefined parameters of the inherited contracts. For ",paraId:17,tocIndex:5},{value:"ERC721",paraId:17,tocIndex:5},{value:", we pass the ",paraId:17,tocIndex:5},{value:"name",paraId:17,tocIndex:5},{value:" and ",paraId:17,tocIndex:5},{value:"symbol",paraId:17,tocIndex:5},{value:" of the ",paraId:17,tocIndex:5},{value:"token",paraId:17,tocIndex:5},{value:", and for ",paraId:17,tocIndex:5},{value:"Ownable",paraId:17,tocIndex:5},{value:", we pass the address of the contract owner.",paraId:17,tocIndex:5},{value:"Lines 13-15 define a ",paraId:17,tocIndex:5},{value:"public",paraId:17,tocIndex:5},{value:" method called ",paraId:17,tocIndex:5},{value:"safeMint",paraId:17,tocIndex:5},{value:", which is accessible to the outside world. This method requires two parameters: ",paraId:17,tocIndex:5},{value:"to",paraId:17,tocIndex:5},{value:", of type ",paraId:17,tocIndex:5},{value:"address",paraId:17,tocIndex:5},{value:", and ",paraId:17,tocIndex:5},{value:"tokenId",paraId:17,tocIndex:5},{value:", of type ",paraId:17,tocIndex:5},{value:"uint256",paraId:17,tocIndex:5},{value:". Inside the method, the private method ",paraId:17,tocIndex:5},{value:"_safeMint()",paraId:17,tocIndex:5},{value:" from the ",paraId:17,tocIndex:5},{value:"ERC721.sol",paraId:17,tocIndex:5},{value:" contract is executed, along with the provided ",paraId:17,tocIndex:5},{value:"to",paraId:17,tocIndex:5},{value:" and ",paraId:17,tocIndex:5},{value:"tokenId",paraId:17,tocIndex:5},{value:" parameters.",paraId:17,tocIndex:5},{value:"Next, we will try to write some custom functions to the contract template.",paraId:18,tocIndex:5}]},64139:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(30098);const t=[{value:"In this course, you will be guided to call a real contract in DApp. We will take Ethereum as an example and call the contract of an NFT ",paraId:0,tocIndex:1},{value:"0xEcd0D12E21805803f70de03B72B1C162dB0898d9",paraId:0,tocIndex:1},{value:".",paraId:0,tocIndex:1},{value:"Contract ",paraId:1,tocIndex:1},{value:"0xEcd0D12E21805803f70de03B72B1C162dB0898d9",paraId:1,tocIndex:1},{value:" is a contract of NFT project ",paraId:1,tocIndex:1},{value:"OurMetaverse",paraId:1,tocIndex:1},{value:". It is a contract that conforms to the ",paraId:1,tocIndex:1},{value:"ERC721",paraId:1,tocIndex:1},{value:" standard. We try to call its ",paraId:1,tocIndex:1},{value:"totalSupply",paraId:1,tocIndex:1},{value:" method to get how many NFTs this contract has issued.",paraId:1,tocIndex:1},{value:"Because we only need to read the contract data and do not need to modify the contract data. So we don't need to initiate a transaction to the blockchain, that is, we don't need to consume tokens as ",paraId:2,tocIndex:2},{value:"GAS",paraId:2,tocIndex:2},{value:". But we need a node to help us read the contract data. In the Web3 ecosystem, there are many vendors that provide node services, and you can choose your favorite node service. Here is an example of ",paraId:2,tocIndex:2},{value:"ZAN's node service",paraId:2,tocIndex:2},{value:" to guide you on how to configure the node service.",paraId:2,tocIndex:2},{value:"First register and log in to ",paraId:3,tocIndex:2},{value:"https://zan.top",paraId:3,tocIndex:2},{value:" and then enter the node service console ",paraId:3,tocIndex:2},{value:"https://zan.top/service/apikeys",paraId:3,tocIndex:2},{value:" to create a Key. Each Key has a default free quota, which is enough for micro projects, but for production environment projects, please purchase node services according to the actual situation.",paraId:3,tocIndex:2},{value:"After the creation is successful, you will see the following page:",paraId:4,tocIndex:2},{value:"Select the node service address of the Ethereum mainnet and copy it. After copying, configure it into ",paraId:5,tocIndex:2},{value:"transports",paraId:5,tocIndex:2},{value:":",paraId:5,tocIndex:2},{value:`+ import { http } from 'wagmi';
import { Address, ConnectButton, Connector, NFTCard } from '@ant-design/web3';
import { MetaMask, WagmiWeb3ConfigProvider } from '@ant-design/web3-wagmi';

export default function Web3() {
  return (
    <WagmiWeb3ConfigProvider
      eip6963={{
        autoAddInjectedWallets: true,
      }}
+      transports={{
+        [Mainnet.id]: http('https://api.zan.top/node/v1/eth/mainnet/{YourZANApiKey}'),
+      }}
      chains={[Mainnet, Sepolia]}
      wallets={[MetaMask()]}
    >
      <Address format address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" />
      <NFTCard address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" tokenId={641} />
      <Connector>
        <ConnectButton />
      </Connector>
      <CallTest />
    </WagmiWeb3ConfigProvider>
  );
}
`,paraId:6,tocIndex:2},{value:"The ",paraId:7,tocIndex:2},{value:"YourZANApiKey",paraId:7,tocIndex:2},{value:" in the above code needs to be replaced with your own Key. In addition, in the actual project, in order to avoid your Key being abused, it is recommended that you put the Key in the backend service, and then call the node service through the backend service, or set the domain name whitelist in the ZAN console to reduce the risk of abuse. Of course, in the tutorial, you can continue to use ",paraId:7,tocIndex:2},{value:"http()",paraId:7,tocIndex:2},{value:" to use the built-in default experimental node service of wagmi.",paraId:7,tocIndex:2},{value:"After configuring the node service, we can start calling the contract. We use the ",paraId:8,tocIndex:3},{value:"useReadContract",paraId:8,tocIndex:3},{value:" Hook provided by wagmi to read the contract data. The sample code is as follows:",paraId:8,tocIndex:3},{value:`- import { http } from "wagmi";
+ import { http, useReadContract } from "wagmi";
import { mainnet } from "wagmi/chains";
import { WagmiWeb3ConfigProvider, MetaMask } from "@ant-design/web3-wagmi";
- import { Address, NFTCard, Connector, ConnectButton } from "@ant-design/web3";
+ import { Address, NFTCard, Connector, ConnectButton, useAccount } from "@ant-design/web3";

+ const CONTRACT_ADDRESS = '0xEcd0D12E21805803f70de03B72B1C162dB0898d9'
+
+ const CallTest = () => {
+  const { account } = useAccount();
+  const result = useReadContract({
+    abi: [
+      {
+        type: 'function',
+        name: 'balanceOf',
+        stateMutability: 'view',
+        inputs: [{ name: 'account', type: 'address' }],
+        outputs: [{ type: 'uint256' }],
+      },
+    ],
+    address: CONTRACT_ADDRESS,
+    functionName: 'balanceOf',
+    args: [account?.address as \`0x\${string}\`],
+   });
+   return (
+     <div>{result.data?.toString()}</div>
+   );
+ }

export default function Web3() {
  return (
    <WagmiWeb3ConfigProvider
      eip6963={{
        autoAddInjectedWallets: true,
      }}
      wallets={[MetaMask()]}
    >
      <Address format address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" />
      <NFTCard
        address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9"
        tokenId={641}
      />
      <Connector>
        <ConnectButton />
      </Connector>
+      <CallTest />
    </WagmiWeb3ConfigProvider>
  );
};

`,paraId:9,tocIndex:3},{value:"Refer to the above code to add the ",paraId:10,tocIndex:3},{value:"balanceOf",paraId:10,tocIndex:3},{value:" method of the contract. We created a ",paraId:10,tocIndex:3},{value:"CallTest",paraId:10,tocIndex:3},{value:" component, and then added this component in ",paraId:10,tocIndex:3},{value:"WagmiWeb3ConfigProvider",paraId:10,tocIndex:3},{value:". Because ",paraId:10,tocIndex:3},{value:"useReadContract",paraId:10,tocIndex:3},{value:" must work inside ",paraId:10,tocIndex:3},{value:"WagmiWeb3ConfigProvider",paraId:10,tocIndex:3},{value:", we cannot use ",paraId:10,tocIndex:3},{value:"useReadContract",paraId:10,tocIndex:3},{value:" directly below the ",paraId:10,tocIndex:3},{value:"export default function Web3() {",paraId:10,tocIndex:3},{value:" line of code. In the actual project, ",paraId:10,tocIndex:3},{value:"WagmiWeb3ConfigProvider",paraId:10,tocIndex:3},{value:" should usually be at the outermost layer of your project component, so that all components of your project can use related Hooks normally.",paraId:10,tocIndex:3},{value:"BalanceOf",paraId:11,tocIndex:3},{value:" is a method used to get how many NFTs of this contract are under an address. So we also need to use the ",paraId:11,tocIndex:3},{value:"useAccount",paraId:11,tocIndex:3},{value:" Hook provided by ",paraId:11,tocIndex:3},{value:"@ant-design/web3",paraId:11,tocIndex:3},{value:" to get the address of the current connected account. Then pass the account address as the parameter of the ",paraId:11,tocIndex:3},{value:"balanceOf",paraId:11,tocIndex:3},{value:" method, so that you can get how many NFTs are under the current account address. If nothing unexpected happens, you will get the result of ",paraId:11,tocIndex:3},{value:"0",paraId:11,tocIndex:3},{value:".",paraId:11,tocIndex:3},{value:"abi",paraId:12,tocIndex:3},{value:" in the code defines the type of the method, so that wagmi can know how to handle the input parameters and returns of the method, and convert the JavaScript object into blockchain transaction information. Usually abi is automatically generated through contract code, we will talk about this part in the next chapter.",paraId:12,tocIndex:3},{value:"Only reading the contract is not enough. A real DApp will definitely involve writing data to the smart contract. Writing data to the smart contract is usually done by executing the smart contract method on the blockchain, and the method execution process will modify the data in the contract.",paraId:13,tocIndex:4},{value:"Next, we will try to call the ",paraId:14,tocIndex:4},{value:"mint",paraId:14,tocIndex:4},{value:" method of the contract used in the next course. The ",paraId:14,tocIndex:4},{value:"mint",paraId:14,tocIndex:4},{value:" method is not a method in the ERC721 specification, it is defined by the contract itself. In this contract, calling the ",paraId:14,tocIndex:4},{value:"mint",paraId:14,tocIndex:4},{value:" method requires consuming GAS and at least ",paraId:14,tocIndex:4},{value:"0.01ETH",paraId:14,tocIndex:4},{value:" to obtain NFT.",paraId:14,tocIndex:4},{value:"The code that needs to be modified is as follows:",paraId:15,tocIndex:4},{value:`- import { http, useReadContract } from "wagmi";
+ import { http, useReadContract, useWriteContract } from "wagmi";
+ import { Button, message } from "antd";
+ import { parseEther } from "viem";

// ...

const CallTest = () => {

// ...
+ const { writeContract, data: hash } = useWriteContract();

  return (
    <div>
      {result.data?.toString()}
+      <Button
+        onClick={() => {
+          writeContract(
+            {
+              abi: [
+                {
+                  type: "function",
+                  name: "mint",
+                  stateMutability: "payable",
+                  inputs: [
+                    {
+                      internalType: "uint256",
+                      name: "quantity",
+                      type: "uint256",
+                    },
+                  ],
+                  outputs: [],
+                },
+              ],
+              address: CONTRACT_ADDRESS,
+              functionName: "mint",
+              args: [BigInt(1)],
+              value: parseEther("0.01"),
+            },
+            {
+              onSuccess: () => {
+                message.success("Mint Success");
+              },
+              onError: (err) => {
+                message.error(err.message);
+              },
+            }
+          );
+        }}
+      >
+        mint
+      </Button>
    </div>
  );
};

// ...

`,paraId:16,tocIndex:4},{value:"In the above code, we used the ",paraId:17,tocIndex:4},{value:"viem",paraId:17,tocIndex:4},{value:" library, which is a library that ",paraId:17,tocIndex:4},{value:"wagmi",paraId:17,tocIndex:4},{value:" depends on at the bottom layer. You need to install it in the project:",paraId:17,tocIndex:4},{value:`npm install viem
`,paraId:18,tocIndex:4},{value:"In the above code, we implemented the ",paraId:19,tocIndex:4},{value:"mint",paraId:19,tocIndex:4},{value:" method of the contract after clicking the ",paraId:19,tocIndex:4},{value:"mint",paraId:19,tocIndex:4},{value:" button, passing in the parameter ",paraId:19,tocIndex:4},{value:"1",paraId:19,tocIndex:4},{value:". In the implementation logic of the contract, this means that an NFT is to be minted. Since the price of each NFT minted is ",paraId:19,tocIndex:4},{value:"0.01 ETH",paraId:19,tocIndex:4},{value:", we also need to send a fee of ",paraId:19,tocIndex:4},{value:"0.01 ETH",paraId:19,tocIndex:4},{value:" in the transaction, so that we can successfully mint the NFT. So the above code will configure ",paraId:19,tocIndex:4},{value:'value: parseEther("0.01")',paraId:19,tocIndex:4},{value:" in the contract call. In the execution of the contract method in Ethereum, the contract cannot directly extract the ETH of the caller, so we need to actively send ETH to the contract when calling the contract, which is a consideration of the contract security design.",paraId:19,tocIndex:4},{value:"Contract calls will have corresponding prompts for success and failure. If the account is not connected, an error of unconnected account will be thrown. So you need to click the connection button we implemented in the previous course to connect your account address. If your account has enough ETH, then click After that, a similar authorization pop-up window will appear:",paraId:20,tocIndex:4},{value:"Click ",paraId:21,tocIndex:4},{value:"Reject",paraId:21,tocIndex:4},{value:", the contract call will not be executed, and your ETH will not be consumed. In the next chapter, we will guide you to deploy a test contract and experience the complete process in the test environment. Of course, if you are very rich, you can also click OK, so that the contract call will be executed.",paraId:21,tocIndex:4},{value:"After the transaction is sent, you need to listen to the transaction ",paraId:22,tocIndex:4},{value:"hash",paraId:22,tocIndex:4},{value:", wait for the transaction to be confirmed, consume your ETH, and get an NFT.",paraId:22,tocIndex:4},{value:"The code that needs to be modified is as follows:",paraId:23,tocIndex:4},{value:`+ import { useWaitForTransactionReceipt } from 'wagmi';
// ...

const CallTest = () => {
+ const { isLoading: isConfirming, isSuccess: isConfirmed } =
+   useWaitForTransactionReceipt({
+    hash,
+  });
+
+ useEffect(() => {
+  if (isConfirmed) {
+    message.success("Mint Success");
+    result.refetch();
+  }
+ }, [isConfirmed]);
+
  return (
    <div>
      {result.data?.toString()}
      <Button
+       loading={isConfirming}
        {/* ... */}
      </Button>
    </div>
  )
};
`,paraId:24,tocIndex:4},{value:"Sending a transaction refers to the process of creating and broadcasting a transaction to the blockchain network, while transaction confirmation (transaction on-chain) means that once the transaction is verified and included in the blockchain, the transaction data is permanently recorded in the blockchain process. Once a transaction is backed up into a block and the block is added to the blockchain, the transaction data will be permanently stored in each account on the blockchain and cannot be tampered with.",paraId:25,tocIndex:4},{value:"Full code:",paraId:26,tocIndex:4}]},74681:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(45905);const t=[{value:"In this part of the course, we will guide you to connect the DApp to the blockchain through the wallet and the blockchain. We will take Ethereum as an example to connect to the blockchain and obtain the user's account information.",paraId:0,tocIndex:1},{value:"First, similar to the ",paraId:1,tocIndex:2},{value:"Quick Start",paraId:2,tocIndex:2},{value:" documentation guide, we need to install some dependencies. In the previous course, we have installed ",paraId:1,tocIndex:2},{value:"antd",paraId:1,tocIndex:2},{value:" and ",paraId:1,tocIndex:2},{value:"@ant-design/web3",paraId:1,tocIndex:2},{value:", so we only need to install ",paraId:1,tocIndex:2},{value:"@ant-design/web3-wagmi",paraId:1,tocIndex:2},{value:" and ",paraId:1,tocIndex:2},{value:"wagmi",paraId:1,tocIndex:2},{value:" next.",paraId:1,tocIndex:2},{value:`npm i @ant-design/web3-wagmi wagmi viem @tanstack/react-query --save
`,paraId:3,tocIndex:2},{value:"@ant-design/web3",paraId:4,tocIndex:2},{value:" is a UI component library, which connects to different blockchains through different ",paraId:4,tocIndex:2},{value:"adapters",paraId:5,tocIndex:2},{value:". In this course, we mainly use ",paraId:4,tocIndex:2},{value:"Ethereum",paraId:4,tocIndex:2},{value:" as an example. Correspondingly, we will also use the ",paraId:4,tocIndex:2},{value:"adapter of Ethereum",paraId:6,tocIndex:2},{value:" to implement the requirements of the course.",paraId:4,tocIndex:2},{value:"wagmi",paraId:7,tocIndex:2},{value:" is an open source React Hooks library that serves Ethereum. The adapter ",paraId:7,tocIndex:2},{value:"@ant-design/web3-wagmi",paraId:7,tocIndex:2},{value:" of Ant Design Web3 is based on it. In the later part of this course, unless otherwise specified, the adapter mentioned refers to ",paraId:7,tocIndex:2},{value:"@ant-design/web3-wagmi",paraId:7,tocIndex:2},{value:".",paraId:7,tocIndex:2},{value:"The configuration of the adapter directly uses the ",paraId:8,tocIndex:3},{value:"official configuration of wagmi",paraId:8,tocIndex:3},{value:". For actual projects, you usually need to configure the JSON RPC address and various wallets. In this course, we will first use the simplest configuration, and then guide you to understand the configuration you need in your actual project.",paraId:8,tocIndex:3},{value:"First, please continue to edit the ",paraId:9,tocIndex:3},{value:"pages/web3.tsx",paraId:9,tocIndex:3},{value:" file and introduce the content you need:",paraId:9,tocIndex:3},{value:`+ import { WagmiWeb3ConfigProvider } from '@ant-design/web3-wagmi';
import { Address } from "@ant-design/web3";

export default function Web3() {
  return (
    <Address format address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" />
  );
};
`,paraId:10,tocIndex:3},{value:"WagmiWeb3ConfigProvider",paraId:11,tocIndex:3},{value:" is an Ant Design Web3 adapter based on wagmi, used for adapting Ethereum. In addition to adapting wagmi's API to the API required by Ant Design Web3, it also makes some usability improvements. You no longer need to use wagmi's ",paraId:11,tocIndex:3},{value:"createConfig",paraId:11,tocIndex:3},{value:" to create a configuration; it will automatically create the wagmi configuration for you. Of course, if you have special needs, you can also ",paraId:11,tocIndex:3},{value:"customize the configuration",paraId:11,tocIndex:3},{value:", and the customized configuration will override the automatically generated configuration of ",paraId:11,tocIndex:3},{value:"WagmiWeb3ConfigProvider",paraId:11,tocIndex:3},{value:".",paraId:11,tocIndex:3},{value:"Then import the ",paraId:12,tocIndex:3},{value:"WagmiWeb3ConfigProvider",paraId:12,tocIndex:3},{value:":",paraId:12,tocIndex:3},{value:`import { createConfig, http } from "wagmi";
import { mainnet } from "wagmi/chains";
import { WagmiWeb3ConfigProvider } from "@ant-design/web3-wagmi";
import { Address } from "@ant-design/web3";

export default function Web3() {
  return (
+     <WagmiWeb3ConfigProvider>
      <div
        style={{
          height: "100vh",
          padding: 64,
        }}
      >
        <Address format address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" />
      </div>
+    </WagmiWeb3ConfigProvider>
  );
};

`,paraId:13,tocIndex:3},{value:"In this way, we have completed the basic configuration of wagmi, and then we can use Ant Design Web3 components to obtain data on the chain.",paraId:14,tocIndex:3},{value:"Let's us try the ",paraId:15,tocIndex:3},{value:"NFTCard",paraId:15,tocIndex:3},{value:" component.",paraId:15,tocIndex:3},{value:`import { WagmiWeb3ConfigProvider } from "@ant-design/web3-wagmi";
- import { Address } from "@ant-design/web3";
+ import { Address, NFTCard } from "@ant-design/web3";

export default function Web3() {
  return (
    <WagmiWeb3ConfigProvider>
      <div
        style={{
          height: "100vh",
          padding: 64,
        }}
      >
         <Address format address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" />
+        <NFTCard address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" tokenId={641} />
      </div>
    </WagmiWeb3ConfigProvider>
  );
};
`,paraId:16,tocIndex:3},{value:"NFTCard",paraId:17,tocIndex:3},{value:" is a component that displays NFT information. We will use it to display the NFT information of the address ",paraId:17,tocIndex:3},{value:"0xEcd0D12E21805803f70de03B72B1C162dB0898d9",paraId:17,tocIndex:3},{value:" and the token ID ",paraId:17,tocIndex:3},{value:"641",paraId:17,tocIndex:3},{value:".",paraId:17,tocIndex:3},{value:"Result:",paraId:18,tocIndex:3},{value:"Please check your network if the result is not displayed.",paraId:19,tocIndex:3},{value:"In the previous section, we have successfully connected to the blockchain and obtained the data on the chain. However, we can see that the address displayed in the ",paraId:20,tocIndex:4},{value:"Address",paraId:20,tocIndex:4},{value:" component is ",paraId:20,tocIndex:4},{value:"0xEcd0D12E21805803f70de03B72B1C162dB0898d9",paraId:20,tocIndex:4},{value:", which is not the address of the current wallet. In this section, we will guide you to connect to the wallet and obtain the address of the current wallet.",paraId:20,tocIndex:4},{value:"We use ",paraId:21,tocIndex:4},{value:"MetaMask",paraId:21,tocIndex:4},{value:" as an example to see how to configure the wallet. Additionally, we have configured ",paraId:21,tocIndex:4},{value:"eip6963",paraId:21,tocIndex:4},{value:"'s ",paraId:21,tocIndex:4},{value:"autoAddInjectedWallets",paraId:21,tocIndex:4},{value:" to ",paraId:21,tocIndex:4},{value:"true",paraId:21,tocIndex:4},{value:", which will automatically add the wallets installed in your browser.",paraId:21,tocIndex:4},{value:`- import { WagmiWeb3ConfigProvider } from "@ant-design/web3-wagmi";
+ import { WagmiWeb3ConfigProvider, MetaMask } from "@ant-design/web3-wagmi";
- import { Address, NFTCard } from "@ant-design/web3";
+ import { Address, NFTCard, Connector, ConnectButton } from "@ant-design/web3";

export default function Web3() {
  return (
-   <WagmiWeb3ConfigProvider>
+    <WagmiWeb3ConfigProvider
+      eip6963={{
+        autoAddInjectedWallets: true,
+      }}
+      wallets={[MetaMask()]}
+    >
      <Address format address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" />
      <NFTCard
        address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9"
        tokenId={641}
      />
+       <Connector>
+         <ConnectButton />
+       </Connector>
    </WagmiWeb3ConfigProvider>
  );
};

`,paraId:22,tocIndex:4},{value:"The full code is as follows:",paraId:23,tocIndex:4},{value:"The result is as follows:",paraId:24},{value:"You can try to refer to ",paraId:25},{value:"this document",paraId:26},{value:" to configure support for more wallets.",paraId:25}]},94978:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(92519);const t=[{value:"In this part of the course, we will guide you to build the front-end part of a DApp. This DApp will implement a function of minting NFT. After the user connects the wallet, he can click to mint an NFT and view the minted NFT.",paraId:0,tocIndex:1},{value:"This part will not involve the development of smart contracts for the time being. The development of smart contracts will be put into the next part of the course. We will provide a smart contract for testing for the DApp to call.",paraId:1,tocIndex:1},{value:"The complete code of this tutorial can be found at ",paraId:2,tocIndex:1},{value:"https://github.com/ant-design/ant-design-web3-demo",paraId:2,tocIndex:1},{value:".",paraId:2,tocIndex:1},{value:"We will use ",paraId:3,tocIndex:2},{value:"React",paraId:3,tocIndex:2},{value:" + ",paraId:3,tocIndex:2},{value:"Next.js",paraId:3,tocIndex:2},{value:" + ",paraId:3,tocIndex:2},{value:"TypeScript",paraId:3,tocIndex:2},{value:" to initialize our project. Of course, if you are more familiar with other front-end frameworks such as ",paraId:3,tocIndex:2},{value:"umi",paraId:3,tocIndex:2},{value:", you can also use the framework you are familiar with. You can still refer to this tutorial, but for non-professional front-end developers, we recommend that you follow the tutorial step by step to complete it to avoid problems caused by framework differences.",paraId:3,tocIndex:2},{value:"Before you start, please make sure you have installed ",paraId:4,tocIndex:2},{value:"Node.js",paraId:4,tocIndex:2},{value:" and the version is greater than 20.0.0. The tutorial will be written based on the latest version of Node.js. If you are using an old version of Node.js, it may also run, but when you encounter problems, you can try to upgrade the Node.js version.",paraId:4,tocIndex:2},{value:"After the installation is complete, you can use the following command to check whether Node.js and its built-in ",paraId:5,tocIndex:2},{value:"npm",paraId:5,tocIndex:2},{value:" and ",paraId:5,tocIndex:2},{value:"npx",paraId:5,tocIndex:2},{value:" are installed successfully:",paraId:5,tocIndex:2},{value:`node -v # => v20.0.0+
npm -v # => 10.0.0+
npx -v # => 10.0.0+
`,paraId:6,tocIndex:2},{value:"Next, we refer to the ",paraId:7,tocIndex:2},{value:"Next.js official documentation",paraId:7,tocIndex:2},{value:" to create a new project:",paraId:7,tocIndex:2},{value:`npx create-next-app@14.0.4 # We specify the version of create-next-app as 14.0.4 to avoid the differences caused by the upgrade affecting the details of the tutorial
`,paraId:8,tocIndex:2},{value:"Please create a new project according to the prompts. We will name it ",paraId:9,tocIndex:2},{value:"ant-design-web3-demo",paraId:9,tocIndex:2},{value:". You can refer to the following figure for the specific technical stack selection:",paraId:9,tocIndex:2},{value:"We removed the selection of ",paraId:10,tocIndex:2},{value:"Tailwind CSS",paraId:10,tocIndex:2},{value:" and ",paraId:10,tocIndex:2},{value:"App Router",paraId:10,tocIndex:2},{value:" to make the project simpler. In actual projects, you should choose the content you need according to your needs.",paraId:10,tocIndex:2},{value:"After the creation is complete, enter the project directory and install the dependencies:",paraId:11,tocIndex:3},{value:`cd ant-design-web3-demo
npm i
`,paraId:12,tocIndex:3},{value:"After the installation is complete, execute ",paraId:13,tocIndex:3},{value:"npm run dev",paraId:13,tocIndex:3},{value:" to start the project. You can visit ",paraId:13,tocIndex:3},{value:"http://localhost:3000",paraId:13,tocIndex:3},{value:" in the browser to see if the project starts successfully.",paraId:13,tocIndex:3},{value:"Next, we install the basic components of Ant Design and Ant Design Web3 to the project:",paraId:14,tocIndex:4},{value:`npm i @ant-design/web3 --save
`,paraId:15,tocIndex:4},{value:"After the installation is complete, you need configure the ",paraId:16,tocIndex:4},{value:"next.config.js",paraId:16,tocIndex:4},{value:" because of ",paraId:16,tocIndex:4},{value:"an existing issue",paraId:16,tocIndex:4},{value:" in the current version of Next.js:",paraId:16,tocIndex:4},{value:`/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
+ transpilePackages: [  "@ant-design", "antd", "rc-util", "rc-pagination", "rc-picker", "rc-input" ],
}

module.exports = nextConfig
`,paraId:17,tocIndex:4},{value:"Then, Create a new file ",paraId:18,tocIndex:4},{value:"pages/web3.tsx",paraId:18,tocIndex:4},{value:" and add the following code:",paraId:18,tocIndex:4},{value:`import { Address } from '@ant-design/web3';

export default function Web3() {
  return <Address format address="0xEcd0D12E21805803f70de03B72B1C162dB0898d9" />;
}
`,paraId:19,tocIndex:4},{value:"Then visit ",paraId:20,tocIndex:4},{value:"http://localhost:3000/web3",paraId:20,tocIndex:4},{value:" to see that you have successfully used Ant Design Web3 in the project \u{1F389}",paraId:20,tocIndex:4},{value:"To make the page more aesthetically pleasing, you can add the following code to ",paraId:21,tocIndex:4},{value:"styles/global.css",paraId:21,tocIndex:4},{value:":",paraId:21,tocIndex:4},{value:`html,
body {
  max-width: 100vw;
+  min-height: 100vh;
  overflow-x: hidden;
}
`,paraId:22,tocIndex:4},{value:"Of course, this is not necessary.",paraId:23,tocIndex:4}]},24180:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(9181);const t=[{value:"Blockchain is a very secure and reliable decentralized network. People can record transaction behavior, store data and exchange value in a distributed ledger, and the whole process is not controlled by any centralized organization, but is maintained by computers distributed around the world.",paraId:0},{value:'Similar protocols to blockchain were actually invented as early as the 1980s and were used to verify timestamps in documents in the 1990s. However, the first truly decentralized blockchain was first proposed by an individual named "Satoshi Nakamoto" in the ',paraId:1,tocIndex:1},{value:"Bitcoin White Paper",paraId:1,tocIndex:1},{value:" in 2008.",paraId:1,tocIndex:1},{value:'Blockchain technology is the underlying technology of the Bitcoin network, and the Bitcoin open source software was released in 2009. It is worth mentioning that the Bitcoin white paper did not actually use the term "blockchain", and this concept was gradually introduced and promoted by people who promoted the development of this technology.',paraId:2,tocIndex:1},{value:'Blockchain can be regarded as a transaction history record, in which each block is "connected" with the previous block in order, forming an immutable record in a peer-to-peer network. By applying encryption trust and guarantee technology, each transaction is assigned a unique identifier or digital fingerprint.',paraId:3,tocIndex:2},{value:"Its trust, responsibility, transparency and security features make blockchain an ideal choice for many organizations and trading partners to access and share data, forming a third-party, consensus-based trust. All participants maintain an encrypted record of each transaction in an undeniable, decentralized, highly scalable and resilient recording mechanism without additional costs or intermediaries. The decentralized single source of information reduces the cost of executing trusted business interactions between parties that may not fully trust each other.",paraId:4,tocIndex:2},{value:"In a permissioned blockchain, participants have the right to participate in the network, and each participant is responsible for maintaining an encrypted record of each transaction. Any company or group that needs secure, real-time, and shareable transaction records can benefit from this unique technology. Its advantage is to improve security and availability, avoid central vulnerabilities, because there is no single location to store all content.",paraId:5,tocIndex:2},{value:"The following definitions help to understand blockchain and its underlying technology and application scenarios in depth:",paraId:6,tocIndex:2},{value:"Decentralized trust",paraId:7,tocIndex:2},{value:": The uniqueness of blockchain is that it does not rely on central authority, but can still guarantee data integrity and realize decentralized trust based on reliable data.",paraId:7,tocIndex:2},{value:"Block",paraId:7,tocIndex:2},{value:": Blockchain stores data in blocks, and each block is connected to the previous block, forming an immutable chain structure. Only adding new blocks is supported. Once added to the blockchain, no block can be modified or deleted.",paraId:7,tocIndex:2},{value:"Consensus algorithm",paraId:7,tocIndex:2},{value:": The consensus algorithm responsible for executing the rules within the blockchain system ensures that all parties comply with the set rules.",paraId:7,tocIndex:2},{value:"Blockchain node",paraId:7,tocIndex:2},{value:": The node responsible for storing data blocks is the storage unit in the blockchain, which keeps the data synchronized and always in the latest state. When a new node joins the network, it will download a copy of all blocks on the current chain and synchronize and update to the latest blockchain version with other nodes.",paraId:7,tocIndex:2},{value:"A smart contract is a computer program hosted and executed on a blockchain network. Each smart contract contains code that specifies the predetermined conditions, and when these conditions are met, the result will be triggered. By running on a decentralized blockchain instead of a centralized server, smart contracts allow multiple parties to share results in an accurate, timely, and tamper-resistant manner.",paraId:8,tocIndex:3},{value:"Smart contracts are powerful automation infrastructure because they are not controlled by central administrators and are not easily subject to single-point attacks by malicious entities. When applied to multi-party digital protocols, smart contract applications can reduce counterparty risk, improve efficiency, reduce costs, and provide new transparency to processes.",paraId:9,tocIndex:3},{value:"Smart contracts follow the simple ",paraId:10,tocIndex:4},{value:"if/when\u2026then\u2026",paraId:10,tocIndex:4},{value:" statement, which is written into code on the blockchain. When the predetermined conditions are met and verified, the computer network will execute the operation. These operations may include issuing funds to relevant parties, registering vehicles, sending notifications, or generating vouchers. Subsequently, when the transaction is completed, the blockchain will be updated, making the transaction unchangeable, and only authorized parties can view the results.",paraId:10,tocIndex:4},{value:"In smart contracts, in order to meet the needs of all parties and complete the task successfully, multiple provisions can be established. In order to establish these terms, participants must reach an agreement on how transactions and their data are represented on the blockchain, agree to establish rules for managing these transactions, and consider and define a framework for resolving disputes.",paraId:11,tocIndex:4},{value:"Not all blockchains have the ability to run smart contracts. Although some blockchains or second-layer networks (such as Arbitrum, Avalanche, Base, BNB Chain, Ethereum, etc.) are examples of smart contract compatibility, blockchains like the basic Bitcoin blockchain do not have native smart contract functions. The main difference between these blockchains is their ability to execute and store arbitrary logic at the bottom.",paraId:12},{value:"Speed, efficiency and accuracy",paraId:13,tocIndex:5},{value:": Once the conditions are met, the contract will be executed immediately. Because smart contracts are digitalized and automated, there is no need to deal with paperwork, nor do you need to spend time reconciling errors that are usually caused by manual filling.",paraId:13,tocIndex:5},{value:"Trust and transparency",paraId:13,tocIndex:5},{value:": Because there is no third party involved, and the encrypted transaction records are shared between participants, there is no need to question whether the information has been changed for personal gain.",paraId:13,tocIndex:5},{value:"Security",paraId:13,tocIndex:5},{value:": Blockchain transaction records are encrypted, which makes it difficult to crack. In addition, since each record is associated with the previous and subsequent records on the distributed ledger, hackers must change the entire chain to change a single record.",paraId:13,tocIndex:5},{value:"Save",paraId:13,tocIndex:5},{value:": Smart contracts avoid the need for transactions to be processed through intermediaries, thereby eliminating the time delay and cost associated with reconciling documents manually.",paraId:13,tocIndex:5}]},49911:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(37745);const t=[{value:"We take Ethereum as an example. After the smart contract is deployed to the blockchain, we can call the corresponding method in the contract by constructing the Ethereum transaction (Transaction), provided that we know the ABI file of the contract and the HASH address of the contract.",paraId:0,tocIndex:0},{value:"ABI is the abbreviation of Application Binary Interface, which is a binary interface standard for defining the functions and parameters of smart contracts. The contract HASH is the address of the contract on the blockchain. They can be obtained when deploying smart contracts.",paraId:1},{value:"There are generally two ways for DApp to call contract methods: connect through wallet plug-ins and connect directly through node RPC. We mainly introduce the first method.",paraId:2},{value:"MetaMask",paraId:3,tocIndex:1},{value:" is currently the most popular wallet plug-in in the Ethereum ecosystem. It provides a simple way for users to manage their Ethereum assets in the browser, and it is also a bridge for DApp to interact with the Ethereum network. If you haven't used it yet, you can download and install it ",paraId:3,tocIndex:1},{value:"here",paraId:3,tocIndex:1},{value:", and refer to the official website tutorial to complete the initial configuration.",paraId:3,tocIndex:1},{value:"After the MetaMask wallet is installed, we can see the MetaMask icon in the upper right corner of the browser, and it will also inject the ",paraId:4,tocIndex:1},{value:"window.ethereum",paraId:4,tocIndex:1},{value:" object into each page. This object is the interface for DApp to interact with the Ethereum network. We can use it to call Ethereum API. For example, we can initiate an ",paraId:4,tocIndex:1},{value:"eth_chainId",paraId:4,tocIndex:1},{value:" RPC request to get the ID of the current network:",paraId:4,tocIndex:1},{value:`await window.ethereum.request({ method: 'eth_chainId' }); // 0x1 represents the Ethereum mainnet
`,paraId:5,tocIndex:1},{value:"We can also get the account address and other information of the current wallet through the following code:",paraId:6,tocIndex:1},{value:`async function getAccount() {
  const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' }).catch((err) => {
    if (err.code === 4001) {
      // EIP-1193 userRejectedRequest error
      // If this happens, the user rejected the connection request.
      console.log('Please connect to MetaMask.');
    } else {
      console.error(err);
    }
  });
  const account = accounts[0];
  return account;
}

await getAccount(); // your account address
`,paraId:7,tocIndex:1},{value:"More wallet RPC and API can refer to ",paraId:8,tocIndex:1},{value:"MetaMask official documentation",paraId:8,tocIndex:1},{value:".",paraId:8,tocIndex:1},{value:"It is complex and error-prone to access the wallet directly with js. We recommend using ",paraId:9},{value:"Ant Design Web3",paraId:10},{value:" in the project to make DApp development more convenient.",paraId:9},{value:"Through the previous study, we learned that the blockchain is a decentralized network, and we can access data by accessing one of the nodes. There are many nodes in the Ethereum network. We can use ",paraId:11,tocIndex:2},{value:"ZAN",paraId:11,tocIndex:2},{value:", ",paraId:11,tocIndex:2},{value:"Infura",paraId:11,tocIndex:2},{value:" and other node service providers to obtain RPC interfaces.",paraId:11,tocIndex:2},{value:"In the ",paraId:12,tocIndex:2},{value:"document",paraId:12,tocIndex:2},{value:" provided by ZAN.top, we can easily test RPC, and call the method of smart contract through RPC.",paraId:12,tocIndex:2},{value:"In this section, we learned how DApp calls smart contracts. We can use wallet plug-ins or node RPC to call smart contracts. In the next section, we will learn how to use Ant Design Web3 to call smart contracts.",paraId:13,tocIndex:3}]},99004:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(64223);const t=[{value:"Decentralized Application (abbreviated as ",paraId:0,tocIndex:1},{value:"DApp",paraId:0,tocIndex:1},{value:') is an application built on a decentralized network, mainly composed of "smart contracts" and "front-end user interfaces".',paraId:0,tocIndex:1},{value:`
  `,paraId:1},{value:"Decentralized",paraId:2,tocIndex:2},{value:": DApp runs on a decentralized and open network, and no one or group can control it;",paraId:2,tocIndex:2},{value:"Deterministic",paraId:2,tocIndex:2},{value:": It performs the same function no matter what the execution environment is;",paraId:2,tocIndex:2},{value:"Turing complete",paraId:2,tocIndex:2},{value:": DApp can perform any operation or logic according to the required resources;",paraId:2,tocIndex:2},{value:"High availability",paraId:2,tocIndex:2},{value:": The front-end user interface of DApp can be accessed by anyone, and it will not stop service due to the downtime of a node;",paraId:2,tocIndex:2},{value:"Privacy",paraId:2,tocIndex:2},{value:": Users can remain anonymous when interacting with DApp without providing real identity information;",paraId:2,tocIndex:2},{value:'Generally speaking, the biggest difference between DApp and ordinary applications is its "decentralized" characteristics, that is, its server-side code should run in a non-centralized execution environment, such as the Ethereum blockchain network.',paraId:3,tocIndex:2},{value:"Taking DApp on Ethereum as an example, the service-side code of most applications is deployed on the Ethereum network and is completely open source, and the core data of DApp is also recorded on the chain, without the need for additional central database storage. As long as the Ethereum network node is confirmed, users can apply to execute any changes to the DApp function or established data.",paraId:4,tocIndex:2},{value:"Ideally, the data of DApp is stored in an encrypted manner in every node of the decentralized network-it can be a PC, mobile terminal, server or mining machine. This mechanism ensures that the data is not leaked or destroyed. These data belong to the user, and developers and maintainers do not have the right to misappropriate these data. In theory, it achieves that the ownership of the data belongs entirely to the user, which is almost impossible in the era of mobile Internet (Web2). Therefore, many people think that DApp is an important carrier of Web3, and the two ideas are the same.",paraId:5,tocIndex:2},{value:"Unfortunately, DApp also has many shortcomings:",paraId:6,tocIndex:2},{value:"More difficult to maintain",paraId:7,tocIndex:2},{value:": Once the service-side code of DApp is deployed on the blockchain network, it is difficult for developers to update the application logic (or underlying data). Even if vulnerabilities or security risks are found in the old version, theoretically, DApp The data on the data cannot be completely erased, which is significantly different from ordinary applications;",paraId:7,tocIndex:2},{value:"Large performance overhead",paraId:7,tocIndex:2},{value:": In order to achieve the security, integrity, transparency and reliability pursued by the blockchain, each node will run and store each transaction, which brings huge performance overhead, and it is difficult to expand more performance;",paraId:7,tocIndex:2},{value:"Poor user interface",paraId:7,tocIndex:2},{value:": DApp may require more technical means to achieve the interaction experience of ordinary applications, including browser wallet plug-ins and other additional user mental burdens;",paraId:7,tocIndex:2},{value:"To sum up, the advantages of DApp compared with ordinary applications are that the data is highly secure and cannot be tampered with, and it provides sufficient privacy and data ownership. The disadvantages are poor maintainability, slow running speed, and poor user experience. The smoothness of the experience is different from that of ordinary applications.",paraId:8,tocIndex:2},{value:"In order to help everyone build the front-end user interface of DApp better and interact with the blockchain network better, the Ant Design team has launched a set of Web3 front-end component libraries ",paraId:9},{value:"Ant Design Web3",paraId:9},{value:". If you have a certain understanding of blockchain basic knowledge, you can go directly to \u{1F449} ",paraId:9},{value:"Develop DApp",paraId:10},{value:".",paraId:9},{value:"Course: Blockchain and Smart Contracts",paraId:11,tocIndex:3},{value:"Course: How DApp calls smart contracts",paraId:12,tocIndex:3},{value:"Web3 Technology Service ZAN",paraId:13,tocIndex:3},{value:"Explore Decentralized Applications",paraId:13,tocIndex:3},{value:"Web3.0 Application Architecture",paraId:13,tocIndex:3},{value:"Popular DApp Tools",paraId:13,tocIndex:3}]},94216:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(65306);const t=[{value:"This course is mainly for students who have a certain foundation of front-end development, helping you move from Web2 to Web3 and gain the ability to develop DApp (decentralized application).",paraId:0,tocIndex:0},{value:"The course is divided into three parts:",paraId:1,tocIndex:0},{value:"What is DApp?",paraId:2,tocIndex:0},{value:" This part mainly introduces the basic concepts to help you understand the basic concepts of blockchain and smart contracts, and let you know what a DApp front-end development needs, and lay a foundation for the follow-up practice.",paraId:2,tocIndex:0},{value:"Develop DApp",paraId:2,tocIndex:0},{value:" This part will take you from 0 to 1 to build a DApp front-end, including initializing the project, connecting the blockchain account, and calling the contract. In this part, you don\u2019t need to care about the smart contract. We will provide a contract that has been deployed. You only need to focus on the development of the front end.",paraId:2,tocIndex:0},{value:"Develop smart contract",paraId:2,tocIndex:0},{value:" Students who are interested in blockchain can continue to learn this part and replace the contract developed in the second part with their own smart contracts.",paraId:2,tocIndex:0},{value:"The course will be based on ",paraId:3,tocIndex:0},{value:"Ant Design Web3",paraId:3,tocIndex:0},{value:" for explanation, so that you can get started more easily. Of course, this will not affect your understanding of the basic concepts. We will explain the relevant concepts in the course to ensure that you can master the basic knowledge of DApp development after the course is completed.",paraId:3,tocIndex:0},{value:"The course will guide you to finally create a minimum viable DApp, which implements the display and minting functions of an NFT. The following is an example of the final result:",paraId:4,tocIndex:0},{value:"https://ant-design-web3-demo.vercel.app/web3",paraId:5,tocIndex:0},{value:"This course has certain prerequisites, which require you to have a basic understanding of ",paraId:6,tocIndex:0},{value:"React",paraId:6,tocIndex:0},{value:" front-end development. If you are not familiar with React, you can learn the ",paraId:6,tocIndex:0},{value:"React official documentation",paraId:6,tocIndex:0},{value:" first.",paraId:6,tocIndex:0},{value:"If you find any problems in the course, please feel free to submit an ",paraId:7,tocIndex:1},{value:"issue",paraId:7,tocIndex:1},{value:". Of course, we welcome you to submit a Pull Request directly to us to make the course better. The content of the course is ",paraId:7,tocIndex:1},{value:"open source on GitHub",paraId:7,tocIndex:1},{value:". Whether it is course optimization, spelling and translation errors, you are welcome to submit a PR to us.",paraId:7,tocIndex:1}]},32368:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(49935);const t=[{value:"In order to make Ant Design Web3 more flexible, and to support more types of blockchains, as well as better maintenance. We split Ant Design Web3 into multiple packages.",paraId:0,tocIndex:1},{value:"Among them, ",paraId:1,tocIndex:1},{value:"@ant-design/web3",paraId:1,tocIndex:1},{value:" is the most core module, which contains a series of UI components. These UI components are pure React components, you can use them directly.",paraId:1,tocIndex:1},{value:"But if the developer only uses this part of the UI components, then the part that interacts with the blockchain still needs to be implemented by the developer. For example, the interface for connecting to the blockchain, getting blockchain information, etc. need to be implemented by the developer.",paraId:2,tocIndex:1},{value:"Therefore, we put forward the concept of an adapter, which can connect Ant Design Web3 UI components and the blockchain, so that these UI components can quickly connect to the blockchain. For example, when you use ",paraId:3,tocIndex:1},{value:"@ant-design/web3-wagmi",paraId:4,tocIndex:1},{value:", the ",paraId:3,tocIndex:1},{value:"Connector",paraId:3,tocIndex:1},{value:", ",paraId:3,tocIndex:1},{value:"NFTCard",paraId:3,tocIndex:1},{value:" and other components can be directly connected to Ethereum.",paraId:3,tocIndex:1},{value:"In the ",paraId:5,tocIndex:2},{value:"types",paraId:5,tocIndex:2},{value:" of ",paraId:5,tocIndex:2},{value:"@ant-design/web3-common",paraId:5,tocIndex:2},{value:", we define ",paraId:5,tocIndex:2},{value:"UniversalWeb3ProviderInterface",paraId:6,tocIndex:2},{value:".",paraId:5,tocIndex:2},{value:"In ",paraId:7,tocIndex:2},{value:"@ant-design/web3",paraId:7,tocIndex:2},{value:" you can use ",paraId:7,tocIndex:2},{value:"Web3ConfigProvider",paraId:8,tocIndex:2},{value:" to globally configure ",paraId:7,tocIndex:2},{value:"UniversalWeb3ProviderInterface",paraId:7,tocIndex:2},{value:", and Ant Design Web3 components will get the relevant content through React Context and use it. The adapter configures these properties for you to implement related functions, and of course you can also implement similar functions to the adapter by globally configuring ",paraId:7,tocIndex:2},{value:"Web3ConfigProvider",paraId:7,tocIndex:2},{value:". In fact, developing an adapter is based on this logic.",paraId:7,tocIndex:2},{value:"As mentioned in the above section, you can use ",paraId:9,tocIndex:3},{value:"Web3ConfigProvider",paraId:10,tocIndex:3},{value:" to provide UI components with related functions for interacting with the chain. We have currently implemented the adaptation of Ethereum based on ",paraId:9,tocIndex:3},{value:"wagmi",paraId:9,tocIndex:3},{value:". You can refer to its implementation to help Ant Design Web3 adapt to more blockchains. The following code is a simple implementation example of an adapter:",paraId:9,tocIndex:3},{value:"For more content, you can refer to the ",paraId:11},{value:"code",paraId:11},{value:" of ",paraId:11},{value:"@ant-design/web3-wagmi",paraId:11},{value:".",paraId:11}]},79334:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(98758);const t=[{value:"Ant Design Web3 is a Web3 React component library based on ",paraId:0,tocIndex:0},{value:"Ant Design",paraId:0,tocIndex:0},{value:", it provides a series of components that can help you quickly build decentralized applications (DApp).",paraId:0,tocIndex:0},{value:"You can use Ant Design Web3 in any of the following ways:",paraId:1,tocIndex:0},{value:"Use UI components directly through ",paraId:2,tocIndex:0},{value:"@ant-design/web3",paraId:2,tocIndex:0},{value:", such as ",paraId:2,tocIndex:0},{value:"ConnectButton",paraId:2,tocIndex:0},{value:", ",paraId:2,tocIndex:0},{value:"Address",paraId:2,tocIndex:0},{value:", etc. You can choose any way you like to connect to the blockchain, such as ",paraId:2,tocIndex:0},{value:"ether",paraId:2,tocIndex:0},{value:", ",paraId:2,tocIndex:0},{value:"viem",paraId:2,tocIndex:0},{value:" and ",paraId:2,tocIndex:0},{value:"web3.js",paraId:2,tocIndex:0},{value:". And any other chain's SDK, including non-EVM compatible blockchains, can also use Ant Design Web3 in this way.",paraId:2,tocIndex:0},{value:"Use the adapter provided by us with ",paraId:2,tocIndex:0},{value:"@ant-design/web3",paraId:2,tocIndex:0},{value:` to quickly connect to various blockchains without having to handle the related logic of connecting to the blockchain yourself.
`,paraId:2,tocIndex:0},{value:"Connect to EVM-compatible chains based on ",paraId:3,tocIndex:0},{value:"@ant-design/web3-wagmi",paraId:3,tocIndex:0},{value:" or ",paraId:3,tocIndex:0},{value:"@ant-design/web3-ethers",paraId:3,tocIndex:0},{value:" and ",paraId:3,tocIndex:0},{value:"@ant-design/web3-eth-web3js",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"Connect to Solana based on ",paraId:3,tocIndex:0},{value:"@ant-design/web3-solana",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"Connect to Bitcoin based on ",paraId:3,tocIndex:0},{value:"@ant-design/web3-bitcoin",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"Connect to Sui based on ",paraId:3,tocIndex:0},{value:"@ant-design/web3-sui",paraId:3,tocIndex:0},{value:".",paraId:3,tocIndex:0},{value:"Implement an adapter yourself to support connecting to more different blockchains, the specific implementation method can refer to ",paraId:2,tocIndex:0},{value:"Developing Adapters",paraId:4,tocIndex:0},{value:".",paraId:2,tocIndex:0},{value:"Use only the official adapter, such as ",paraId:2,tocIndex:0},{value:"@ant-design/web3-solana",paraId:2,tocIndex:0},{value:", and then completely customize the UI components, consume the capabilities provided by the adapter through ",paraId:2,tocIndex:0},{value:"Web3ConfigProvider",paraId:2,tocIndex:0},{value:".",paraId:2,tocIndex:0},{value:"Here are examples of using Ant Design Web3 through ",paraId:5,tocIndex:1},{value:"@ant-design/web3-wagmi",paraId:5,tocIndex:1},{value:":",paraId:5,tocIndex:1},{value:"If you want to try more refined theme control, you can try our ",paraId:6},{value:"Theme Editor",paraId:7},{value:", or check out the ",paraId:6},{value:"Theme",paraId:8},{value:" documentation.",paraId:6},{value:"If you want to further try how to use Ant Design Web3 in your own project, or want to create a project based on Ant Design Web3 from 0, you can continue reading ",paraId:9},{value:"Quick Start",paraId:10},{value:", wish you a pleasant surfing in Web3! \u{1F30A}\u{1F30A}\u{1F30A}",paraId:9},{value:"Why use Ant Design Web3?",paraId:11,tocIndex:2},{value:"\u{1F3A8} Provides high-quality UI components based on Ant Design. ",paraId:12,tocIndex:2},{value:"Ant Design",paraId:12,tocIndex:2},{value:" is a high-quality UI basic component set that supports flexible theme customization and has nearly 100,000 GitHub stars and many users, which gives Ant Design Web3 a basic quality guarantee.",paraId:12,tocIndex:2},{value:"\u{1F4E6} Out-of-the-box experience, not only provides ",paraId:12,tocIndex:2},{value:"ConnectModal",paraId:12,tocIndex:2},{value:" for connecting wallets, but also ",paraId:12,tocIndex:2},{value:"Address",paraId:12,tocIndex:2},{value:", ",paraId:12,tocIndex:2},{value:"NFTCard",paraId:12,tocIndex:2},{value:" and other components, continuously iterates to cover the needs you may encounter in DApp development, bringing the R&D experience of Web2 to Web3. We also pay attention to user experience and bring the user experience of Web2 to Web3.",paraId:12,tocIndex:2},{value:"\u{1F50C} Flexible and reliable architecture design, UI layer and adapter layer are separated, which makes it possible to support different blockchains and different chain SDKs, and also allows components to be continuously and stably iterated and upgraded.",paraId:12,tocIndex:2},{value:"There are more features:",paraId:13,tocIndex:2},{value:"Feature",paraId:14,tocIndex:2},{value:"Supported",paraId:14,tocIndex:2},{value:"Theme customization",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Internationalization",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"100% test coverage",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"TypeScript support",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Responsive design",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Quick and easy wallet connection component",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"NFT component",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"More practical components such as Address",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Rich icon library",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Support EIP6963",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Support WalletConnect",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Support Ethereum and its L2",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Support Bitcoin",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Support Solana",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Support TON",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Adapt to more non-EVM chains",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Course",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Use with wagmi",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Use with ethers",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Use with web3.js",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Use with umi",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Use with Next.js",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Use with Remix",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2},{value:"Use with Tailwind CSS",paraId:14,tocIndex:2},{value:"\u2705",paraId:14,tocIndex:2}]},14998:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(81286);const t=[{value:"Modified files under ",paraId:0,tocIndex:1},{value:"packages",paraId:0,tocIndex:1},{value:"@ant-design/web3-assets",paraId:1,tocIndex:1},{value:"@ant-design/web3-common",paraId:1,tocIndex:1},{value:"@ant-design/web3-icons",paraId:1,tocIndex:1},{value:"@ant-design/web3-solana",paraId:1,tocIndex:1},{value:"@ant-design/web3-wagmi",paraId:1,tocIndex:1},{value:"@ant-design/web3",paraId:1,tocIndex:1},{value:"First of all, you need to run the command:",paraId:2,tocIndex:2},{value:`MacBook-Pro ant-design-web3 % pnpm changeset

> @ant-design/web3-docs@0.0.0 changeset ant-design-web3
> changeset
`,paraId:3},{value:"Select the modified package by space and press enter to confirm\u3002",paraId:4},{value:`\u{1F98B}  Which packages would you like to include? \u2026
\u25C9 changed packages
  \u25C9 @ant-design/web3
\u25EF unchanged packages
  \u25EF @ant-design/web3-assets
  \u25EF @ant-design/web3-common
  \u25EF @ant-design/web3-icons
  \u25EF @ant-design/web3-solana
  \u25EF @ant-design/web3-wagmi
`,paraId:5},{value:`\u{1F98B}  Which packages would you like to include? \xB7 @ant-design/web3
\u{1F98B}  Which packages should have a major bump? \u2026
\u25EF all packages
  \u25EF @ant-design/web3@1.9.0
`,paraId:6},{value:"At this point, we should skip it with a carriage return. For bugfixes in general, we select the last ",paraId:7},{value:"patch",paraId:7},{value:" version, and we select ",paraId:7},{value:"minor",paraId:7},{value:" for newer features.\u3002",paraId:7},{value:`\u{1F98B}  Which packages should have a major bump? \xB7 No items were selected
\u{1F98B}  Which packages should have a minor bump? \xB7 No items were selected
\u{1F98B}  The following packages will be patch bumped:
\u{1F98B}  @ant-design/web3@1.9.0
\u{1F98B}  Please enter a summary for this change (this will be in the changelogs).
\u{1F98B}    (submit empty line to open external editor)
\u{1F98B}  Summary \u203A
`,paraId:8},{value:"As a final step, we submit message in the ",paraId:9},{value:"Summary",paraId:9},{value:" that conforms to ",paraId:9},{value:"Angular's commit convention",paraId:9},{value:".",paraId:9},{value:`\u{1F98B}  Summary \u203A feat: support more icons
`,paraId:10}]},54974:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(79465);const t=[{value:"The crypto industry is evolving rapidly with new projects and standards emerging all the time. We welcome community contributions of icons to better support these projects.",paraId:0,tocIndex:0},{value:"The ",paraId:1,tocIndex:1},{value:"packages/icons",paraId:1,tocIndex:1},{value:" directory corresponds to the ",paraId:1,tocIndex:1},{value:"@ant-design/web3-icons",paraId:1,tocIndex:1},{value:" package, and new icons should be added in this directory, specifically:",paraId:1,tocIndex:1},{value:`
  `,paraId:2},{value:`
    `,paraId:3},{value:`
      src
      `,paraId:3},{value:`
        `,paraId:4},{value:`
          components
          `,paraId:4},{value:`
            `,paraId:5},{value:"YOUR-ICON.tsx",paraId:5},{value:"Add icon components",paraId:5},{value:`
          `,paraId:5},{value:`
        `,paraId:4},{value:`
        `,paraId:4},{value:`
          svgs
          `,paraId:4},{value:`
            `,paraId:6},{value:"YOUR-ICON.svg",paraId:6},{value:"Add icon svg",paraId:6},{value:`
          `,paraId:6},{value:`
        `,paraId:4},{value:`
      `,paraId:4},{value:`
    `,paraId:3},{value:`
    `,paraId:3},{value:"index.ts",paraId:3},{value:"export it",paraId:3},{value:`
  `,paraId:3},{value:"Add new svg in ",paraId:7,tocIndex:2},{value:"svgs",paraId:7,tocIndex:2},{value:" folder, file name should be the same as icon name, and use the ",paraId:7,tocIndex:2},{value:"kebab-case",paraId:7,tocIndex:2},{value:" style for file name.",paraId:7,tocIndex:2},{value:"Also, please note that do not use ",paraId:8,tocIndex:2},{value:"id",paraId:8,tocIndex:2},{value:" in the ",paraId:8,tocIndex:2},{value:"style",paraId:8,tocIndex:2},{value:" attribute of the svg, because the ",paraId:8,tocIndex:2},{value:"react-inline-svg-unique-id",paraId:8,tocIndex:2},{value:" plugin does not support ",paraId:8,tocIndex:2},{value:"style",paraId:8,tocIndex:2},{value:". We recommend that the properties in ",paraId:8,tocIndex:2},{value:"style",paraId:8,tocIndex:2},{value:" be taken out as separate attributes as much as possible:",paraId:8,tocIndex:2},{value:`- <circle style="fill:url(#ant-web3-icon-aave-circle-colorful-3);" cx="400" cy="400" r="388"/> # bad
+ <circle fill="url(#ant-web3-icon-aave-circle-colorful-3)" cx="400" cy="400" r="388"/> # good
`,paraId:9,tocIndex:2},{value:"Execute the following command to automatically generate react components based on svg.",paraId:10,tocIndex:3},{value:`import * as React from 'react';
import AntdIcon from '@ant-design/icons';
import { type IconBaseProps } from '@ant-design/icons/lib/components/Icon';
import { ConfigProvider } from 'antd';
import classnames from 'classnames';

import SVGComponent from '../svgs/aave-circle-colorful.svg';

export const AAVECircleColorful = React.forwardRef<HTMLSpanElement, IconBaseProps>((props, ref) => {
  const { getPrefixCls } = React.useContext(ConfigProvider.ConfigContext);
  const prefixCls = getPrefixCls('web3-icon-aave-circle-colorful');
  return (
    <AntdIcon
      {...props}
      className={classnames(prefixCls, props.className)}
      ref={ref}
      component={SVGComponent}
    />
  );
});
AAVECircleColorful.displayName = 'AAVECircleColorful';
`,paraId:11},{value:"There are four types through the display form of icon:",paraId:12,tocIndex:4},{value:"circle colorful",paraId:13,tocIndex:4},{value:"colorful",paraId:13,tocIndex:4},{value:"circle filled",paraId:13,tocIndex:4},{value:"filled",paraId:13,tocIndex:4},{value:"The naming specification is: ",paraId:14,tocIndex:4},{value:"{project name}-{type name}",paraId:14,tocIndex:4},{value:", such as ",paraId:14,tocIndex:4},{value:"aave-circle-colorful",paraId:14,tocIndex:4},{value:". Using the correct naming specification will be automatically classified in the document.",paraId:14,tocIndex:4},{value:"Based on the functions of the corresponding projects of icons, the following diversions are made:",paraId:15,tocIndex:4},{value:"Chain Icons",paraId:16,tocIndex:4},{value:"Token Icons",paraId:16,tocIndex:4},{value:"Tool Icons",paraId:16,tocIndex:4},{value:"If you need to make a special declaration, you can change it in the ",paraId:17,tocIndex:4},{value:".dumi/theme/builtins/IconSearch/fields.ts",paraId:17,tocIndex:4},{value:" file, otherwise it will be classified as the default classification.",paraId:17,tocIndex:4},{value:"Verify whether the icon is displayed correctly in the local debugging environment.",paraId:18,tocIndex:5}]},80356:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(77966);const t=[{value:"All work on Ant Design Web3 happens directly on ",paraId:0,tocIndex:1},{value:"GitHub",paraId:0,tocIndex:1},{value:". Both core team members and external contributors send pull requests which go through the same review process.",paraId:0,tocIndex:1},{value:"When submitting a PR, please execute ",paraId:1,tocIndex:2},{value:"pnpm changeset",paraId:1,tocIndex:2},{value:" to generate the changelog first, and then submit the PR.",paraId:1,tocIndex:2},{value:" We manage version releases through ",paraId:1,tocIndex:2},{value:"changesets",paraId:1,tocIndex:2},{value:". Executing this command will generate changelog files under ",paraId:1,tocIndex:2},{value:".changeset",paraId:1,tocIndex:2},{value:", and these files will be automatically merged into ",paraId:1,tocIndex:2},{value:"CHANGELOG.md",paraId:1,tocIndex:2},{value:" when released. But not every PR needs a changelog, for example, PRs that do not involve package content modifications such as documents and official websites do not need to execute this command. For more changesets usage guide, please refer to: ",paraId:1,tocIndex:2},{value:"How to add Changelog",paraId:1,tocIndex:2},{value:".",paraId:1,tocIndex:2},{value:"Go to ",paraId:2,tocIndex:3},{value:"issues",paraId:2,tocIndex:3},{value:" to find issues marked with ",paraId:2,tocIndex:3},{value:"development task",paraId:2,tocIndex:3},{value:" and ",paraId:2,tocIndex:3},{value:"bug",paraId:2,tocIndex:3},{value:" labels, assign them to yourself, and complete the development as soon as possible within ",paraId:2,tocIndex:3},{value:"three days",paraId:2,tocIndex:3},{value:" and submit a PR. Except for bugs, all development tasks should be split into small tasks that can be completed within one hour or one day. Assigning an issue to yourself means claiming the task, please make sure you understand the task before claiming it, and if you have any questions, you can discuss it in the issue. Also try to arrange time reasonably to ensure that you can submit a high-quality PR within three days. PR needs to be assigned to the core development members, and can be merged after at least one person approves (Approved).",paraId:2,tocIndex:3},{value:"Novices can first look for issues with the ",paraId:3,tocIndex:3},{value:"good first issue",paraId:3,tocIndex:3},{value:" label, and issues with the ",paraId:3,tocIndex:3},{value:"help wanted",paraId:3,tocIndex:3},{value:" label need more participation from the community.",paraId:3,tocIndex:3},{value:"We are using ",paraId:4,tocIndex:4},{value:"GitHub Issues",paraId:4,tocIndex:4},{value:" for bug tracking. To report a bug, submit a new issue. If you want a quick resolution to the bug you've discovered, please provide a specific reproduction example.",paraId:4,tocIndex:4},{value:"Before reporting a bug, please search existing ",paraId:5,tocIndex:4},{value:"issues",paraId:5,tocIndex:4},{value:" to see if it has already been reported.",paraId:5,tocIndex:4},{value:"Create a new issue to track the clear feature, and add the ",paraId:6,tocIndex:5},{value:"feature",paraId:6,tocIndex:5},{value:" label. Before development, the task needs to be split. ",paraId:6,tocIndex:5},{value:"Ensure that the split of each task can be completed within one hour or one day.",paraId:6,tocIndex:5},{value:" Create a separate issue for each split task and associate it, and add the ",paraId:6,tocIndex:5},{value:"development task",paraId:6,tocIndex:5},{value:" label to facilitate multi-person collaboration. If the feature is small, you may not need to split it, and directly add the ",paraId:6,tocIndex:5},{value:"development task",paraId:6,tocIndex:5},{value:" label. Adding the ",paraId:6,tocIndex:5},{value:"development task",paraId:6,tocIndex:5},{value:" label means that no further discussion is needed and you can go directly to development. If the split task is not clear, please discuss it in the issue. If the entire feature is not clear, please close the issue and refer to the instructions below to discuss in the discussion.",paraId:6,tocIndex:5},{value:"For unclear features and proposals that need to be discussed, please create a discussion in the ",paraId:7,tocIndex:5},{value:"discussion",paraId:7,tocIndex:5},{value:".",paraId:7,tocIndex:5},{value:"The release is responsible by the core members, and one version is released every week. If there is an urgent bug fix, it can be released at any time. The release complies with the ",paraId:8,tocIndex:6},{value:"Semver",paraId:8,tocIndex:6},{value:" specification.",paraId:8,tocIndex:6},{value:"The release is published by executing ",paraId:9,tocIndex:6},{value:"pnpm run release",paraId:9,tocIndex:6},{value:", which will first execute ",paraId:9,tocIndex:6},{value:"changeset version",paraId:9,tocIndex:6},{value:" to merge the changelog under ",paraId:9,tocIndex:6},{value:".changeset",paraId:9,tocIndex:6},{value:" into ",paraId:9,tocIndex:6},{value:"CHANGELOG.md",paraId:9,tocIndex:6},{value:" and update the version of the package. Then execute ",paraId:9,tocIndex:6},{value:"changeset publish",paraId:9,tocIndex:6},{value:" to publish to npm and add the corresponding tag.",paraId:9,tocIndex:6},{value:"After the release, the related modifications are submitted to the main branch, and the corresponding tag also needs to be pushed to GitHub. A ",paraId:10,tocIndex:6},{value:"Release",paraId:10,tocIndex:6},{value:" is created based on the tag of the new version of ",paraId:10,tocIndex:6},{value:"@ant-design/web3",paraId:10,tocIndex:6},{value:".",paraId:10,tocIndex:6},{value:"If it is an alpha or beta version, please execute ",paraId:11,tocIndex:6},{value:"pnpm run release:alpha",paraId:11,tocIndex:6},{value:" or ",paraId:11,tocIndex:6},{value:"pnpm run release:beta",paraId:11,tocIndex:6},{value:" to release.",paraId:11,tocIndex:6},{value:"The core members are adjusted irregularly according to their activities. PRs must be ",paraId:12,tocIndex:7},{value:"reviewed and approved by at least one core member",paraId:12,tocIndex:7},{value:" before merged. The issues in the discussion area also need to be confirmed by at least two core members before they can be converted into development tasks.",paraId:12,tocIndex:7},{value:"The current core members are:",paraId:13,tocIndex:7},{value:"@yutingzhao1991",paraId:14,tocIndex:7},{value:"@kiner-tang",paraId:14,tocIndex:7},{value:"@jeasonstudio",paraId:14,tocIndex:7},{value:"@gin-lsl",paraId:14,tocIndex:7},{value:"@liangchaofei",paraId:14,tocIndex:7},{value:"@thinkasany",paraId:14,tocIndex:7},{value:"Design-related issues can @ our designers:",paraId:15,tocIndex:7},{value:"@wenqing993",paraId:16,tocIndex:7},{value:"feature",paraId:17,tocIndex:8},{value:" Independent new features.",paraId:17,tocIndex:8},{value:"bug",paraId:17,tocIndex:8},{value:" Defects or bugs.",paraId:17,tocIndex:8},{value:"development task",paraId:17,tocIndex:8},{value:" The development workload can be completed within one hour or one day, and no further discussion is required. The task can be directly developed.",paraId:17,tocIndex:8},{value:"help wanted",paraId:17,tocIndex:8},{value:" Problems that need the community to help solve.",paraId:17,tocIndex:8},{value:"good first issue",paraId:17,tocIndex:8},{value:" Small problems that are very suitable for new contributors to get started.",paraId:17,tocIndex:8},{value:"Someone working on it",paraId:17,tocIndex:8},{value:" Someone is already working on this issue, please don't repeat it.",paraId:17,tocIndex:8},{value:"wontfix",paraId:17,tocIndex:8},{value:" This will not be fixed.",paraId:17,tocIndex:8},{value:"question",paraId:17,tocIndex:8},{value:" More information is needed.",paraId:17,tocIndex:8},{value:"invalid",paraId:17,tocIndex:8},{value:" Invalid issue.",paraId:17,tocIndex:8},{value:"duplicate",paraId:17,tocIndex:8},{value:" Duplicate issue.",paraId:17,tocIndex:8},{value:"enhancement",paraId:17,tocIndex:8},{value:" New feature.",paraId:17,tocIndex:8},{value:"documentation",paraId:17,tocIndex:8},{value:" Documentation related.",paraId:17,tocIndex:8},{value:"dependencies",paraId:17,tocIndex:8},{value:" Dependency related.",paraId:17,tocIndex:8},{value:"Need Changelog",paraId:17,tocIndex:8},{value:" Need to generate changelog (after adding this label, the bot will automatically add relevant operation instructions comments).",paraId:17,tocIndex:8},{value:"site",paraId:17,tocIndex:8},{value:" Some issues about the website.",paraId:17,tocIndex:8}]},62227:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(11262);const t=[{value:"We provide multiple ways to support multilingual internationalization:",paraId:0,tocIndex:0},{value:"Through the ",paraId:1,tocIndex:0},{value:"locale",paraId:1,tocIndex:0},{value:" configuration provided by the component, you can implement internationalization within the component.",paraId:1,tocIndex:0},{value:"Through the ",paraId:1,tocIndex:0},{value:"locale",paraId:1,tocIndex:0},{value:" configuration in ",paraId:1,tocIndex:0},{value:"Web3ConfigProvider",paraId:2,tocIndex:0},{value:", you can implement global configuration.",paraId:1,tocIndex:0},{value:"Use the built-in language pack. In ",paraId:1,tocIndex:0},{value:"@ant-design/web3",paraId:1,tocIndex:0},{value:", we provide some multilingual support built-in.",paraId:1,tocIndex:0},{value:"For the specific language configuration content supported, please refer to the ",paraId:3},{value:"Locale",paraId:3},{value:" type definition. For languages and components that are not yet supported, please submit a ",paraId:3},{value:"Pull request",paraId:3},{value:" to support.",paraId:3},{value:"In addition, in ",paraId:4},{value:"@ant-design/web3-wagmi",paraId:4},{value:", ",paraId:4},{value:"WagmiWeb3ConfigProviderProps",paraId:4},{value:" will pass ",paraId:4},{value:"locale",paraId:4},{value:" to ",paraId:4},{value:"Web3ConfigProvider",paraId:4},{value:" to simplify your use.",paraId:4}]},21319:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(36363);const t=[{value:"When your project needs to support ",paraId:0,tocIndex:0},{value:"USDT",paraId:0,tocIndex:0},{value:" payments and needs to support ",paraId:0,tocIndex:0},{value:"USDT/USDC",paraId:0,tocIndex:0},{value:" on multiple chains, the following can help you.",paraId:0,tocIndex:0},{value:"You can use our official adapter with ",paraId:1,tocIndex:0},{value:"@ant-design/web3",paraId:1,tocIndex:0},{value:" to quickly connect to various blockchains to support ",paraId:1,tocIndex:0},{value:"USDT/USDC",paraId:1,tocIndex:0},{value:" payments on these chains at the same time.",paraId:1,tocIndex:0},{value:"You can do this:",paraId:2,tocIndex:0}]},17879:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(79235);const t=[{value:"Before you start, it is recommended to learn ",paraId:0,tocIndex:0},{value:"React",paraId:0,tocIndex:0},{value:" first, and install and configure ",paraId:0,tocIndex:0},{value:"Node.js",paraId:0,tocIndex:0},{value:" v18 or above correctly. The official guide assumes that you have a medium knowledge of HTML, CSS and JavaScript, and have basically mastered the correct development method of React family bucket. In addition, this guide assumes that you have initialized a project through a React framework (such as ",paraId:0,tocIndex:0},{value:"Next.js",paraId:0,tocIndex:0},{value:" or ",paraId:0,tocIndex:0},{value:"umi",paraId:0,tocIndex:0},{value:").",paraId:0,tocIndex:0},{value:"You can install the relevant dependencies under the root directory of the project through ",paraId:1,tocIndex:1},{value:"npm",paraId:1,tocIndex:1},{value:" or ",paraId:1,tocIndex:1},{value:"pnpm",paraId:1,tocIndex:1},{value:" and other package management tools, as shown below:",paraId:1,tocIndex:1},{value:"@ant-design/web3",paraId:2,tocIndex:2},{value:" is a pure UI component, you can use it directly, for example, you can use ",paraId:2,tocIndex:2},{value:"Address",paraId:2,tocIndex:2},{value:":",paraId:2,tocIndex:2},{value:"@ant-design/web3",paraId:3,tocIndex:3},{value:" does not provide the ability to connect to the blockchain itself. It is a pure UI component library. We designed it from the beginning to consider that it can be adapted to different blockchains in the future. But we officially implemented an adapter ",paraId:3,tocIndex:3},{value:"@ant-design/web3-wagmi",paraId:3,tocIndex:3},{value:" based on ",paraId:3,tocIndex:3},{value:"wagmi",paraId:3,tocIndex:3},{value:". It has built-in connection capabilities with EVM compatible chains, and you can connect to Ethereum through it.",paraId:3,tocIndex:3},{value:"In ",paraId:4,tocIndex:3},{value:"@ant-design/web3-wagmi",paraId:4,tocIndex:3},{value:", we expose a component ",paraId:4,tocIndex:3},{value:"WagmiWeb3ConfigProvider",paraId:4,tocIndex:3},{value:", which encapsulates wagmi's ",paraId:4,tocIndex:3},{value:"WagmiConfig",paraId:4,tocIndex:3},{value:".",paraId:4,tocIndex:3},{value:"As long as you use ",paraId:5,tocIndex:3},{value:"WagmiWeb3ConfigProvider",paraId:5,tocIndex:3},{value:" as ",paraId:5,tocIndex:3},{value:"WagmiConfig",paraId:5,tocIndex:3},{value:", the Ant Design Web3 components in your application can automatically connect to the blockchain.",paraId:5,tocIndex:3},{value:"Here is an example. When you use ",paraId:6,tocIndex:3},{value:"WagmiWeb3ConfigProvider",paraId:6,tocIndex:3},{value:" at the outermost layer of a React application, the ",paraId:6,tocIndex:3},{value:"NFTImage",paraId:6,tocIndex:3},{value:" in your application can automatically get the relevant information of the NFT from Ethereum and display it.",paraId:6,tocIndex:3},{value:"Of course, compared with ",paraId:7},{value:"NFTImage",paraId:7},{value:", we may use more components of the connection blockchain button. You can read the specific documentation of the ",paraId:7},{value:"Connector",paraId:8},{value:" component to learn how to use it.",paraId:7},{value:"If you're using recommended App Router, add the ",paraId:9,tocIndex:4},{value:'"use client"',paraId:9,tocIndex:4},{value:" directive at the top of the file to use Provider such as ",paraId:9,tocIndex:4},{value:"WagmiWeb3ConfigProvider",paraId:9,tocIndex:4},{value:", considering that ",paraId:9,tocIndex:4},{value:"createContext",paraId:9,tocIndex:4},{value:" only works in Client Components.",paraId:9,tocIndex:4},{value:"In ",paraId:10,tocIndex:4},{value:"Next.js",paraId:10,tocIndex:4},{value:", based on its build mechanism, you may encounter the following errors when introducing packages such as ",paraId:10,tocIndex:4},{value:"@ant-design/web3",paraId:10,tocIndex:4},{value:":",paraId:10,tocIndex:4},{value:"Error: require() of ES Module ... from ... not supported.",paraId:11,tocIndex:4},{value:"SyntaxError: Cannot use import statement outside a module",paraId:11,tocIndex:4},{value:"Because Next.js does not go through the relevant compilation logic when loading dependent packages under ",paraId:12,tocIndex:4},{value:"node_modules",paraId:12,tocIndex:4},{value:". You may need to manually add the ",paraId:12,tocIndex:4},{value:"transpilePackages",paraId:12,tocIndex:4},{value:" configuration in Next.js configuration file ",paraId:12,tocIndex:4},{value:"next.config.js",paraId:12,tocIndex:4},{value:":",paraId:12,tocIndex:4},{value:`/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
+  transpilePackages: [
+    "@ant-design",
+    "antd",
+    "rc-util",
+    "rc-pagination",
+    "rc-picker",
+  ],
};

module.exports = nextConfig;
`,paraId:13,tocIndex:4},{value:"You can also follow the following related issues to get the latest progress:",paraId:14,tocIndex:4},{value:"https://github.com/ant-design/ant-design/issues/46053",paraId:15,tocIndex:4},{value:"https://github.com/vercel/next.js/issues/58817",paraId:15,tocIndex:4},{value:"You may encounter the following error when using ",paraId:16,tocIndex:5},{value:"@ant-design/web3",paraId:16,tocIndex:5},{value:" in ",paraId:16,tocIndex:5},{value:"Remix",paraId:16,tocIndex:5},{value:" (Not the Remix IDE of Ethereum):",paraId:16,tocIndex:5},{value:"Error: require() of ES Module ... from ... not supported.",paraId:17,tocIndex:5},{value:"SyntaxError: Cannot use import statement outside a module",paraId:17,tocIndex:5},{value:"This is because Remix does not go through the relevant compilation logic when loading dependent packages under ",paraId:18,tocIndex:5},{value:"node_modules",paraId:18,tocIndex:5},{value:". You may need to manually add the ",paraId:18,tocIndex:5},{value:"serverDependenciesToBundle",paraId:18,tocIndex:5},{value:" configuration in Remix configuration file ",paraId:18,tocIndex:5},{value:"remix.config.js",paraId:18,tocIndex:5},{value:":",paraId:18,tocIndex:5},{value:`/** @type {import('@remix-run/dev').AppConfig} */
export default {
  ignoredRouteFiles: ["**/.*"],
  // appDirectory: "app",
  // assetsBuildDirectory: "public/build",
  // publicPath: "/build/",
  // serverBuildPath: "build/index.js",
+  serverDependenciesToBundle: [/^@ant-design/, /^rc-/, "^antd"],
};
`,paraId:19,tocIndex:5},{value:"You can also follow the following related issues to get the latest progress:",paraId:20,tocIndex:5},{value:"https://github.com/ant-design/ant-design-icons/issues/605",paraId:21,tocIndex:5}]},14371:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(94786);const t=[{value:"Ant Design Web3 is developed based on Ant Design, and you can set the theme of Ant Design Web3 by configuring ",paraId:0,tocIndex:0},{value:"Ant Design's theme",paraId:0,tocIndex:0},{value:".",paraId:0,tocIndex:0},{value:"Ant Design Web3 has built-in support for dark mode, which inherits the configuration from Ant Design.",paraId:1,tocIndex:1},{value:"You can fully customize Ant Design's ",paraId:2,tocIndex:3},{value:"Design Token",paraId:2,tocIndex:3},{value:", which we will inherit and use in Ant Design Web3. If you find any unsupported or incorrectly used Design Tokens, please ",paraId:2,tocIndex:3},{value:"submit an issue",paraId:2,tocIndex:3},{value:" to let us know.",paraId:2,tocIndex:3},{value:"We provide a ",paraId:3,tocIndex:3},{value:"theme editor",paraId:4,tocIndex:3},{value:" where you can modify Design Tokens online and see the effects.",paraId:3,tocIndex:3},{value:"In addition to Ant Design's Design Tokens, Ant Design Web3 also offers some additional Design Tokens that you can customize. The Design Tokens for components are continuously being supplemented, and you can view the supported Design Tokens on the corresponding component documentation pages. If you find any unsupported or incorrectly used Design Tokens, please ",paraId:5,tocIndex:4},{value:"submit an issue",paraId:5,tocIndex:4},{value:" to let us know. Below is a specific example, you can customize the Design Tokens of Ant Design and Ant Design Web3 to achieve flexible custom styles. More examples can be viewed by visiting ",paraId:5,tocIndex:4},{value:"Try It Out",paraId:6,tocIndex:4},{value:".",paraId:5,tocIndex:4}]},6828:function(d,a,e){e.r(a),e.d(a,{texts:function(){return t}});var n=e(27119);const t=[]}}]);
